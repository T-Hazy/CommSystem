<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TouchSocket.Http</name>
    </assembly>
    <members>
        <member name="T:TouchSocket.Http.HttpBase">
            <summary>
            Http基础头部
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpBase.MaxCacheSize">
            <summary>
            定义缓存的最大大小，这里设置为100MB。
            这个值是根据预期的内存使用量和性能需求确定的。
            过大的缓存可能会导致内存使用率过高，影响系统的其他部分。
            过小的缓存则可能无法有效减少对外部资源的访问，降低程序的运行效率。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpBase.ServerVersion">
            <summary>
            服务器版本
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.Accept">
            <summary>
            可接受MIME类型
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.AcceptEncoding">
            <summary>
            允许编码
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.CanRead">
            <summary>
            能否读取。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.CanWrite">
            <summary>
            能否写入。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.Client">
            <summary>
            客户端
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.ContentCompleted">
            <summary>
            内容填充完成
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.ContentLength">
            <summary>
            内容长度
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.ContentType">
            <summary>
            内容类型
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.Headers">
            <summary>
            请求头集合
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.KeepAlive">
            <summary>
            保持连接。
            <para>
            一般的，当是http1.1时，如果没有显式的Connection: close，即返回true。当是http1.0时，如果没有显式的Connection: Keep-Alive，即返回false。
            </para>
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.Protocols">
            <summary>
            协议名称，默认HTTP
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.ProtocolVersion">
            <summary>
            HTTP协议版本，默认1.1
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.RequestLine">
            <summary>
            请求行
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.LoadHeaderProperties">
            <summary>
            读取信息
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.GetContent(System.Threading.CancellationToken)">
            <summary>
            获取一次性内容。
            </summary>
            <returns>返回一个只读内存块，该内存块包含具体的字节内容。</returns>
            <param name="cancellationToken">一个CancellationToken对象，用于取消异步操作。</param>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.GetContentAsync(System.Threading.CancellationToken)">
            <summary>
            获取一次性内容。
            </summary>
            <returns>返回一个包含字节的只读内存的任务。</returns>
            <param name="cancellationToken">用于取消异步操作的令牌。</param>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.SetContent(System.ReadOnlyMemory{System.Byte}@)">
            <summary>
            设置一次性内容
            </summary>
            <param name="content">要设置的内容，作为只读内存块传入</param>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.ReadAsync(System.Threading.CancellationToken)">
            <summary>
            异步读取HTTP块段的内容。
            </summary>
            <param name="cancellationToken">用于取消异步操作的令牌。</param>
            <returns>返回一个<see cref="T:TouchSocket.Core.IBlockResult`1"/>，表示异步读取操作的结果。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.ReadCopyToAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            异步读取并复制流数据
            </summary>
            <param name="stream">需要读取并复制的流</param>
            <param name="cancellationToken">异步操作的取消令牌</param>
            <returns>一个异步任务，表示复制操作的完成</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.WriteAsync(System.ReadOnlyMemory{System.Byte})">
            <summary>
            异步写入字节序列到流中。
            </summary>
            <param name="memory">待写入的字节序列，使用<see cref="T:System.ReadOnlyMemory`1"/>类型以提高性能并支持不可变性。</param>
            <returns>返回一个Task对象，表示异步写入操作的完成。</returns>
        </member>
        <member name="T:TouchSocket.Http.HttpContext">
            <summary>
            Http上下文
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpContext.#ctor(TouchSocket.Http.HttpRequest)">
            <summary>
            构造函数
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpContext.#ctor(TouchSocket.Http.HttpRequest,TouchSocket.Http.HttpResponse)">
            <summary>
            构造函数
            </summary>
            <param name="request"></param>
            <param name="response"></param>
        </member>
        <member name="P:TouchSocket.Http.HttpContext.Request">
            <summary>
            Http请求
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpContext.Response">
            <summary>
            Http响应
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpMethod">
            <summary>
            HttpMethod
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpMethod.m_value">
            <summary>
            值
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpMethod.Get">
            <summary>
            Get
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpMethod.Post">
            <summary>
            Post
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpMethod.Put">
            <summary>
            Put
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpMethod.Delete">
            <summary>
            Delete
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpMethod.#ctor(System.String)">
            <summary>
            表示
            </summary>
            <param name="value">值</param>
        </member>
        <member name="M:TouchSocket.Http.HttpMethod.ToString">
            <summary>
            转换为字符串
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpMethod.GetHashCode">
            <summary>
            获取哈希码
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.HttpProxy">
            <summary>
            Http代理
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpProxy.#ctor(TouchSocket.Sockets.IPHost)">
            <summary>
            不带基本验证的代理
            </summary>
            <param name="host"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpProxy.#ctor(TouchSocket.Sockets.IPHost,System.String,System.String)">
            <summary>
            带基本验证的代理
            </summary>
            <param name="host"></param>
            <param name="userName"></param>
            <param name="passWord"></param>
        </member>
        <member name="P:TouchSocket.Http.HttpProxy.Credential">
            <summary>
            验证代理
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpProxy.Host">
            <summary>
            代理的地址
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpRange">
            <summary>
            Range: bytes=0-499 表示第 0-499 字节范围的内容
            Range: bytes=500-999 表示第 500-999 字节范围的内容
            Range: bytes=-500 表示最后 500 字节的内容
            Range: bytes=500- 表示从第 500 字节开始到文件结束部分的内容
            Range: bytes=0-0,-1 表示第一个和最后一个字节
            Range: bytes=500-600,601-999 同时指定几个范围
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpRange.GetRanges(System.String,System.Int64)">
            <summary>
            转换获取的集合
            </summary>
            <param name="rangeStr"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpRange.GetRange(System.String,System.Int64)">
            <summary>
            转换获取的集合
            </summary>
            <param name="rangeStr"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Http.HttpRange.Start">
            <summary>
            起始位置
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRange.Length">
            <summary>
            长度
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpRequest">
            <summary>
            HTTP请求定义
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.#ctor">
            <summary>
            HttpRequest类的构造函数。
            </summary>
            <remarks>
            初始化HttpRequest对象的基本属性。
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.#ctor(TouchSocket.Http.HttpClientBase)">
            <summary>
            初始化 HttpRequest 实例。
            </summary>
            <param name="httpClientBase">提供底层 HTTP 通信功能的 HttpClientBase 实例。</param>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.Client">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.Forms">
            <summary>
            表单数据
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.Method">
            <summary>
            HTTP请求方式。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.Params">
            <summary>
            Body参数
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.Query">
            <summary>
            url参数
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.RelativeURL">
            <summary>
            相对路径（不含参数）
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.URL">
            <summary>
            Url全地址，包含参数
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.Build(TouchSocket.Core.ByteBlock)">
            <summary>
             构建响应数据。
            <para>当数据较大时，不建议这样操作，可直接<see cref="M:TouchSocket.Http.HttpRequest.WriteAsync(System.ReadOnlyMemory{System.Byte})"/></para>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.BuildAsBytes">
            <summary>
            构建数据为字节数组。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.GetContentAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.ReadAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.SetContent(System.ReadOnlyMemory{System.Byte}@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.SetProxyHost(System.String)">
            <summary>
            设置代理Host
            </summary>
            <param name="host">代理服务器的地址</param>
            <returns>返回当前HttpRequest实例，以支持链式调用</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.SetUrl(System.String)">
            <summary>
            设置Url，可带参数
            </summary>
            <param name="url">要设置的URL地址</param>
            <returns>返回当前HttpRequest实例，支持链式调用</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.ToString">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.ResetHttp">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.WriteAsync(System.ReadOnlyMemory{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.LoadHeaderProperties">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.BuildHeader(TouchSocket.Core.ByteBlock)">
            <summary>
            构建响应头部
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.HttpResponse">
            <summary>
            Http响应
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.#ctor(TouchSocket.Http.HttpClientBase)">
            <summary>
            Http响应
            </summary>
            <param name="httpClientBase"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.#ctor(TouchSocket.Http.HttpRequest)">
            <summary>
            从<see cref="T:TouchSocket.Http.HttpRequest"/>创建一个Http响应
            </summary>
            <param name="request"></param>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.Client">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.IsChunk">
            <summary>
            是否分块
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.IsProxyAuthenticationRequired">
            <summary>
            是否代理权限验证。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.IsRedirect">
            <summary>
            是否重定向
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.Responsed">
            <summary>
            是否已经响应数据。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.StatusCode">
            <summary>
            状态码，默认200
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.StatusMessage">
            <summary>
            状态消息，默认Success
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.AnswerAsync">
            <summary>
            构建数据并回应。
            <para>该方法仅在具有Client实例时有效。</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.Build(TouchSocket.Core.ByteBlock,System.Boolean)">
            <summary>
             构建响应数据。
            <para>当数据较大时，不建议这样操作，可直接<see cref="M:TouchSocket.Http.HttpResponse.WriteAsync(System.ReadOnlyMemory{System.Byte})"/></para>
            </summary>
            <param name="byteBlock"></param>
            <param name="responsed"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.BuildAsBytes">
            <summary>
            构建数据为字节数组。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.CompleteChunkAsync">
            <summary>
            当传输模式是Chunk时，用于结束传输。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.GetContentAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.ReadAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.SetContent(System.ReadOnlyMemory{System.Byte}@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.ToString">
            <summary>
            输出
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.WriteAsync(System.ReadOnlyMemory{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.LoadHeaderProperties">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.HttpResponseResult">
            <summary>
            HTTP响应结果结构体，实现了IDisposable接口，用于在使用后释放相关资源。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpResponseResult.m_action">
            <summary>
            一个操作委托，用于在Dispose时执行特定操作以释放资源。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponseResult.#ctor(TouchSocket.Http.HttpResponse,System.Action)">
            <summary>
            初始化HttpResponseResult结构体。
            </summary>
            <param name="response">HTTP响应对象，用于处理HTTP请求的响应。</param>
            <param name="action">一个Action委托，将在Dispose方法中调用，用于执行资源释放操作。</param>
        </member>
        <member name="P:TouchSocket.Http.HttpResponseResult.Response">
            <summary>
            获取HTTP响应对象。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponseResult.Dispose">
            <summary>
            执行资源释放操作。调用构造函数中传入的Action委托以执行具体释放逻辑。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpTools">
            <summary>
            Http工具
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpTools.GetContentTypeFromExtension(System.String)">
            <summary>
            从扩展名获取ContentType
            </summary>
            <param name="extension"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.MultifileCollection">
            <summary>
            多文件集合
            </summary>
        </member>
        <member name="M:TouchSocket.Http.MultifileCollection.#ctor(TouchSocket.Http.HttpRequest)">
            <summary>
            多文件集合
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:TouchSocket.Http.MultifileCollection.GetEnumerator">
            <summary>
            获取一个迭代器。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.TouchSocketHttpUtility">
            <summary>
            TouchSocketHttp辅助工具类
            </summary>
        </member>
        <member name="P:TouchSocket.Http.TouchSocketHttpUtility.CRLF">
            <summary>
            获取一个只读的字节序列，表示回车换行(CRLF)。
            </summary>
            <value>
            一个包含回车和换行字节的只读字节序列。
            </value>
        </member>
        <member name="F:TouchSocket.Http.TouchSocketHttpUtility.NoCacheMaxSize">
            <summary>
            非缓存上限
            </summary>
        </member>
        <member name="T:TouchSocket.Http.AuthenticationChallenge">
            <summary>
            处理代理认证凭证
            </summary>
        </member>
        <member name="M:TouchSocket.Http.AuthenticationChallenge.#ctor(System.String,TouchSocket.Http.NetworkCredential,System.UInt32)">
            <summary>
            构造
            </summary>
            <param name="value">服务器返回的凭证认证类型</param>
            <param name="credential">基本凭证用户名密码</param>
            <param name="nonceCount">暂时不知道是什么</param>
        </member>
        <member name="P:TouchSocket.Http.AuthenticationChallenge.NonceCount">
            <summary>
            暂时不知
            </summary>
        </member>
        <member name="P:TouchSocket.Http.AuthenticationChallenge.Parameters">
            <summary>
            其实用不用他都一样
            </summary>
        </member>
        <member name="P:TouchSocket.Http.AuthenticationChallenge.Type">
            <summary>
            凭证类型
            </summary>
        </member>
        <member name="M:TouchSocket.Http.AuthenticationChallenge.ToString">
            <summary>
            转换成凭证本文
            </summary>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:TouchSocket.Http.AuthenticationType">
            <summary>
            代理身份认证类型
            </summary>
        </member>
        <member name="F:TouchSocket.Http.AuthenticationType.None">
            <summary>
            不允许身份认证
            </summary>
        </member>
        <member name="F:TouchSocket.Http.AuthenticationType.Digest">
            <summary>
            指定摘要身份验证。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.AuthenticationType.Basic">
            <summary>
            指定基本身份验证。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.AuthenticationType.Anonymous">
            <summary>
            指定匿名身份验证。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.NetworkCredential">
            <summary>
            代理身份认证
            </summary>
        </member>
        <member name="M:TouchSocket.Http.NetworkCredential.#ctor(System.String,System.String,System.String,System.String[])">
            <summary>
            构造
            </summary>
            <param name="username"></param>
            <param name="password"></param>
            <param name="domain">基本认证应该不需要这个</param>
            <param name="roles"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="P:TouchSocket.Http.NetworkCredential.Username">
            <summary>
            凭证用户名
            </summary>
        </member>
        <member name="P:TouchSocket.Http.NetworkCredential.Password">
            <summary>
            凭证密码
            </summary>
        </member>
        <member name="P:TouchSocket.Http.NetworkCredential.Domain">
            <summary>
            Domain
            </summary>
        </member>
        <member name="P:TouchSocket.Http.NetworkCredential.Roles">
            <summary>
            Roles
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpClient">
            <summary>
            Http客户端
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpClient.ConnectAsync(System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClient.RequestAsync(TouchSocket.Http.HttpRequest,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClient.RequestContentAsync(TouchSocket.Http.HttpRequest,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.HttpClientBase">
            <summary>
            Http客户端基类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.SetWarpAdapter(TouchSocket.Core.SingleStreamDataHandlingAdapter)">
            <summary>
            设置用于处理单流数据的转换适配器
            </summary>
            <param name="adapter">要设置的SingleStreamDataHandlingAdapter实例</param>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.ProtectedRequestAsync(TouchSocket.Http.HttpRequest,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送Http请求，并仅等待响应头
            </summary>
            <param name="request">要发送的HttpRequest对象</param>
            <param name="millisecondsTimeout">超时时间，单位为毫秒，默认为10秒</param>
            <param name="token">用于取消操作的CancellationToken</param>
            <returns>返回HttpResponseResult对象，包含响应结果和释放锁的方法</returns>
            <exception cref="T:System.TimeoutException">当操作超时时抛出</exception>
            <exception cref="T:System.OperationCanceledException">当操作被取消时抛出</exception>
            <exception cref="T:System.Exception">当发生其他异常时抛出</exception>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.ProtectedRequestContentAsync(TouchSocket.Http.HttpRequest,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送Http请求，并等待全部响应
            </summary>
            <param name="request">Http请求对象</param>
            <param name="millisecondsTimeout">超时时间，单位为毫秒，默认为10秒</param>
            <param name="token">取消令牌</param>
            <returns>返回Http响应结果</returns>
            <exception cref="T:System.TimeoutException">当操作超时时抛出</exception>
            <exception cref="T:System.OperationCanceledException">当操作被取消时抛出</exception>
            <exception cref="T:System.Exception">当发生其他异常时抛出</exception>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.OnTcpConnecting(TouchSocket.Sockets.ConnectingEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.OnTcpClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.OnTcpReceived(TouchSocket.Sockets.ReceivedDataEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.HttpService`1">
            <summary>
            HTTP/HTTPS服务器
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpService">
            <summary>
            HTTP/HTTPS服务器
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpService.NewClient">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.HttpSessionClient">
            <summary>
            http辅助类
            </summary>
            <summary>
            http辅助类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnReceivedHttpRequest(TouchSocket.Http.HttpContext)">
            <summary>
            当收到到Http请求时。覆盖父类方法将不会触发插件。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnTcpClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnTcpConnecting(TouchSocket.Sockets.ConnectingEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnTcpReceived(TouchSocket.Sockets.ReceivedDataEventArgs)">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.HttpSessionClient.WebSocket">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnWebSocketHandshaking(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在WebSocket握手过程中触发插件执行异步任务
            </summary>
            <param name="webSocket">WebSocket对象，用于进行WebSocket通信</param>
            <param name="e">HTTP上下文参数，提供关于HTTP请求和响应的信息</param>
            <returns>返回一个任务，该任务在插件处理完成后结束</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnWebSocketHandshaked(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            当WebSocket握手成功时，触发相关插件的异步事件。
            </summary>
            <param name="webSocket">WebSocket对象，表示握手成功的WebSocket连接。</param>
            <param name="e">HttpContextEventArgs对象，包含HTTP上下文信息。</param>
            <returns>一个表示事件处理完成的Task对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnWebSocketReceived(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <summary>
            虚拟异步方法：当WebSocket接收到数据时触发
            </summary>
            <param name="webSocket">提供数据接收的WebSocket实例</param>
            <param name="e">包含接收数据的事件参数</param>
            <remarks>
            此方法通过调用插件管理器来通知所有实现了<see cref="T:TouchSocket.Http.WebSockets.IWebSocketReceivedPlugin"/>接口的插件，
            使它们能够处理接收到的WebSocket数据。这样做可以扩展数据处理逻辑，而无需直接修改此方法。
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnWebSocketClosing(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Core.MsgEventArgs)">
            <summary>
            调用前触发WebSocket关闭时的插件
            </summary>
            <param name="webSocket">当前的WebSocket实例</param>
            <param name="e">关闭事件的参数</param>
            <returns>异步任务</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnWebSocketClosed(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Core.MsgEventArgs)">
            <summary>
            虚拟异步方法：处理WebSocket关闭事件
            </summary>
            <param name="webSocket">关闭的WebSocket实例</param>
            <param name="e">WebSocket关闭事件的附加参数</param>
            <remarks>
            此方法通过调用插件管理器，触发IWebSocketClosedPlugin接口的实现来处理WebSocket关闭事件
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.SwitchProtocolToWebSocketAsync(TouchSocket.Http.HttpContext)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.IHttpClient">
            <summary>
            Http终端接口
            </summary>
        </member>
        <member name="M:TouchSocket.Http.IHttpClient.RequestAsync(TouchSocket.Http.HttpRequest,System.Int32,System.Threading.CancellationToken)">
            <summary>
            发起请求
            </summary>
            <param name="request">请求体</param>
            <param name="millisecondsTimeout">等待超时时间</param>
            <param name="token">结束等待令箭</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.IHttpClient.RequestContentAsync(TouchSocket.Http.HttpRequest,System.Int32,System.Threading.CancellationToken)">
            <summary>
            发起请求，并获取数据体
            </summary>
            <param name="request">请求体</param>
            <param name="millisecondsTimeout">等待超时时间</param>
            <param name="token">结束等待令箭</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.IHttpService`1">
            <summary>
            IHttpService
            </summary>
        </member>
        <member name="T:TouchSocket.Http.IHttpService">
            <summary>
            IHttpService
            </summary>
        </member>
        <member name="T:TouchSocket.Http.IHttpServiceBase">
            <summary>
            IHttpServiceBase
            </summary>
        </member>
        <member name="T:TouchSocket.Http.IHttpSession">
            <summary>
            Http终端基础接口
            </summary>
        </member>
        <member name="T:TouchSocket.Http.IHttpSessionClient">
            <summary>
            Http服务器终端接口
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IHttpSessionClient.WebSocket">
            <summary>
            当该连接是WebSocket时，可获取该对象，否则为null。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.IHttpSessionClient.SwitchProtocolToWebSocketAsync(TouchSocket.Http.HttpContext)">
            <summary>
            转化Protocol协议标识为<see cref="F:TouchSocket.Sockets.Protocol.WebSocket"/>
            </summary>
            <param name="httpContext">Http上下文</param>
        </member>
        <member name="T:TouchSocket.Http.CorsBuilder">
            <summary>
            CorsBuilder
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsBuilder.Credentials">
            <summary>
            允许客户端携带验证信息
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsBuilder.Headers">
            <summary>
            请求头
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsBuilder.Methods">
            <summary>
            允许跨域的方法。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsBuilder.Origin">
            <summary>
            允许跨域的域名
            </summary>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.AllowAnyHeaders">
            <summary>
            允许所有的Header
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.AllowAnyMethod">
            <summary>
            允许任何Method。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.AllowAnyOrigin">
            <summary>
            允许所有的源
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.AllowCredentials">
            <summary>
            允许客户端携带验证信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.WithHeaders(System.String[])">
            <summary>
            允许跨域的Header
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.WithMethods(System.String[])">
            <summary>
            允许跨域的方法。
            例如“PUT,POST,GET,DELETE,OPTIONS,HEAD,PATCH”
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.WithOrigin(System.String)">
            <summary>
            允许跨域的域名
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.Build">
            <summary>
            构建
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.CorsOptions">
            <summary>
            跨域相关配置
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsOptions.CorsPolicys">
            <summary>
            跨域策略集
            </summary>
        </member>
        <member name="M:TouchSocket.Http.CorsOptions.Add(System.String,System.Action{TouchSocket.Http.CorsBuilder})">
            <summary>
            添加跨域策略
            </summary>
            <param name="policyName"></param>
            <param name="corsBuilderAction"></param>
        </member>
        <member name="M:TouchSocket.Http.CorsOptions.Add(System.String,TouchSocket.Http.CorsPolicy)">
            <summary>
            添加跨域策略
            </summary>
            <param name="policyName"></param>
            <param name="corsResult"></param>
        </member>
        <member name="T:TouchSocket.Http.CorsPlugin">
            <summary>
            可以配置跨域的插件
            </summary>
        </member>
        <member name="M:TouchSocket.Http.CorsPlugin.#ctor(TouchSocket.Http.ICorsService,System.String)">
            <summary>
            可以配置跨域的插件
            </summary>
            <param name="corsService"></param>
            <param name="policyName"></param>
        </member>
        <member name="M:TouchSocket.Http.CorsPlugin.Loaded(TouchSocket.Core.IPluginManager)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.CorsPolicy">
            <summary>
            CorsResult
            </summary>
        </member>
        <member name="M:TouchSocket.Http.CorsPolicy.#ctor(System.Boolean,System.String,System.String,System.String)">
            <summary>
            CorsResult
            </summary>
            <param name="credentials"></param>
            <param name="headers"></param>
            <param name="methods"></param>
            <param name="origin"></param>
        </member>
        <member name="P:TouchSocket.Http.CorsPolicy.Credentials">
            <summary>
            允许客户端携带验证信息
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsPolicy.Headers">
            <summary>
            请求头
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsPolicy.Methods">
            <summary>
            允许跨域的方法。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsPolicy.Origin">
            <summary>
            允许跨域的域名
            </summary>
        </member>
        <member name="M:TouchSocket.Http.CorsPolicy.Apply(TouchSocket.Http.HttpContext)">
            <summary>
            应用跨域策略
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:TouchSocket.Http.ICorsService">
            <summary>
            跨域相关的服务类接口
            </summary>
        </member>
        <member name="M:TouchSocket.Http.ICorsService.GetPolicy(System.String)">
            <summary>
            按照策略名称，获取策略
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.HttpClientDataHandlingAdapter">
            <summary>
            Http客户端数据处理适配器
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpClientDataHandlingAdapter.CanSplicingSend">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClientDataHandlingAdapter.OnLoaded(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClientDataHandlingAdapter.PreviewReceivedAsync(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
            <param name="byteBlock"></param>
        </member>
        <member name="T:TouchSocket.Http.HttpClientDataHandlingAdapter2">
            <summary>
            Http客户端数据处理适配器
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpClientDataHandlingAdapter2.CanSplicingSend">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClientDataHandlingAdapter2.OnLoaded(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.HttpServerDataHandlingAdapter">
            <summary>
            Http服务器数据处理适配器
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpServerDataHandlingAdapter.CanSplicingSend">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpServerDataHandlingAdapter.OnLoaded(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpServerDataHandlingAdapter.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpServerDataHandlingAdapter.PreviewReceivedAsync(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
            <param name="byteBlock"></param>
        </member>
        <member name="T:TouchSocket.Http.HttpContextEventHandler`1">
            <summary>
            HTTP上下文事件委托
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Http.HttpHeaders">
            <summary>
            请求头枚举
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.CacheControl">
            <summary>
            Cache-Control 标头，指定请求/响应链上所有缓存控制机制必须服从的指令。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Connection">
            <summary>
            Connection 标头，指定特定连接需要的选项。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Date">
            <summary>
            Date 标头，指定开始创建请求的日期和时间。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.KeepAlive">
            <summary>
            Keep-Alive 标头，指定用以维护持久性连接的参数。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Pragma">
            <summary>
            Pragma 标头，指定可应用于请求/响应链上的任何代理的特定于实现的指令。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Trailer">
            <summary>
            Trailer 标头，指定标头字段显示在以 chunked 传输编码方式编码的消息的尾部。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.TransferEncoding">
            <summary>
            Transfer-Encoding 标头，指定对消息正文应用的转换的类型（如果有）。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Upgrade">
            <summary>
            Upgrade 标头，指定客户端支持的附加通信协议。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Via">
            <summary>
            Via 标头，指定网关和代理程序要使用的中间协议。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Warning">
            <summary>
            Warning 标头，指定关于可能未在消息中反映的消息的状态或转换的附加信息。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Allow">
            <summary>
            Allow 标头，指定支持的 HTTP 方法集。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentLength">
            <summary>
            Content-Length 标头，指定伴随正文数据的长度（以字节为单位）。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentType">
            <summary>
            Content-Type 标头，指定伴随正文数据的 MIME 类型。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentEncoding">
            <summary>
            Content-Encoding 标头，指定已应用于伴随正文数据的编码。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentLanguage">
            <summary>
            Content-Langauge 标头，指定伴随正文数据的自然语言。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentLocation">
            <summary>
            Content-Location 标头，指定可从其中获得伴随正文的 URI。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentMd5">
            <summary>
            Content-MD5 标头，指定伴随正文数据的 MD5 摘要，用于提供端到端消息完整性检查。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentRange">
            <summary>
            Content-Range 标头，指定在完整正文中应用伴随部分正文数据的位置。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Expires">
            <summary>
            Expires 标头，指定日期和时间，在此之后伴随的正文数据应视为陈旧的。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.LastModified">
            <summary>
            Last-Modified 标头，指定上次修改伴随的正文数据的日期和时间。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Accept">
            <summary>
            Accept 标头，指定响应可接受的 MIME 类型。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.AcceptCharset">
            <summary>
            Accept-Charset 标头，指定响应可接受的字符集。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.AcceptEncoding">
            <summary>
            Accept-Encoding 标头，指定响应可接受的内容编码。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.AcceptLanguage">
            <summary>
            Accept-Langauge 标头，指定响应首选的自然语言。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Authorization">
            <summary>
            Authorization 标头，指定客户端为向服务器验证自身身份而出示的凭据。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Cookie">
            <summary>
            Cookie 标头，指定向服务器提供的 Cookie 数据。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Expect">
            <summary>
            Expect 标头，指定客户端要求的特定服务器行为。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.From">
            <summary>
            From 标头，指定控制请求用户代理的用户的 Internet 电子邮件地址。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Host">
            <summary>
            Host 标头，指定所请求资源的主机名和端口号。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfMatch">
            <summary>
            If-Match 标头，指定仅当客户端的指示资源的缓存副本是最新的时，才执行请求的操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfModifiedSince">
            <summary>
            If-Modified-Since 标头，指定仅当自指示的数据和时间之后修改了请求的资源时，才执行请求的操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfNoneMatch">
            <summary>
            If-None-Match 标头，指定仅当客户端的指示资源的缓存副本都不是最新的时，才执行请求的操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfRange">
            <summary>
            If-Range 标头，指定如果客户端的缓存副本是最新的，仅发送指定范围的请求资源。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfUnmodifiedSince">
            <summary>
            If-Unmodified-Since 标头，指定仅当自指示的日期和时间之后修改了请求的资源时，才执行请求的操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.MaxForwards">
            <summary>
            Max-Forwards 标头，指定一个整数，表示此请求还可转发的次数。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ProxyAuthorization">
            <summary>
            Proxy-Authorization 标头，指定客户端为向代理验证自身身份而出示的凭据。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Referer">
            <summary>
            Referer 标头，指定从中获得请求 URI 的资源的 URI。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Range">
            <summary>
            Range 标头，指定代替整个响应返回的客户端请求的响应的子范围。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Te">
            <summary>
            TE 标头，指定响应可接受的传输编码方式。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Translate">
            <summary>
            Translate 标头，与 WebDAV 功能一起使用的 HTTP 规范的 Microsoft 扩展。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.UserAgent">
            <summary>
            User-Agent 标头，指定有关客户端代理的信息。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.AcceptRanges">
            <summary>
            Accept-Ranges 标头，指定服务器接受的范围。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Age">
            <summary>
            Age 标头，指定自起始服务器生成响应以来的时间长度（以秒为单位）。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ETag">
            <summary>
            Etag 标头，指定请求的变量的当前值。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Location">
            <summary>
            Location 标头，指定为获取请求的资源而将客户端重定向到的 URI。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ProxyAuthenticate">
            <summary>
            Proxy-Authenticate 标头，指定客户端必须对代理验证其自身。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.RetryAfter">
            <summary>
            Retry-After 标头，指定某个时间（以秒为单位）或日期和时间，在此时间之后客户端可以重试其请求。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Server">
            <summary>
            Server 标头，指定关于起始服务器代理的信息。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.SetCookie">
            <summary>
            Set-Cookie 标头，指定提供给客户端的 Cookie 数据。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Vary">
            <summary>
            Vary 标头，指定用于确定缓存的响应是否为新响应的请求标头。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.WwwAuthenticate">
            <summary>
            WWW-Authenticate 标头，指定客户端必须对服务器验证其自身。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Origin">
            <summary>
            Origin。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentDisposition">
            <summary>
            Content-Disposition
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpContextEventArgs">
            <summary>
            Http请求事件类
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpContextEventArgs.Context">
            <summary>
            Http上下文
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpContextEventArgs.#ctor(TouchSocket.Http.HttpContext)">
            <summary>
            构造函数
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:TouchSocket.Http.HttpClientExtension">
            <summary>
            HttpClient 扩展类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpClientExtension.GetByteArrayAsync(TouchSocket.Http.IHttpClient,System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步获取URL的字节数组表示形式。
            </summary>
            <param name="httpClient">发起HTTP请求的客户端。</param>
            <param name="url">要请求的URL。</param>
            <param name="millisecondsTimeout">请求超时时间，以毫秒为单位，默认为10秒。</param>
            <param name="token">用于取消操作的取消令牌。</param>
            <returns>包含从URL获取的字节的数组。</returns>
            <exception cref="T:System.Exception">如果HTTP请求失败，将抛出异常。</exception>
        </member>
        <member name="M:TouchSocket.Http.HttpClientExtension.GetStringAsync(TouchSocket.Http.IHttpClient,System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步获取指定URL的字符串内容。
            </summary>
            <param name="httpClient">用于发送HTTP请求的客户端。</param>
            <param name="url">要请求的URL。</param>
            <param name="millisecondsTimeout">请求超时时间，以毫秒为单位，默认为10秒。</param>
            <param name="token">用于取消操作的取消令牌。</param>
            <returns>返回从指定URL获取的字符串。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpClientExtension.GetFileAsync(TouchSocket.Http.IHttpClient,TouchSocket.Http.HttpRequest,System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步获取HTTP请求的文件内容
            </summary>
            <param name="httpClient">HTTP客户端接口</param>
            <param name="request">HTTP请求对象</param>
            <param name="stream">用于存储文件内容的目标流</param>
            <param name="millisecondsTimeout">请求超时时间，以毫秒为单位，默认为10秒</param>
            <param name="token">用于取消操作的取消令牌</param>
            <returns>返回一个异步任务</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpClientExtension.GetFileAsync(TouchSocket.Http.IHttpClient,System.String,System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步获取URL指定的文件，并将其内容写入提供的流中。
            </summary>
            <param name="httpClient">用于发送HTTP请求的客户端。</param>
            <param name="url">要获取的文件的URL。</param>
            <param name="stream">将文件内容写入的流。</param>
            <param name="millisecondsTimeout">操作超时时间，以毫秒为单位，默认为10秒。</param>
            <param name="token">用于取消异步操作的取消令牌。</param>
            <returns>返回一个Task对象，表示异步操作。</returns>
        </member>
        <member name="T:TouchSocket.Http.HttpContainerExtension">
            <summary>
            HttpContainerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpContainerExtension.AddCors(TouchSocket.Core.IRegistrator,System.Action{TouchSocket.Http.CorsOptions})">
            <summary>
            向注册器中添加跨域服务。
            </summary>
            <param name="registrator"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.HttpExtensions">
            <summary>
            Http扩展辅助
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AddHeader``1(``0,System.String,System.String)">
            <summary>
            添加Header参数
            </summary>
            <param name="request"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AddHeader``1(``0,TouchSocket.Http.HttpHeaders,System.String)">
            <summary>
            添加Header参数
            </summary>
            <param name="request"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromJson``1(``0,System.String)">
            <summary>
            从Json
            </summary>
            <param name="request"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromText``1(``0,System.String)">
            <summary>
            从文本
            </summary>
            <param name="request"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromXML``1(``0,System.String)">
            <summary>
            从Xml格式
            </summary>
            <param name="request"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetBody(TouchSocket.Http.HttpBase)">
            <summary>
            获取Body的字符串
            </summary>
            <param name="httpBase"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetBodyAsync(TouchSocket.Http.HttpBase)">
            <summary>
            异步获取 HTTP 请求的主体内容。
            </summary>
            <param name="httpBase">HttpBase 实例，用于发起 HTTP 请求。</param>
            <returns>返回主体内容的字符串表示，如果内容为空则返回 null。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetBoundary(TouchSocket.Http.HttpBase)">
            <summary>
            当数据类型为multipart/form-data时，获取boundary
            </summary>
            <param name="httpBase"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetContent``1(``0,System.String,System.Text.Encoding)">
            <summary>
            设置内容
            </summary>
            <param name="httpBase">HttpBase类型的对象，其内容需要被设置</param>
            <param name="content">要设置的内容，以字符串形式传入</param>
            <param name="encoding">内容的编码方式，如果未指定，则默认使用UTF-8编码</param>
            <returns>返回设置后的内容对象，允许进行方法链调用</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetContentLength``1(``0,System.Int64)">
            <summary>
            设置数据体长度
            </summary>
            <param name="httpBase">要设置数据体长度的HttpBase对象</param>
            <param name="value">数据体的长度</param>
            <returns>返回修改后的HttpBase对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetContentTypeByExtension``1(``0,System.String)">
            <summary>
            从扩展名设置内容类型，必须以“.”开头
            </summary>
            <param name="httpBase">要设置内容类型的 HttpBase 对象</param>
            <param name="extension">文件扩展名，必须以“.”开头，用于确定内容类型</param>
            <returns>返回设置后的 HttpBase 对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AddQuery``1(``0,System.String,System.String)">
            <summary>
            添加Query参数
            </summary>
            <param name="request">请求对象</param>
            <param name="key">参数键</param>
            <param name="value">参数值</param>
            <returns>返回添加了参数的请求对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetMultifileCollection``1(``0)">
            <summary>
            获取多文件集合。如果不存在，则返回null。
            </summary>
            <typeparam name="TRequest">请求类型，必须继承自HttpRequest。</typeparam>
            <param name="request">请求对象，用于提取多文件集合。</param>
            <returns>多文件集合对象，如果请求中不存在多文件数据，则返回null。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.InitHeaders``1(``0)">
            <summary>
            初始化常规的请求头。
            <para>包含：</para>
            <list type="number">
            <item>Connection:keep-alive</item>
            <item>Pragma:no-cache</item>
            <item>UserAgent:TouchSocket.Http</item>
            </list>
            </summary>
            <param name="request">要初始化请求头的请求对象。</param>
            <returns>返回初始化后的请求对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetHost``1(``0,System.String)">
            <summary>
            添加Host请求头
            </summary>
            <param name="request">要添加Host请求头的HttpRequest对象</param>
            <param name="host">要设置的Host值</param>
            <returns>返回修改后的HttpRequest对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.UrlEquals``1(``0,System.String)">
            <summary>
            对比不包含参数的Url。其中有任意一方为null，则均返回False。
            </summary>
            <param name="request">请求对象，用于获取待对比的相对URL。</param>
            <param name="url">待对比的目标URL字符串。</param>
            <returns>如果两个URL都不为null且在忽略大小写的情况下相等，则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsDelete``1(``0)">
            <summary>
            将请求对象的方法设置为Delete。
            </summary>
            <param name="request">要设置为Delete方法的请求对象。</param>
            <returns>返回修改过方法类型的请求对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsGet``1(``0)">
            <summary>
            将请求方法设置为GET
            </summary>
            <param name="request">要转换为GET方法的请求对象</param>
            <returns>修改过方法的请求对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsMethod``1(``0,System.String)">
            <summary>
            将指定的请求对象设置为指定的HTTP方法。
            该方法扩展了HttpRequest类，允许在调用时动态改变请求的方法类型。
            </summary>
            <param name="request">要修改的HttpRequest对象。</param>
            <param name="method">要设置的HTTP方法，如"GET"、"POST"等。</param>
            <returns>修改后的HttpRequest对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsPost``1(``0)">
            <summary>
            将请求对象设置为POST方法
            </summary>
            <param name="request">要设置为POST方法的请求对象</param>
            <returns>修改过方法类型的请求对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsPut``1(``0)">
            <summary>
            将请求对象的方法设置为PUT
            </summary>
            <param name="request">要修改的请求对象</param>
            <returns>修改后的请求对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsDelete``1(``0)">
            <summary>
            判断当前请求是否为Delete操作
            </summary>
            <param name="request">请求对象，用于检查请求方法</param>
            <returns>如果请求方法为Delete，则返回true；否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsGet``1(``0)">
            <summary>
            判断当前请求是否为GET请求
            </summary>
            <param name="request">请求对象，用于检查其请求方法</param>
            <returns>如果请求方法是GET，则返回true；否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsMethod``1(``0,System.String)">
            <summary>
            判断指定的请求是否为指定的HTTP方法类型
            </summary>
            <param name="request">待检查的HTTP请求</param>
            <param name="method">要判断的HTTP方法类型，如"GET"、"POST"</param>
            <returns>如果请求的方法类型与指定的方法一致，则返回true；否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsPost``1(``0)">
            <summary>
            判断当前请求是否为POST请求
            </summary>
            <param name="request">请求对象，泛型参数，必须是HttpRequest的子类或实现</param>
            <returns>如果当前请求方法是POST，则返回true；否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsPut``1(``0)">
            <summary>
            判断请求是否为PUT方法
            </summary>
            <param name="request">请求对象，类型为HttpRequest的泛型实例</param>
            <returns>如果请求方法为PUT，则返回true；否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsUpgrade``1(``0)">
            <summary>
            判断请求头中是否包含升级连接
            </summary>
            <param name="request">请求对象，泛型参数，要求是HttpRequest的子类或实现</param>
            <returns>如果请求头中包含升级连接，则返回true；否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsAcceptGzip``1(``0)">
            <summary>
            判断请求是否接受Gzip压缩。
            </summary>
            <param name="request">请求对象，用于获取请求的接受编码。</param>
            <returns>如果请求接受Gzip压缩，则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsSuccess``1(``0,System.Nullable{System.Int32})">
            <summary>
            判断返回的状态码是否为成功。
            </summary>
            <param name="response">要判断的响应对象。</param>
            <param name="status">
            可选参数，指定期望的状态码。
            当不指定具体的状态码时，只要状态码在200-299之间则为<see langword="true"/>。
            当指定时，状态码不仅必须要在200-299之间，还必须是指定的状态码才会返回<see langword="true"/>。
            </param>
            <returns>返回一个布尔值，表示响应状态码是否表示成功。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetContentTypeFromFileName``1(``0,System.String)">
            <summary>
            设置文件类型。
            </summary>
            <param name="response">要设置的HTTP响应对象。</param>
            <param name="fileName">文件名，用于确定Content-Type和文件下载时的提示名称。</param>
            <returns>返回设置后的HTTP响应对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetStatus``1(``0,System.Int32,System.String)">
            <summary>
            设置状态，并且附带时间戳。
            </summary>
            <param name="response">要设置状态的HttpResponse对象。</param>
            <param name="status">HTTP响应状态码。</param>
            <param name="msg">状态描述信息。</param>
            <returns>返回修改后的HttpResponse对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetStatus``1(``0)">
            <summary>
            设置默认Success状态，并且附带时间戳。
            </summary>
            <typeparam name="TResponse">泛型参数，表示HttpResponse的类型。</typeparam>
            <param name="response">要设置状态的HttpResponse对象。</param>
            <returns>返回设置后的HttpResponse对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetGzipContent``1(``0,System.Byte[])">
            <summary>
            为指定的HttpResponse对象设置Gzip压缩内容
            </summary>
            <typeparam name="TResponse">HttpResponse的类型</typeparam>
            <param name="response">要设置内容的HttpResponse对象</param>
            <param name="gzipContent">要设置的Gzip压缩内容</param>
            <returns>返回设置了Gzip内容的HttpResponse对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.UrlNotFind``1(``0)">
            <summary>
            设置HTTP响应为404 Not Found
            此方法用于处理路径文件未找到的情况，它将HTTP响应的状态码设置为404，并在响应体中返回一个简单的HTML页面，指示文件未找到。
            </summary>
            <param name="response">要设置的HTTP响应对象</param>
            <returns>设置后的HTTP响应对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromFileAsync(TouchSocket.Http.HttpResponse,System.IO.FileInfo,TouchSocket.Http.HttpRequest,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            从文件响应。
            <para>当response支持持续写入时，会直接回复响应。并阻塞执行，直到完成。所以在执行该方法之前，请确保已设置完成所有状态字</para>
            <para>当response不支持持续写入时，会填充Content，且不会响应，需要自己执行Build，并发送。</para>
            </summary>
            <param name="response">响应</param>
            <param name="request">请求头，用于尝试续传，为null时则不续传。</param>
            <param name="fileInfo">文件信息</param>
            <param name="fileName">文件名，不设置时会获取路径文件名</param>
            <param name="maxSpeed">最大速度。</param>
            <param name="bufferLen">读取长度。</param>
            <param name="autoGzip">是否自动<see cref="T:TouchSocket.Http.HttpRequest"/>请求，自动启用gzip</param>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:System.Exception"></exception>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromFileAsync(TouchSocket.Http.HttpContext,System.IO.FileInfo,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            从文件响应。
            <para>当response支持持续写入时，会直接回复响应。并阻塞执行，直到完成。所以在执行该方法之前，请确保已设置完成所有状态字</para>
            <para>当response不支持持续写入时，会填充Content，且不会响应，需要自己执行Build，并发送。</para>
            </summary>
            <param name="context">上下文</param>
            <param name="fileInfo">文件信息</param>
            <param name="fileName">文件名，不设置时会获取路径文件名</param>
            <param name="maxSpeed">最大速度。</param>
            <param name="bufferLen">读取长度。</param>
            <param name="autoGzip">是否自动<see cref="T:TouchSocket.Http.HttpRequest"/>请求，自动启用gzip</param>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:System.Exception"></exception>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.CreateWriteStream``1(``0)">
            <summary>
            为指定的 HTTP 响应创建一个写入流。
            </summary>
            <param name="response">要关联写入流的 HTTP 响应对象。</param>
            <returns>一个 <see cref="T:System.IO.Stream"/> 对象，用于向 HTTP 响应写入数据。</returns>
            <remarks>
            此方法提供了一种方便的方式来获取一个写入流，该流可以直接与指定的 HTTP 响应对象关联，
            从而简化了向 HTTP 响应写入数据的过程。
            </remarks>
            <typeparam name="TResponse">HTTP 响应的类型，必须是 <see cref="T:TouchSocket.Http.HttpResponse"/> 的一个子类。</typeparam>
        </member>
        <member name="T:TouchSocket.Http.IContentTypeProvider">
            <summary>
            IContentTypeProvider
            </summary>
        </member>
        <member name="M:TouchSocket.Http.IContentTypeProvider.TryGetContentType(System.String,System.String@)">
            <summary>
            给定文件路径，确定MIME类型
            </summary>
            <param name="subpath"></param>
            <param name="contentType"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.IFormFile">
            <summary>
            表单文件
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.ContentDisposition">
            <summary>
            获取Content-Disposition
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.ContentType">
            <summary>
            获取Content-Type
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.Data">
            <summary>
            实际的数据
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.DataPair">
            <summary>
            数据对
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.FileName">
            <summary>
            获取file name
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.Length">
            <summary>
            文件长度。在数据接收完成之前，该值为-1;
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.Name">
            <summary>
             获取name字段
            </summary>
        </member>
        <member name="T:TouchSocket.Http.IHttpHeader">
            <summary>
            表示http的headers
            </summary>
        </member>
        <member name="M:TouchSocket.Http.IHttpHeader.Get(System.String)">
            <summary>
            获取Header
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.IHttpHeader.Get(TouchSocket.Http.HttpHeaders)">
            <summary>
            获取Header
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.IHttpHeader.Add(TouchSocket.Http.HttpHeaders,System.String)">
            <summary>
            添加Header
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="P:TouchSocket.Http.IHttpHeader.Item(TouchSocket.Http.HttpHeaders)">
            <summary>
            获取、添加Header
            </summary>
            <param name="headers"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.IHttpParams">
            <summary>
            Http参数
            </summary>
        </member>
        <member name="M:TouchSocket.Http.IHttpParams.Get(System.String)">
            <summary>
            获取参数
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.IHttpSocketClient">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.IHttpClientBase">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.DefaultHttpServicePlugin">
            <summary>
            默认的Http服务。为Http做兜底拦截。该插件应该最后添加。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.DefaultHttpServicePlugin.Loaded(TouchSocket.Core.IPluginManager)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.DefaultHttpServicePlugin.OnHttpRequest(TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContextEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.IHttpPlugin">
            <summary>
            IHttpPlugin
            </summary>
        </member>
        <member name="M:TouchSocket.Http.IHttpPlugin.OnHttpRequest(TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到Http请求。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.FileExtensionContentTypeProvider">
            <summary>
            FileExtensionContentTypeProvider
            </summary>
        </member>
        <member name="M:TouchSocket.Http.FileExtensionContentTypeProvider.#ctor">
            <summary>
            FileExtensionContentTypeProvider
            </summary>
        </member>
        <member name="M:TouchSocket.Http.FileExtensionContentTypeProvider.#ctor(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            FileExtensionContentTypeProvider
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="P:TouchSocket.Http.FileExtensionContentTypeProvider.Mappings">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.FileExtensionContentTypeProvider.TryGetContentType(System.String,System.String@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.HttpStaticPagePlugin">
            <summary>
            Http静态内容插件
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.#ctor(TouchSocket.Http.StaticPageOptions)">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpStaticPagePlugin.ContentTypeProvider">
            <summary>
            提供文件扩展名和MIME类型之间的映射。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpStaticPagePlugin.StaticFilesPool">
            <summary>
            静态文件池
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpStaticPagePlugin.NavigateAction">
            <summary>
            重新导航
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpStaticPagePlugin.ResponseAction">
            <summary>
            在响应之前调用。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.ConfigureStaticFilesPool(System.Action{TouchSocket.Http.StaticFilesPool})">
            <summary>
            配置静态文件池
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.AddFolder(System.String,System.String,System.String,System.Nullable{System.TimeSpan})">
            <summary>
            添加静态文件目录
            </summary>
            <param name="path">Static content path</param>
            <param name="prefix">Cache prefix (default is "/")</param>
            <param name="filter">Cache filter (default is "*.*")</param>
            <param name="timeout">Refresh cache millisecondsTimeout (default is 1 hour)</param>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.SetContentTypeProvider(TouchSocket.Http.IContentTypeProvider)">
            <summary>
            设置提供文件扩展名和MIME类型之间的映射。
            </summary>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.SetNavigateAction(System.Func{TouchSocket.Http.HttpRequest,System.Threading.Tasks.Task{System.String}})">
            <summary>
            设定重新导航
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.SetNavigateAction(System.Func{TouchSocket.Http.HttpRequest,System.String})">
            <summary>
            设定重新导航
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.SetResponseAction(System.Func{TouchSocket.Http.HttpContext,System.Threading.Tasks.Task})">
            <summary>
            在响应之前调用。
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.SetResponseAction(System.Action{TouchSocket.Http.HttpContext})">
            <summary>
            在响应之前调用。
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.Loaded(TouchSocket.Core.IPluginManager)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.ClearFolder">
            <summary>
            移除所有静态页面
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.RemoveFolder(System.String)">
            <summary>
            移除指定路径的静态文件
            </summary>
            <param name="path">Static content path</param>
        </member>
        <member name="T:TouchSocket.Http.StaticEntry">
            <summary>
            表示一个静态条目，可以是字节缓存或文件信息。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.StaticEntry.#ctor(System.Byte[],System.TimeSpan)">
            <summary>
            使用字节数组和超时时间初始化静态条目。
            </summary>
            <param name="value">条目的值，如果条目代表的是字节缓存。</param>
            <param name="timeout">条目的超时时间。</param>
        </member>
        <member name="M:TouchSocket.Http.StaticEntry.#ctor(System.IO.FileInfo,System.TimeSpan)">
            <summary>
            使用FileInfo和超时时间初始化静态条目。
            </summary>
            <param name="fileInfo">条目代表的文件信息。</param>
            <param name="timespan">条目的超时时间。</param>
        </member>
        <member name="P:TouchSocket.Http.StaticEntry.IsCacheBytes">
            <summary>
            获取一个值，指示当前条目是否为字节缓存。
            </summary>
            <value>如果条目的值非空，则为true；否则为false。</value>
        </member>
        <member name="P:TouchSocket.Http.StaticEntry.FileInfo">
            <summary>
            获取或设置与条目关联的文件信息。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticEntry.Value">
            <summary>
            获取与条目关联的字节数组。该值在初始化后不可更改。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticEntry.Timespan">
            <summary>
            获取或设置条目的超时时间。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.StaticFilesPool">
            <summary>
            静态文件缓存池
            </summary>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.#ctor">
            <summary>
            静态文件池的构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticFilesPool.Empty">
            <summary>
            判断文件缓存是否为空
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticFilesPool.Count">
            <summary>
            获取文件缓存的数量
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticFilesPool.MaxCacheSize">
            <summary>
            对于静态资源缓存的最大尺寸。默认1024*1024。
            </summary>
            <remarks>
            大于设定值的资源只会存储<see cref="T:System.IO.FileInfo"/>，每次访问资源时都会从磁盘加载。
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.Clear">
            <summary>
            清除缓存。
            该方法通过停止文件监视器并清除缓存项，来释放资源。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.AddEntry(System.String,System.Byte[],System.TimeSpan)">
            <summary>
            添加一个新的缓存值
            </summary>
            <param name="key">缓存键</param>
            <param name="value">缓存值，以字节数组形式存储</param>
            <param name="millisecondsTimeout">缓存条目的超时时间，以毫秒为单位</param>
            <returns>始终返回true，表示添加操作已完成</returns>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.AddEntry(System.String,System.IO.FileInfo,System.TimeSpan)">
            <summary>
            向缓存中添加一个条目。
            </summary>
            <param name="key">要添加的条目的键。</param>
            <param name="value">要添加的条目的值，包含文件信息。</param>
            <param name="millisecondsTimeout">条目过期的时间段，以毫秒为单位。</param>
            <returns>总是返回true，表示条目已成功添加。</returns>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.ContainsEntry(System.String)">
            <summary>
            检查给定键是否存在于条目中。
            </summary>
            <param name="key">要检查的键。</param>
            <returns>如果键存在于条目中，则返回 true；否则返回 false。</returns>
            <remarks>
            此方法用于确定是否已经存在具有给定键的条目。
            它首先对键应用路径格式化，然后检查是否存在与格式化后的键相对应的条目。
            使用 ReadLock 确保在读取操作期间数据的一致性。
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.RemoveEntry(System.String)">
            <summary>
            移除指定键的条目。
            </summary>
            <param name="key">要移除的条目的键。</param>
            <returns>如果成功移除，则返回 true；否则返回 false。</returns>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.TryFindEntry(System.String,TouchSocket.Http.StaticEntry@)">
            <summary>
            尝试查找缓存项。
            </summary>
            <param name="key">要查找的键。</param>
            <param name="cacheEntry">找到的缓存项，通过引用返回。</param>
            <returns>如果找到缓存项则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.AddFolder(System.String,System.String,System.String,System.Nullable{System.TimeSpan})">
            <summary>
            添加一个文件夹到监控列表。
            </summary>
            <param name="path">要添加的文件夹路径。</param>
            <param name="prefix">文件夹的前缀，默认为"/"。</param>
            <param name="filter">文件过滤器，默认为"*.*"，表示不过滤。</param>
            <param name="timeout">操作超时时间，默认为1小时。</param>
            <returns>添加的文件数量。</returns>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.ContainsFolder(System.String)">
            <summary>
            检查指定路径的文件夹是否存在于集合中。
            </summary>
            <param name="path">要检查的文件夹路径。</param>
            <returns>如果文件夹存在于集合中，则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.RemoveFolder(System.String)">
            <summary>
            移除指定路径的文件夹。
            </summary>
            <param name="path">要移除的文件夹路径。</param>
            <returns>如果成功移除文件夹，则返回 true；如果指定路径不存在于文件夹集合中，则返回 false。</returns>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.StaticPageOptions">
            <summary>
            静态页面配置
            </summary>
        </member>
        <member name="M:TouchSocket.Http.StaticPageOptions.#ctor">
            <summary>
            构造函数：初始化StaticPageOptions实例
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticPageOptions.ContentTypeProvider">
            <summary>
            提供文件扩展名和MIME类型之间的映射。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticPageOptions.FilesPool">
            <summary>
            获取静态文件池对象
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticPageOptions.NavigateAction">
            <summary>
            重新导航
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticPageOptions.ResponseAction">
            <summary>
            在响应之前调用。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.StaticPageOptions.AddFolder(System.String,System.String,System.String,System.Nullable{System.TimeSpan})">
            <summary>
            添加静态文件目录
            </summary>
            <param name="path">静态内容路径</param>
            <param name="prefix">缓存前缀（默认为"/"）</param>
            <param name="filter">缓存过滤器（默认为"*.*"，表示所有文件）</param>
            <param name="timeout">刷新缓存的时间间隔（以毫秒为单位，默认为1小时）</param>
        </member>
        <member name="M:TouchSocket.Http.StaticPageOptions.SetContentTypeProvider(TouchSocket.Http.IContentTypeProvider)">
            <summary>
            设置提供文件扩展名和MIME类型之间的映射。
            </summary>
            <param name="provider">一个实现了IContentTypeProvider接口的对象，用于提供文件扩展名与MIME类型的映射。</param>
        </member>
        <member name="M:TouchSocket.Http.StaticPageOptions.SetNavigateAction(System.Func{TouchSocket.Http.HttpRequest,System.Threading.Tasks.Task{System.String}})">
            <summary>
            设定重新导航
            </summary>
            <param name="func">一个函数，接受HttpRequest作为参数，并返回一个异步Task，该Task结果为字符串类型的导航目标</param>
        </member>
        <member name="M:TouchSocket.Http.StaticPageOptions.SetNavigateAction(System.Func{TouchSocket.Http.HttpRequest,System.String})">
            <summary>
            设定重新导航
            </summary>
            <param name="func">一个函数，接受一个HttpRequest参数，并返回一个字符串类型的URL</param>
        </member>
        <member name="M:TouchSocket.Http.StaticPageOptions.SetResponseAction(System.Func{TouchSocket.Http.HttpContext,System.Threading.Tasks.Task})">
            <summary>
            在响应之前调用。
            </summary>
            <param name="func">一个委托，包含在响应之前需要执行的操作。该委托接受一个HttpContext参数，返回一个Task对象。</param>
        </member>
        <member name="M:TouchSocket.Http.StaticPageOptions.SetResponseAction(System.Action{TouchSocket.Http.HttpContext})">
            <summary>
            设置一个操作，该操作将在生成响应之前被调用。
            </summary>
            <param name="action">一个接受HttpContext作为参数的Action委托，表示要设置的操作。</param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketMessage">
            <summary>
            WebSocket消息结构体，实现了IDisposable接口，用于处理WebSocket消息的生命周期。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketMessage.#ctor(TouchSocket.Http.WebSockets.WSDataType,TouchSocket.Core.ByteBlock,System.Action)">
            <summary>
            初始化WebSocketMessage结构体的新实例。
            </summary>
            <param name="opcode">消息的数据类型，使用WSDataType枚举表示。</param>
            <param name="payloadData">消息的负载数据，使用ByteBlock结构表示。</param>
            <param name="disposeAction">在消息释放时需要调用的动作。</param>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketMessage.Opcode">
            <summary>
            获取消息的数据类型。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketMessage.PayloadData">
            <summary>
            获取消息的负载数据。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketMessage.Dispose">
            <summary>
            释放消息资源。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketMessageCombinator">
            <summary>
            WebSocket消息合并器。其作用是合并具有中继数据的消息
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketMessageCombinator.TryCombine(TouchSocket.Http.WebSockets.WSDataFrame,TouchSocket.Http.WebSockets.WebSocketMessage@)">
            <summary>
            尝试将数据帧组合成WebSocket消息。
            </summary>
            <param name="dataFrame">待组合的数据帧。</param>
            <param name="webSocketMessage">组合成功的WebSocket消息。</param>
            <returns>如果成功组合则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketMessageCombinator.Clear">
            <summary>
            清空所有缓存状态及数据。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketOption">
            <summary>
            WebSocket配置
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketOption.Version">
            <summary>
            版本
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSDataFrame">
            <summary>
            WebSocket数据帧
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.FIN">
            <summary>
            是否为最后数据帧。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.IsBinary">
            <summary>
            是否是二进制数据类型
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.IsClose">
            <summary>
            是否是关闭请求
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.IsPing">
            <summary>
            是否是Ping
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.IsPong">
            <summary>
            是否是Pong
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.IsText">
            <summary>
            是否是文本类型
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.Mask">
            <summary>
            计算掩码
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.MaskingKey">
            <summary>
            掩码值
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.MaxLength">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.Opcode">
            <summary>
            数据类型
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.PayloadData">
            <summary>
            有效数据
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.PayloadLength">
            <summary>
            有效载荷数据长度
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.RSV1">
            <summary>
            标识RSV-1。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.RSV2">
            <summary>
            标识RSV-2。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.RSV3">
            <summary>
            标识RSV-3。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrame.Build``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrame.SetMaskString(System.String)">
            <summary>
            设置Mask。
            </summary>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrame.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSTools">
            <summary>
            WSTools
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSTools.acceptMask">
            <summary>
            应答。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSTools.CalculateBase64Key(System.String)">
            <summary>
            计算Base64值
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSTools.CreateBase64Key">
            <summary>
            获取Base64随即字符串。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSTools.GetWSRequest(TouchSocket.Http.HttpClientBase,System.String,System.String@)">
            <summary>
            获取WS的请求头
            </summary>
            <param name="httpClientBase"></param>
            <param name="version"></param>
            <param name="base64Key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSTools.TryGetResponse(TouchSocket.Http.HttpRequest,TouchSocket.Http.HttpResponse)">
            <summary>
            获取响应
            </summary>
            <param name="request"></param>
            <param name="response"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.SetupClientWebSocket">
            <summary>
            SetupClientWebSocket
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.#ctor">
            <summary>
            SetupClientWebSocket
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.ConnectAsync(System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.SetupClientWebSocket.LastReceivedTime">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.SetupClientWebSocket.LastSendTime">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.SetupClientWebSocket.Protocol">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.SetupClientWebSocket.RemoteIPHost">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.SetupClientWebSocket.ProtectedIsHandshaked">
            <summary>
            是否已完成连接
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.SetupClientWebSocket.Client">
            <summary>
            通讯实际客户端
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.CloseAsync(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.Abort(System.Boolean,System.String)">
            <summary>
            中断连接
            </summary>
            <param name="msg"></param>
            <param name="manual"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.LoadConfig(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            加载配置
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.OnDisconnected(TouchSocket.Sockets.ClosedEventArgs)">
            <summary>
            已断开连接。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.OnReceived(System.Net.WebSockets.WebSocketReceiveResult,TouchSocket.Core.ByteBlock)">
            <summary>
            收到数据
            </summary>
            <param name="result"></param>
            <param name="byteBlock"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketClient">
            <summary>
            WebSocketClient用户终端简单实现。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.AllowAsyncRead">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Client">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Closed">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Closing">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Handshaked">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Handshaking">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Received">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.OnWebSocketClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <summary>
            当WebSocket连接关闭时执行的任务。
            </summary>
            <param name="e">包含关闭事件相关信息的参数。</param>
            <returns>一个等待完成的任务。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.OnWebSocketClosing(TouchSocket.Sockets.ClosedEventArgs)">
            <summary>
            当WebSocket即将关闭时，执行异步任务。
            </summary>
            <param name="e">提供了关闭事件的相关信息。</param>
            <returns>返回一个异步任务。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.OnWebSocketHandshaked(TouchSocket.Http.HttpContextEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.OnWebSocketHandshaking(TouchSocket.Http.HttpContextEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.OnWebSocketReceived(TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Version">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.PingAsync">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.PongAsync">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.ReadAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.SendAsync(TouchSocket.Http.WebSockets.WSDataFrame,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.SendAsync(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.SendAsync(System.ReadOnlyMemory{System.Byte},System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketClientBase">
            <summary>
            WebSocket用户终端。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.#ctor">
            <summary>
            WebSocket用户终端
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClientBase.Online">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.ConnectAsync(System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnWebSocketClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <summary>
            当 WebSocket 连接关闭时触发的事件处理程序。
            </summary>
            <param name="e">包含关闭原因和状态代码的事件参数。</param>
            <returns>一个 <see cref="T:System.Threading.Tasks.Task"/> 对象，表示异步操作的完成。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnWebSocketClosing(TouchSocket.Sockets.ClosedEventArgs)">
            <summary>
            在WebSocket关闭时触发的事件处理程序。
            </summary>
            <param name="e">包含关闭原因和状态码的事件参数。</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> 表示事件处理的异步操作。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnWebSocketHandshaked(TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示完成握手后。
            </summary>
            <param name="e">包含HTTP上下文信息的参数对象。</param>
            <returns>一个表示任务已完成的Task对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnWebSocketHandshaking(TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示在即将握手连接时。
            </summary>
            <param name="e">包含HTTP上下文信息的参数对象</param>
            <returns>一个表示异步操作完成的任务</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnWebSocketReceived(TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <summary>
            当收到WS数据时。
            </summary>
            <param name="e">包含接收数据的事件参数</param>
            <returns>一个Task对象，表示异步操作</returns>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClientBase.WebSocket">
            <summary>
            实际通讯的WebSocket。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnTcpClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnTcpReceived(TouchSocket.Sockets.ReceivedDataEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter">
            <summary>
            WebSocket适配器
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.m_surPlusLength">
            <summary>
            数据包剩余长度
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.m_tempByteBlock">
            <summary>
            临时包
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.DecodingFromBytes(System.Byte[],System.Int32@,System.Int32,TouchSocket.Http.WebSockets.WSDataFrame@)">
            <summary>
            解码
            </summary>
            <param name="dataBuffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="dataFrame"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.PreviewReceivedAsync(TouchSocket.Core.ByteBlock)">
            <summary>
            当接收到数据时处理数据
            </summary>
            <param name="byteBlock">数据流</param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.Reset">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.SplitPackageAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            分解包
            </summary>
            <param name="dataBuffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter2">
            <summary>
            WebSocket适配器
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter2.GetInstance">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSDataFrameEventHandler`1">
            <summary>
            收到WebSocket数据
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSDataType">
            <summary>
            WebSocket数据类型
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Cont">
            <summary>
            表示一个中间数据包
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Text">
            <summary>
            表示一个text类型数据包
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Binary">
            <summary>
            表示一个binary类型数据包
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Close">
            <summary>
            表示一个断开连接类型数据包
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Ping">
            <summary>
            表示一个ping类型数据包
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Pong">
            <summary>
            表示一个pong类型数据包
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSDataFrameEventArgs">
            <summary>
            WS数据事件类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrameEventArgs.#ctor(TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            构造函数
            </summary>
            <param name="dataFrame"></param>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrameEventArgs.DataFrame">
            <summary>
            WS数据帧。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketConnectException">
            <summary>
            WebSocket连接异常。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketConnectException.#ctor(System.String,TouchSocket.Http.HttpContext)">
            <summary>
            WebSocket连接异常
            </summary>
            <param name="mes"></param>
            <param name="context"></param>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketConnectException.Context">
            <summary>
            HttpContext
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketClientExtension">
            <summary>
            WebSocketClientExtension
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension">
            <summary>
            WebSocket数据帧扩展类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension.AppendBinary(TouchSocket.Http.WebSockets.WSDataFrame,System.ReadOnlySpan{System.Byte})">
            <summary>
            将二进制数据追加到WSDataFrame对象的PayloadData属性中。
            </summary>
            <param name="dataFrame">要追加数据的WSDataFrame对象。</param>
            <param name="span">要追加的二进制数据，使用<see cref="T:System.ReadOnlySpan`1"/>类型以提高性能。</param>
            <returns>返回修改后的WSDataFrame对象，以便支持链式调用。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension.AppendText(TouchSocket.Http.WebSockets.WSDataFrame,System.String,System.Text.Encoding)">
            <summary>
            将文本数据追加到WSDataFrame对象的PayloadData中。
            </summary>
            <param name="dataFrame">要追加文本数据的WSDataFrame对象。</param>
            <param name="text">要追加的文本数据。</param>
            <param name="encoding">文本数据的编码方式。默认为UTF8。</param>
            <returns>追加文本数据后的WSDataFrame对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension.BuildRequest``1(TouchSocket.Http.WebSockets.WSDataFrame,``0@)">
            <summary>
            构建请求数据（含Make）
            </summary>
            <param name="dataFrame">数据帧对象，用于封装请求数据</param>
            <param name="byteBlock">字节块对象，用于存储构建的请求数据</param>
            <typeparam name="TByteBlock">泛型参数，指定字节块的类型，必须实现IByteBlock接口</typeparam>
            <remarks>
            此方法通过设置数据帧的Mask属性为true，并确保数据帧具有MaskingKey，
            然后调用dataFrame的Build方法来构建请求数据，并将结果存储在byteBlock中。
            如果MaskingKey未设置，则使用"RRQM"作为默认值。
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension.BuildRequestToBytes(TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            构建请求数据（含Make）
            </summary>
            <param name="dataFrame">要构建的数据帧</param>
            <returns>构建完成的字节数组</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension.BuildResponse``1(TouchSocket.Http.WebSockets.WSDataFrame,``0@)">
            <summary>
            构建响应数据（无Make）
            </summary>
            <param name="dataFrame">待构建的WS数据帧</param>
            <param name="byteBlock">字节块，用于存储构建后的数据</param>
            <remarks>
            该方法直接调用WS数据帧的Build方法来构建数据，
            并将构建结果存储在字节块中，而不是创建一个新的对象。
            这样可以提高性能，减少内存分配。
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension.BuildResponseToBytes(TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            构建响应数据（无Make）
            </summary>
            <param name="dataFrame">要转换为字节数组的数据帧</param>
            <returns>转换后的字节数组</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension.ToText(TouchSocket.Http.WebSockets.WSDataFrame,System.Text.Encoding)">
            <summary>
            当数据类型为<see cref="F:TouchSocket.Http.WebSockets.WSDataType.Text"/>时，将数据帧转换为文本消息。
            </summary>
            <param name="dataFrame">要转换的数据帧。</param>
            <param name="encoding">使用的编码方式。如果未指定（默认值），将使用UTF8编码。</param>
            <returns>转换后的文本消息。</returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketExtension">
            <summary>
            WebSocket扩展类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketExtension.ReadStringAsync(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Core.ByteBlock,System.Threading.CancellationToken)">
            <summary>
            异步读取完整字符串。
            <para>
            注意：该访问调用时如果收到非字符串数据则会抛出异常。同时，该方法不可在<see cref="T:TouchSocket.Http.WebSockets.IWebSocket"/>的接收数据事件（插件）中使用。
            相关用法请按照<see cref="M:TouchSocket.Http.WebSockets.IWebSocket.ReadAsync(System.Threading.CancellationToken)"/>进行。
            </para>
            </summary>
            <param name="webSocket">要读取数据的WebSocket实例</param>
            <param name="byteBlock">用于存储接收到的数据的字节块</param>
            <param name="token">用于取消操作的取消令牌</param>
            <returns>返回一个任务，该任务在完成后将包含读取到的字符串</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketExtension.ReadStringAsync(TouchSocket.Http.WebSockets.IWebSocket,System.Threading.CancellationToken)">
            <summary>
            异步读取完整字符串。
            <para>
            注意：该访问调用时如果收到非字符串数据则会抛出异常。同时，该方法不可在<see cref="T:TouchSocket.Http.WebSockets.IWebSocket"/>的接收数据事件（插件）中使用。
            相关用法请按照<see cref="M:TouchSocket.Http.WebSockets.IWebSocket.ReadAsync(System.Threading.CancellationToken)"/>进行。
            </para>
            </summary>
            <param name="webSocket">要读取数据的WebSocket实例</param>
            <param name="token">用于取消异步读取操作的取消令牌</param>
            <returns>返回异步读取到的字符串</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketExtension.ReadBinaryAsync(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Core.ByteBlock,System.Threading.CancellationToken)">
            <summary>
            异步读取完整二进制数据。
            <para>
            注意：该访问调用时如果收到非二进制数据则会抛出异常。同时，该方法不可在<see cref="T:TouchSocket.Http.WebSockets.IWebSocket"/>的接收数据事件（插件）中使用。
            相关用法请按照<see cref="M:TouchSocket.Http.WebSockets.IWebSocket.ReadAsync(System.Threading.CancellationToken)"/>进行。
            </para>
            </summary>
            <param name="webSocket">要读取数据的WebSocket实例。</param>
            <param name="byteBlock">用于存储读取的二进制数据的容器。</param>
            <param name="token">用于取消异步读取操作的取消令牌。</param>
            <returns>返回一个Task对象，表示异步读取操作。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketExtension.ReadBinaryAsync(TouchSocket.Http.WebSockets.IWebSocket,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            异步读取完整二进制数据。
            <para>
            注意：该访问调用时如果收到非二进制数据则会抛出异常。同时，该方法不可在<see cref="T:TouchSocket.Http.WebSockets.IWebSocket"/>的接收数据事件（插件）中使用。
            相关用法请按照<see cref="M:TouchSocket.Http.WebSockets.IWebSocket.ReadAsync(System.Threading.CancellationToken)"/>进行。
            </para>
            </summary>
            <param name="webSocket">要读取数据的WebSocket实例。</param>
            <param name="stream">用于存储读取的二进制数据的流。</param>
            <param name="token">用于取消异步读取操作的取消令牌。默认值为<see cref="P:System.Threading.CancellationToken.None"/>。</param>
            <returns>返回一个<see cref="T:System.Threading.Tasks.Task"/>对象，表示异步读取操作。</returns>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketExtension.WebSocketMessageCombinatorProperty">
            <summary>
            WebSocketMessageCombinatorProperty
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketExtension.GetMessageCombinator(TouchSocket.Http.WebSockets.IWebSocket)">
            <summary>
            获取消息合并器。
            </summary>
            <param name="webSocket">WebSocket实例</param>
            <returns>消息合并器实例</returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocket">
            <summary>
            定义WebSocket服务的接口，继承自IDisposable, IOnlineClient, IClosableClient接口。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocket.Version">
            <summary>
            WebSocket版本
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocket.AllowAsyncRead">
            <summary>
            允许异步Read读取
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocket.Client">
            <summary>
            使用的Http客户端
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocket.PingAsync">
            <summary>
            异步发送Ping请求。
            </summary>
            <returns>任务完成时返回。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocket.PongAsync">
            <summary>
            异步执行Pong操作。
            </summary>
            <returns>一个任务对象，表示异步操作的完成。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocket.ReadAsync(System.Threading.CancellationToken)">
            <summary>
            异步等待读取数据
            </summary>
            <param name="token">用于取消异步读取操作的取消令牌</param>
            <returns>返回一个值任务，该任务完成后将包含WebSocket接收的结果</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocket.SendAsync(TouchSocket.Http.WebSockets.WSDataFrame,System.Boolean)">
            <summary>
            采用WebSocket协议，发送WS数据。发送结束后，请及时释放<see cref="T:TouchSocket.Http.WebSockets.WSDataFrame"/>
            </summary>
            <param name="dataFrame">要发送的数据帧</param>
            <param name="endOfMessage">是否是消息的结束标志，默认为true</param>
            <returns>返回一个异步任务，用于指示发送操作的完成状态</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocket.SendAsync(System.String,System.Boolean)">
            <summary>
            异步发送文本消息。
            </summary>
            <param name="text">要发送的文本内容。</param>
            <param name="endOfMessage">指示是否是消息的结束。默认为true。</param>
            <returns>返回一个任务对象，表示异步操作的结果。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocket.SendAsync(System.ReadOnlyMemory{System.Byte},System.Boolean)">
            <summary>
            异步发送指定的字节内存数据。
            </summary>
            <param name="memory">要发送的字节数据，作为只读内存块。</param>
            <param name="endOfMessage">指示当前数据是否为消息的结束。默认为true。</param>
            <remarks>
            此方法允许异步发送数据，通过指定是否为消息的结束来控制数据流。
            </remarks>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketClient">
            <summary>
            用户终端接口
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocketClient.Closed">
            <summary>
            当WebSocket断开时触发。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocketClient.Closing">
            <summary>
            当WebSocket收到Close报文时触发。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocketClient.Handshaked">
            <summary>
            表示完成握手后。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocketClient.Handshaking">
            <summary>
            表示在即将握手连接时。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocketClient.Received">
            <summary>
            收到WebSocket数据
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketReceiveResult">
            <summary>
            定义WebSocket接收结果的接口，继承自IDisposable接口
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocketReceiveResult.IsCompleted">
            <summary>
            获取接收操作是否已完成的标志
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocketReceiveResult.Message">
            <summary>
            获取接收到的消息内容
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocketReceiveResult.DataFrame">
            <summary>
            WebSocket数据帧
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketClosedPlugin">
            <summary>
            IWebSocketClosedPlugin
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketClosedPlugin.OnWebSocketClosed(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosedEventArgs)">
            <summary>
            表示WebSocket已经断开连接。
            </summary>
            <param name="webSocket"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketClosingPlugin">
            <summary>
            IWebSocketClosingPlugin
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketClosingPlugin.OnWebSocketClosing(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosedEventArgs)">
            <summary>
            表示收到断开连接报文。如果对方直接断开连接，此方法则不会触发。
            </summary>
            <param name="webSocket"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketHandshakedPlugin">
            <summary>
            IWebSocketHandshakedPlugin
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketHandshakedPlugin.OnWebSocketHandshaked(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示完成握手后。
            </summary>
            <param name="webSocket"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketHandshakingPlugin">
            <summary>
            IWebSocketHandshakingPlugin
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketHandshakingPlugin.OnWebSocketHandshaking(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示在即将握手连接时。
            </summary>
            <param name="webSocket"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketReceivedPlugin">
            <summary>
            IWebSocketReceivedPlugin
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketReceivedPlugin.OnWebSocketReceived(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <summary>
            当收到WS数据时。
            </summary>
            <param name="webSocket"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketCommandLinePlugin">
            <summary>
            WS命令行插件。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketCommandLinePlugin.#ctor(TouchSocket.Core.ILog)">
            <summary>
            WSCommandLinePlugin
            </summary>
            <param name="logger"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketCommandLinePlugin.Loaded(TouchSocket.Core.IPluginManager)">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketCommandLinePlugin.Converter">
            <summary>
            字符串转换器，默认支持基础类型和Json。可以自定义。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketCommandLinePlugin.ReturnException">
            <summary>
            是否返回执行异常。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketCommandLinePlugin.NoReturnException">
            <summary>
            当有执行异常时，不返回异常。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketCommandLinePlugin.OnWebSocketReceived(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketFeature">
            <summary>
            基于Http的WebSocket的扩展。
            <para>此组件只能挂载在<see cref="T:TouchSocket.Http.HttpService"/>中</para>
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketFeature.AutoCloseProperty">
            <summary>
            自动响应Close报文
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketFeature.AutoPongProperty">
            <summary>
            自动响应Ping报文
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketFeature.#ctor">
            <summary>
            WebSocketFeature
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketFeature.AutoClose">
            <summary>
            是否默认处理Close报文。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketFeature.AutoPong">
            <summary>
            当收到ping报文时，是否自动回应pong。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketFeature.VerifyConnection">
            <summary>
            验证连接
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketFeature.WSUrl">
            <summary>
            用于WebSocket连接的路径，默认为“/ws”
            <para>如果设置为null或空，则意味着所有的连接都将解释为WS</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketFeature.NoAutoClose">
            <summary>
            不处理Close报文。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketFeature.SetVerifyConnection(System.Func{TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContext,System.Boolean})">
            <summary>
            验证连接
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketFeature.SetVerifyConnection(System.Func{TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContext,System.Threading.Tasks.Task{System.Boolean}})">
            <summary>
            验证连接
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketFeature.SetWSUrl(System.String)">
            <summary>
            用于WebSocket连接的路径，默认为“/ws”
            <para>如果设置为null或空，则意味着所有的连接都将解释为WS</para>
            </summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketFeature.UseAutoPong">
            <summary>
            当收到ping报文时，自动回应pong。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketFeature.Loaded(TouchSocket.Core.IPluginManager)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketHeartbeatPlugin">
            <summary>
            初始化一个适用于WebSocket的心跳插件
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketHeartbeatPlugin.Loaded(TouchSocket.Core.IPluginManager)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Sockets.HttpConfigExtensions">
            <summary>
            HttpConfigExtensions
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.HttpConfigExtensions.HttpProxyProperty">
            <summary>
            Http代理
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.HttpConfigExtensions.SetHttpProxy(TouchSocket.Core.TouchSocketConfig,TouchSocket.Http.HttpProxy)">
             <summary>
            设置Http代理
             </summary>
             <param name="config"></param>
             <param name="value"></param>
             <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.WebSocketConfigExtension">
            <summary>
            WebSocketConfigExtensions
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.WebSocketConfigExtension.WebSocketOptionProperty">
            <summary>
            WebSocket配置属性
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.WebSocketConfigExtension.SetWebSocketOption(TouchSocket.Core.TouchSocketConfig,TouchSocket.Http.WebSockets.WebSocketOption)">
            <summary>
            设置WebSocket的相关配置
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.HttpPluginManagerExtension">
            <summary>
            HttpPluginManagerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.HttpPluginManagerExtension.UseDefaultHttpServicePlugin(TouchSocket.Core.IPluginManager)">
            <summary>
            使用默认的Http服务插件。该插件作为Http请求的默认处理者，用于拦截未被其他插件处理的Http请求。
            该方法通过扩展方法的方式，允许插件管理器动态添加此默认Http服务插件。
            </summary>
            <param name="pluginManager">插件管理器，负责管理和添加插件。</param>
            <returns>返回创建并添加到插件管理器的默认Http服务插件实例。</returns>
        </member>
        <member name="M:TouchSocket.Core.HttpPluginManagerExtension.UseHttpStaticPage(TouchSocket.Core.IPluginManager,System.Action{TouchSocket.Http.StaticPageOptions})">
            <summary>
            静态页面插件扩展方法
            </summary>
            <param name="pluginManager">插件管理器实例</param>
            <param name="optionsAction">配置操作委托，用于配置静态页面选项</param>
            <returns>配置后的静态页面插件实例</returns>
        </member>
        <member name="M:TouchSocket.Core.HttpPluginManagerExtension.UseHttpStaticPage(TouchSocket.Core.IPluginManager)">
            <summary>
            静态方法，用于通过插件管理器启用HTTP静态页面服务插件
            </summary>
            <param name="pluginManager">插件管理器对象，用于添加和管理插件</param>
            <returns>返回创建的HTTP静态页面服务插件实例</returns>
        </member>
        <member name="M:TouchSocket.Core.HttpPluginManagerExtension.UseCors(TouchSocket.Core.IPluginManager,System.String)">
            <summary>
            启用跨域功能
            </summary>
            <param name="pluginManager">插件管理器</param>
            <param name="policyName">跨域策略名称</param>
            <returns>返回一个新的CorsPlugin实例</returns>
        </member>
        <member name="T:TouchSocket.Core.WebSocketPluginManagerExtension">
            <summary>
            WebSocketPluginManagerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WebSocketPluginManagerExtension.UseWebSocket(TouchSocket.Core.IPluginManager)">
            <summary>
            使用WebSocket插件。
            </summary>
            <returns>插件类型实例</returns>
        </member>
        <member name="M:TouchSocket.Core.WebSocketPluginManagerExtension.UseWebSocketHeartbeat(TouchSocket.Core.IPluginManager)">
            <summary>
            使用WebSocket心跳插件，客户端、服务器均有效。但是一般建议客户端使用即可。
            </summary>
            <returns>插件类型实例</returns>
        </member>
        <member name="M:TouchSocket.Core.WebSocketPluginManagerExtension.UseWebSocketReconnection``1(TouchSocket.Core.IPluginManager)">
            <summary>
            使用<see cref="T:TouchSocket.Http.WebSockets.IWebSocketClient"/>断线重连。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="pluginManager"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.WebSocketPluginManagerExtension.UseWebSocketReconnection(TouchSocket.Core.IPluginManager)">
            <summary>
            使用<see cref="T:TouchSocket.Http.WebSockets.IWebSocketClient"/>断线重连。
            </summary>
            <param name="pluginManager"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Resources.TouchSocketHttpResource">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketHttpResource.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketHttpResource.Culture">
            <summary>
              重写当前线程的 CurrentUICulture 属性，对
              使用此强类型资源类的所有资源查找执行重写。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketHttpResource.NotAllowAsyncRead">
            <summary>
              查找类似 当AllowAsyncRead为false时，不支持该操作。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketHttpResource.RefuseWebSocketConnection">
            <summary>
              查找类似 主动拒绝WebSocket连接，信息：{0} 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketHttpResource.WebSocketConnectionProtocolIsIncorrect">
            <summary>
              查找类似 WebSocket连接协议不正确，这可能并不是一个WebSocket连接。 的本地化字符串。
            </summary>
        </member>
    </members>
</doc>
