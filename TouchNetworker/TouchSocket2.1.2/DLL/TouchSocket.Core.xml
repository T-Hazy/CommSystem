<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TouchSocket.Core</name>
    </assembly>
    <members>
        <member name="T:TouchSocket.Core.AppMessageAttribute">
            <summary>
            注册为消息
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AppMessageAttribute.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AppMessageAttribute.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="token"></param>
        </member>
        <member name="P:TouchSocket.Core.AppMessageAttribute.Token">
            <summary>
            标识
            </summary>
        </member>
        <member name="T:TouchSocket.Core.AppMessenger">
            <summary>
            消息通知类。内部全为弱引用。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.AppMessenger.Default">
            <summary>
            默认单例实例
            </summary>
        </member>
        <member name="P:TouchSocket.Core.AppMessenger.AllowMultiple">
            <summary>
            允许多广播注册
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.Add(System.String,TouchSocket.Core.MessageInstance)">
            <summary>
            添加
            </summary>
            <param name="token"></param>
            <param name="messageInstance"></param>
            <exception cref="T:TouchSocket.Core.MessageRegisteredException"></exception>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.CanSendMessage(System.String)">
            <summary>
            判断能否触发该消息，意味着该消息是否已经注册。
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.Clear">
            <summary>
            清除所有消息
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.GetAllMessage">
            <summary>
            获取所有消息
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.Remove(System.String)">
            <summary>
            移除
            </summary>
            <param name="token"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.Remove(TouchSocket.Core.IMessageObject)">
            <summary>
            按对象移除
            </summary>
            <param name="messageObject"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.SendAsync(System.String,System.Object[])">
            <summary>
            发送消息
            </summary>
            <param name="token"></param>
            <param name="parameters"></param>
            <exception cref="T:TouchSocket.Core.MessageNotFoundException"></exception>
        </member>
        <member name="M:TouchSocket.Core.AppMessenger.SendAsync``1(System.String,System.Object[])">
            <summary>
            发送消息，当多播时，只返回最后一个返回值
            </summary>
            <typeparam name="T">返回值类型</typeparam>
            <param name="token"></param>
            <param name="parameters"></param>
            <returns></returns>
            <exception cref="T:TouchSocket.Core.MessageNotFoundException"></exception>
        </member>
        <member name="T:TouchSocket.Core.AppMessengerExtensions">
            <summary>
            AppMessengerExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register(TouchSocket.Core.AppMessenger,TouchSocket.Core.IMessageObject)">
            <summary>
            注册消息
            </summary>
            <param name="appMessenger"></param>
            <param name="messageObject"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Register(TouchSocket.Core.AppMessenger,TouchSocket.Core.IMessageObject,System.String,System.Reflection.MethodInfo)">
            <summary>
            注册消息
            </summary>
            <param name="appMessenger"></param>
            <param name="messageObject"></param>
            <param name="token"></param>
            <param name="methodInfo"></param>
            <exception cref="T:TouchSocket.Core.MessageRegisteredException"></exception>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.RegisterStatic``1(TouchSocket.Core.AppMessenger)">
            <summary>
            注册类的静态消息
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.RegisterStatic(TouchSocket.Core.AppMessenger,System.Type)">
            <summary>
            注册类的静态消息
            </summary>
            <param name="appMessenger"></param>
            <param name="type"></param>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Unregister(TouchSocket.Core.AppMessenger,TouchSocket.Core.IMessageObject)">
            <summary>
            卸载消息
            </summary>
            <param name="appMessenger"></param>
            <param name="messageObject"></param>
        </member>
        <member name="M:TouchSocket.Core.AppMessengerExtensions.Unregister(TouchSocket.Core.AppMessenger,System.String)">
            <summary>
            移除注册
            </summary>
            <param name="appMessenger"></param>
            <param name="token"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:TouchSocket.Core.IMessageObject">
            <summary>
            限定消息的接口
            </summary>
        </member>
        <member name="T:TouchSocket.Core.MessageInstance">
            <summary>
            MessageInstance
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MessageInstance.#ctor(System.Reflection.MethodInfo,System.Object)">
            <summary>
            MessageInstance
            </summary>
            <param name="method"></param>
            <param name="messageObject"></param>
        </member>
        <member name="P:TouchSocket.Core.MessageInstance.MessageObject">
            <summary>
            承载消息的实体
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MessageInstance.WeakReference">
            <summary>
            弱引用。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.TouchSocketBitConverter">
            <summary>
            提供了与TouchSocket库相关的字节序列和对象之间的转换功能。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TouchSocketBitConverter.BigEndian">
            <summary>
            以大端
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TouchSocketBitConverter.BigSwapEndian">
            <summary>
            以交换大端
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TouchSocketBitConverter.LittleEndian">
            <summary>
            以小端
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TouchSocketBitConverter.LittleSwapEndian">
            <summary>
            以交换小端
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.#ctor(TouchSocket.Core.EndianType)">
            <summary>
            初始化 TouchSocketBitConverter 类的新实例。
            </summary>
            <param name="endianType">指定字节序类型，可以是大端字节序或小端字节序。</param>
        </member>
        <member name="P:TouchSocket.Core.TouchSocketBitConverter.Default">
            <summary>
            以默认小端，可通过<see cref="P:TouchSocket.Core.TouchSocketBitConverter.DefaultEndianType"/>重新指定默认端。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TouchSocketBitConverter.DefaultEndianType">
            <summary>
            默认大小端切换。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TouchSocketBitConverter.EndianType">
            <summary>
            获取字节序类型
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBitConverter(TouchSocket.Core.EndianType)">
            <summary>
            根据字节序类型获取相应的字节交换器
            </summary>
            <param name="endianType">字节序类型</param>
            <returns>对应的字节交换器</returns>
            <exception cref="T:System.InvalidOperationException">当字节序类型不支持时抛出</exception>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.IsSameOfSet">
            <summary>
            判断当前字节序是否与系统字节序相同
            </summary>
            <returns>如果字节序相同返回true，否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.To``1(System.ReadOnlySpan{System.Byte})">
            <summary>
            将字节跨度转换为指定类型
            </summary>
            <typeparam name="T">要转换成的类型</typeparam>
            <param name="span">要转换的字节跨度</param>
            <returns>转换后的值</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">当字节跨度长度不足以表示类型T时抛出</exception>
            <exception cref="T:System.NotSupportedException">当类型T不支持时抛出</exception>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.UnsafeTo``1(System.Byte@)">
            <summary>
            不安全地将字节引用转换为指定类型
            </summary>
            <typeparam name="T">要转换成的类型</typeparam>
            <param name="source">要转换的字节引用</param>
            <returns>转换后的值</returns>
            <exception cref="T:System.NotSupportedException">当类型T不支持时抛出</exception>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.UnsafeWriteBytes``1(System.Byte@,``0)">
            <summary>
            不安全地将值直接写入字节数组中。
            </summary>
            <typeparam name="T">要写入的值的类型，必须是值类型。</typeparam>
            <param name="source">指向字节数组的引用，从这里开始写入。</param>
            <param name="value">要写入的值。</param>
            <returns>写入的字节数。</returns>
            <remarks>
            此方法用于在字节数组中直接插入结构，主要用于性能考虑。
            它绕过了C#的类型安全性，因此使用时必须确保T是固定大小的值类型。
            如果数据格式不匹配或大小不支持，将抛出异常。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.WriteBytes``1(System.Span{System.Byte},``0)">
            <summary>
            将指定值的字节表示形式写入到指定的字节跨度中。
            </summary>
            <typeparam name="T">要写入的值的类型，必须是非托管类型。</typeparam>
            <param name="span">要写入字节的目标跨度。</param>
            <param name="value">要写入的值。</param>
            <returns>写入的字节数。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.UInt16)">
            <summary>
            将ushort类型值转换为字节数组。
            </summary>
            <param name="value">要转换的ushort类型值。</param>
            <returns>转换后的字节数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToUInt16(System.Byte[],System.Int32)">
            <summary>
            转换为指定端模式的2字节转换为UInt16数据。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.UInt64)">
            <summary>
            将指定的ulong类型值转换为8字节的字节数组。
            此方法主要用于处理数据转换，确保数据格式符合特定需求。
            </summary>
            <param name="value">需要转换的ulong类型值。</param>
            <returns>转换后的8字节字节数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Byte@,System.UInt64)">
            <summary>
            将ulong类型值转换为指定端的8字节
            </summary>
            <param name="buffer">指向存放转换后字节的缓冲区的引用</param>
            <param name="value">需要转换的ulong类型值</param>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToUInt64(System.Byte[],System.Int32)">
            <summary>
            转换为指定端模式的Ulong数据。
            </summary>
            <param name="buffer">包含要转换数据的字节数组。</param>
            <param name="offset">要转换数据的起始位置。</param>
            <returns>转换后的ulong数据。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">如果offset参数导致转换的字节数不足8字节，则抛出此异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Boolean)">
            <summary>
            将布尔值转换为指定端1字节
            </summary>
            <param name="value">要转换的布尔值</param>
            <returns>转换后的字节数组</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Boolean[])">
            <summary>
            将布尔数组转为字节数组。不足位补0。
            </summary>
            <param name="values">待转换的布尔数组。</param>
            <returns>转换后的字节数组。</returns>
            <exception cref="T:System.ArgumentNullException">如果传入的布尔数组为null，则抛出此异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Byte@,System.Boolean)">
            <summary>
            将布尔值转换为指定端1字节
            </summary>
            <param name="buffer">指向用于存储转换结果的字节的引用</param>
            <param name="value">要转换的布尔值</param>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Byte@,System.Boolean[])">
            <summary>
            将布尔值数组转换为字节序列。
            </summary>
            <param name="buffer">指向目标字节缓冲区的引用。</param>
            <param name="values">待转换的布尔值数组。</param>
            <exception cref="T:System.ArgumentNullException">如果values参数为null，则抛出此异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToBoolean(System.Byte[],System.Int32)">
            <summary>
             转换为指定端模式的bool数据。
            </summary>
            <param name="buffer">包含转换为bool所需的字节的字节数组。</param>
            <param name="offset">从buffer中的哪个位置开始读取字节的偏移量。</param>
            <returns>从指定的字节数组和偏移量位置转换得到的bool值。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToBooleans(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将指定的字节，按位解析为bool数组。
            </summary>
            <param name="buffer">包含待解析位的字节数组。</param>
            <param name="offset">在字节数组中开始解析的起始位置。</param>
            <param name="length">要解析的字节数。</param>
            <returns>返回一个bool数组，其中每个元素对应字节中的一个位。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToBooleans(System.Byte@,System.Int32)">
            <summary>
            将指定的字节，按位解析为bool数组。
            </summary>
            <param name="buffer">指向待解析的字节缓冲区的引用。</param>
            <param name="length">要解析的字节数。</param>
            <returns>包含每个字节按位解析后的bool值的数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToBooleans(System.ReadOnlySpan{System.Byte},System.Int32)">
            <summary>
            将字节的只读跨度转换为布尔值数组。
            </summary>
            <param name="span">要转换的字节跨度。</param>
            <param name="length">要处理的字节长度。</param>
            <returns>转换后的布尔值数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Char)">
            <summary>
            将指定字符转换为字节数组
            </summary>
            <param name="value">要转换的字符</param>
            <returns>字节数组</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Byte@,System.Char)">
            <summary>
            将指定值转换为2字节，并存储到缓冲区中
            </summary>
            <param name="buffer">指向存储转换后字节的缓冲区的引用</param>
            <param name="value">要转换的字符值</param>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToChar(System.Byte[],System.Int32)">
            <summary>
             转换为指定端模式的Char数据。
            </summary>
            <param name="buffer">包含要转换数据的字节数组。</param>
            <param name="offset">要转换数据的起始位置。</param>
            <returns>转换后的Char数据。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">如果offset参数导致无法转换出Char数据，则抛出此异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Int16)">
            <summary>
            将16位整数转换为指定字节序的字节数组。
            </summary>
            <param name="value">要转换的16位整数。</param>
            <returns>包含转换后字节的字节数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Byte@,System.Int16)">
            <summary>
            将16位整数转换为指定字节序，并存储在指定的字节缓冲区中。
            </summary>
            <param name="buffer">目标字节缓冲区。</param>
            <param name="value">要转换的16位整数。</param>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToInt16(System.Byte[],System.Int32)">
            <summary>
            从指定字节数组和偏移量处读取两个字节，并根据设定的字节序模式转换为16位整数。
            </summary>
            <param name="buffer">包含数据的字节数组。</param>
            <param name="offset">从字节数组中的哪个位置开始读取。</param>
            <returns>转换得到的16位整数。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Int32)">
            <summary>
            将整数转换为指定字节序的4字节数组。
            </summary>
            <param name="value">要转换的整数。</param>
            <returns>转换后的字节数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Byte@,System.Int32)">
            <summary>
            将整数转换为指定字节序，并存储在给定的字节数组中。
            </summary>
            <param name="buffer">存储转换结果的字节数组。</param>
            <param name="value">要转换的整数。</param>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToInt32(System.Byte[],System.Int32)">
            <summary>
            从字节数组中根据指定字节序转换为int。
            </summary>
            <param name="buffer">包含要转换数据的字节数组。</param>
            <param name="offset">数据在字节数组中的起始位置。</param>
            <returns>转换得到的整数。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">如果从offset开始不足4个字节，抛出此异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Int64)">
            <summary>
            将长整型值转换为按指定端序排列的8字节数组。
            </summary>
            <param name="value">要转换的长整型值。</param>
            <returns>一个包含转换后的8字节的数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Byte@,System.Int64)">
            <summary>
            将长整型值转换为按指定端序排列的字节，并存储在缓冲区中。
            </summary>
            <param name="buffer">存储转换后数据的缓冲区。</param>
            <param name="value">要转换的长整型值。</param>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToInt64(System.Byte[],System.Int32)">
            <summary>
            从字节数组中读取按指定端序排列的long值。
            </summary>
            <param name="buffer">包含数据的字节数组。</param>
            <param name="offset">从数组的哪个位置开始读取数据。</param>
            <returns>读取到的长整型值。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.UInt32)">
            <summary>
            将无符号整数转换为指定字节序的4字节数组。
            </summary>
            <param name="value">要转换的无符号整数。</param>
            <returns>表示该无符号整数的4字节数组，按指定字节序排列。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Byte@,System.UInt32)">
            <summary>
            将无符号整数转换为指定字节序，并存储在给定的字节数组中。
            </summary>
            <param name="buffer">存储转换结果的字节数组。</param>
            <param name="value">要转换的无符号整数。</param>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToUInt32(System.Byte[],System.Int32)">
            <summary>
            从指定字节序的字节数组中转换出无符号整数。
            </summary>
            <param name="buffer">包含要转换数据的字节数组。</param>
            <param name="offset">数据在字节数组中的起始位置。</param>
            <returns>转换得到的无符号整数。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">如果从offset开始不足4个字节，则抛出此异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Single)">
            <summary>
            将浮点数转换为指定字节序的4字节数组。
            </summary>
            <param name="value">要转换的浮点数。</param>
            <returns>转换后的字节数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Byte@,System.Single)">
            <summary>
            将浮点数转换为指定字节序的字节数组，并存储在指定缓冲区中。
            </summary>
            <param name="buffer">存储转换结果的缓冲区。</param>
            <param name="value">要转换的浮点数。</param>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToSingle(System.Byte[],System.Int32)">
            <summary>
            从字节数组中按指定字节序读取浮点数。
            </summary>
            <param name="buffer">包含浮点数数据的字节数组。</param>
            <param name="offset">数据在数组中的起始位置。</param>
            <returns>读取到的浮点数。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Double)">
            <summary>
            将指定的双精度浮点数转换为对应字节端序的8字节数组。
            </summary>
            <param name="value">要转换的双精度浮点数。</param>
            <returns>对应的字节数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Byte@,System.Double)">
            <summary>
            将指定的双精度浮点数转换为对应字节端序的8字节，并存储在指定的字节数组中。
            </summary>
            <param name="buffer">用于存储转换结果的字节数组。</param>
            <param name="value">要转换的双精度浮点数。</param>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToDouble(System.Byte[],System.Int32)">
            <summary>
            将指定偏移量的字节数组转换为对应字节端序的双精度浮点数。
            </summary>
            <param name="buffer">包含数据的字节数组。</param>
            <param name="offset">从数组的哪个位置开始读取数据。</param>
            <returns>转换得到的双精度浮点数。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Decimal)">
            <summary>
            将指定的 decimal 值转换为一个包含该值的字节数组。
            </summary>
            <param name="value">要转换的 decimal 值。</param>
            <returns>一个包含转换后的字节的字节数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.GetBytes(System.Byte@,System.Decimal)">
            <summary>
            将指定的 decimal 值转换为一个包含该值的字节数组，并将结果存储在指定的缓冲区中。
            </summary>
            <param name="buffer">存储转换后的字节的缓冲区。</param>
            <param name="value">要转换的 decimal 值。</param>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketBitConverter.ToDecimal(System.Byte[],System.Int32)">
            <summary>
            从指定偏移量处的字节数组中读取一个 decimal 值。
            </summary>
            <param name="buffer">包含要读取的 decimal 值的字节数组。</param>
            <param name="offset">从 buffer 的哪个位置开始读取。</param>
            <returns>从字节数组中读取到的 decimal 值。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">如果从 offset 开始的 buffer 的长度小于 16，则抛出此异常。</exception>
        </member>
        <member name="T:TouchSocket.Core.CacheEntry`2">
            <summary>
            缓存实体
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CacheEntry`2.#ctor(`0)">
            <summary>
            初始化缓存项对象。
            </summary>
            <param name="key">缓存项的键。</param>
        </member>
        <member name="M:TouchSocket.Core.CacheEntry`2.#ctor(`0,`1)">
            <summary>
            构造函数：初始化缓存条目。
            </summary>
            <param name="key">缓存条目的键。</param>
            <param name="value">缓存条目的值。</param>
        </member>
        <member name="P:TouchSocket.Core.CacheEntry`2.Duration">
            <summary>
            有效区间。如果想长期有效，请使用<see cref="F:System.TimeSpan.Zero"/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.CacheEntry`2.Key">
            <summary>
            键
            </summary>
        </member>
        <member name="P:TouchSocket.Core.CacheEntry`2.UpdateTime">
            <summary>
            更新时间
            </summary>
        </member>
        <member name="P:TouchSocket.Core.CacheEntry`2.Value">
            <summary>
            值
            </summary>
        </member>
        <member name="T:TouchSocket.Core.CacheManagementExtensions">
            <summary>
            CacheExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CacheManagementExtensions.AddCache``2(TouchSocket.Core.ICache{``0,``1},``0,``1,System.Int32)">
            <summary>
            向缓存中添加键值对条目。
            </summary>
            <param name="cacheManagement">实现缓存管理的接口。</param>
            <param name="key">缓存条目的键。</param>
            <param name="value">缓存条目的值。</param>
            <param name="duration">缓存条目存在的持续时间（以毫秒为单位），默认为60分钟。</param>
        </member>
        <member name="M:TouchSocket.Core.CacheManagementExtensions.SetCache``2(TouchSocket.Core.ICache{``0,``1},``0,``1,System.Int32)">
            <summary>
            将指定的键值对存储到缓存中，并设置缓存项的过期时间。
            </summary>
            <param name="cacheManagement">实现缓存管理的接口实例。</param>
            <param name="key">缓存项的键。</param>
            <param name="value">缓存项的值。</param>
            <param name="duration">缓存项的持续时间（以毫秒为单位），默认为60秒。</param>
        </member>
        <member name="M:TouchSocket.Core.CacheManagementExtensions.TryGetValue``2(TouchSocket.Core.ICache{``0,``1},``0,``1@,System.Boolean)">
            <summary>
            尝试从缓存中获取值。
            </summary>
            <typeparam name="TKey">缓存键的类型。</typeparam>
            <typeparam name="TValue">缓存值的类型。</typeparam>
            <param name="cacheClient">缓存客户端实例。</param>
            <param name="key">要获取的缓存键。</param>
            <param name="value">输出参数，包含获取的缓存值。</param>
            <param name="update">是否更新缓存项的时间戳。</param>
            <returns>如果成功获取值则返回true，否则返回false。</returns>
        </member>
        <member name="T:TouchSocket.Core.ICache`2">
            <summary>
            缓存键值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.AddCache(TouchSocket.Core.ICacheEntry{`0,`1})">
            <summary>
            添加缓存。当缓存存在时，不会添加成功。
            </summary>
            <param name="entity">缓存实体</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.ClearCache">
            <summary>
            清空所有缓存
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.ContainsCache(`0)">
            <summary>
            判断缓存是否存在，且在生命周期内。
            </summary>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.SetCache(TouchSocket.Core.ICacheEntry{`0,`1})">
            <summary>
            设置缓存，不管缓存存不存在，都会添加。
            </summary>
            <param name="entity"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.GetCache(`0)">
            <summary>
            获取指定键的缓存。
            </summary>
            <param name="key">键</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ICache`2.RemoveCache(`0)">
            <summary>
            移除指定键的缓存。
            </summary>
            <param name="key">键</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:TouchSocket.Core.ICacheAsync`2">
            <summary>
            缓存键值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ICacheAsync`2.AddCacheAsync(TouchSocket.Core.ICacheEntry{`0,`1})">
            <summary>
            添加缓存。当缓存存在时，不会添加成功。
            </summary>
            <param name="entity">要添加的缓存项，类型为ICacheEntry泛型接口。</param>
            <returns>返回一个<see cref="T:System.Boolean"/>类型的异步操作结果，表示添加缓存项的操作是否成功。</returns>
        </member>
        <member name="M:TouchSocket.Core.ICacheAsync`2.ClearCacheAsync">
            <summary>
            清空所有缓存
            </summary>
            <returns>一个异步任务，表示清空缓存操作</returns>
        </member>
        <member name="M:TouchSocket.Core.ICacheAsync`2.ContainsCacheAsync(`0)">
            <summary>
            异步判断指定键的缓存是否存在且在生命周期内。
            </summary>
            <param name="key">缓存的键。</param>
            <returns>返回一个Task对象，其结果指示缓存是否存在且在生命周期内。</returns>
            <exception cref="T:System.ArgumentNullException">当键值为空时抛出。</exception>
        </member>
        <member name="M:TouchSocket.Core.ICacheAsync`2.GetCacheAsync(`0)">
            <summary>
            异步获取指定键的缓存条目。
            </summary>
            <param name="key">用于检索缓存条目的键。</param>
            <returns>返回一个任务，该任务结果包含缓存条目。</returns>
            <exception cref="T:System.ArgumentNullException">当键为null时抛出此异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.ICacheAsync`2.RemoveCacheAsync(`0)">
            <summary>
            异步移除缓存项。
            </summary>
            <param name="key">缓存项的键。</param>
            <returns>移除操作是否成功的布尔值。</returns>
        </member>
        <member name="M:TouchSocket.Core.ICacheAsync`2.SetCacheAsync(TouchSocket.Core.ICacheEntry{`0,`1})">
            <summary>
            设置缓存，不管缓存存不存在，都会添加。
            </summary>
            <param name="entity">要添加到缓存中的项，类型为ICacheEntry泛型接口。</param>
            <returns>返回一个<see cref="T:System.Boolean"/>类型的异步操作结果，表示缓存设置操作是否成功。</returns>
            <exception cref="T:System.ArgumentNullException">当尝试将null作为缓存项添加时，抛出此异常。</exception>
        </member>
        <member name="T:TouchSocket.Core.ICacheEntry">
            <summary>
            缓存实体接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ICacheEntry.Duration">
            <summary>
            有效区间。如果想长期有效，请使用<see cref="F:System.TimeSpan.Zero"/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ICacheEntry.UpdateTime">
            <summary>
            更新时间
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ICacheEntry`2">
            <summary>
            缓存实体接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ICacheEntry`2.Key">
            <summary>
            键
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ICacheEntry`2.Value">
            <summary>
            值
            </summary>
        </member>
        <member name="T:TouchSocket.Core.MemoryCache`2">
            <summary>
            一个简单的内存缓存
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.#ctor">
            <summary>
             一个简单的内存缓存
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MemoryCache`2.Remove">
            <summary>
            当每个元素超时被移除时触发。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.AddCache(TouchSocket.Core.ICacheEntry{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.AddCacheAsync(TouchSocket.Core.ICacheEntry{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.ClearCache">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.ClearCacheAsync">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.ContainsCache(`0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.ContainsCacheAsync(`0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.GetCache(`0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.GetCacheAsync(`0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.RemoveCache(`0,TouchSocket.Core.ICacheEntry{`0,`1}@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.RemoveCache(`0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.RemoveCacheAsync(`0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.SetCache(TouchSocket.Core.ICacheEntry{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemoryCache`2.SetCacheAsync(TouchSocket.Core.ICacheEntry{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.AsyncBoundedQueue`1">
            <summary>
            异步有界队列类，基于值任务源。
            </summary>
            <typeparam name="T">队列中元素的类型。</typeparam>
        </member>
        <member name="M:TouchSocket.Core.AsyncBoundedQueue`1.#ctor(System.Int32)">
            <summary>
            构造函数，初始化有界队列。
            </summary>
            <param name="capacity">队列的最大容量，必须为正数。</param>
        </member>
        <member name="M:TouchSocket.Core.AsyncBoundedQueue`1.DequeueAsync(System.Threading.CancellationToken)">
            <summary>
            异步取出队列中的一个元素。
            </summary>
            <param name="cancellationToken">取消操作的令牌。</param>
            <returns>一个ValueTask对象，可以异步等待。</returns>
        </member>
        <member name="M:TouchSocket.Core.AsyncBoundedQueue`1.EnqueueAsync(`0,System.Threading.CancellationToken)">
            <summary>
            异步向队列中添加一个元素。
            </summary>
            <param name="item">要添加到队列中的元素。</param>
            <param name="cancellationToken">取消操作的令牌。</param>
        </member>
        <member name="M:TouchSocket.Core.AsyncBoundedQueue`1.GetResult">
            <summary>
            从队列中取出一个元素并返回。
            </summary>
            <returns>队列中的一个元素。</returns>
        </member>
        <member name="M:TouchSocket.Core.AsyncBoundedQueue`1.Scheduler(System.Action{System.Object},System.Object)">
            <summary>
            执行调度操作，直接执行给定的操作。
            </summary>
            <param name="action">要执行的操作。</param>
            <param name="state">操作的状态对象。</param>
        </member>
        <member name="T:TouchSocket.Core.ConcurrentDoublyDictionary`2">
            <summary>
            安全双向字典
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentDoublyDictionary`2.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentDoublyDictionary`2.KeyToValue">
            <summary>
            由键指向值得集合
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentDoublyDictionary`2.ValueToKey">
            <summary>
            由值指向键的集合
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentDoublyDictionary`2.TryAdd(`0,`1)">
            <summary>
             尝试将指定的键和值添加到字典中。
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentDoublyDictionary`2.TryRemoveFromKey(`0,`1@)">
            <summary>
            由键尝试移除
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentDoublyDictionary`2.TryRemoveFromValue(`1,`0@)">
            <summary>
            由值尝试移除
            </summary>
            <param name="value"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentDoublyDictionary`2.TryGetFromKey(`0,`1@)">
            <summary>
            由键获取到值
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentDoublyDictionary`2.TryGetFromValue(`1,`0@)">
            <summary>
            由值获取到键
            </summary>
            <param name="value"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.ConcurrentList`1">
            <summary>
            线程安全的List，其基本操作和List一致。
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            构造函数
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.#ctor(System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentList`1.Count">
            <summary>
            元素数量
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentList`1.IsReadOnly">
            <summary>
            是否为只读
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentList`1.Item(System.Int32)">
            <summary>
            获取索引元素
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Add(`0)">
            <summary>
            添加元素
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Clear">
            <summary>
            清空所有元素
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Contains(`0)">
            <summary>
            是否包含某个元素
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.CopyTo(`0[],System.Int32)">
            <summary>
            复制到
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.GetEnumerator">
            <summary>
            返回迭代器
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            返回迭代器组合
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.IndexOf(`0)">
            <summary>
            索引
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Insert(System.Int32,`0)">
            <summary>
            插入
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Remove(`0)">
            <summary>
            移除元素
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.RemoveAt(System.Int32)">
            <summary>
            按索引移除
            </summary>
            <param name="index"></param>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentList`1.Capacity">
            <summary>
            获取或设置容量
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.BinarySearch(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.BinarySearch(`0)"/>
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})"/>
            </summary>
            <param name="item"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})"/>
            </summary>
            <param name="index"></param>
            <param name="count"></param>
            <param name="item"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.ConvertAll``1(System.Converter{`0,``0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})"/>
            </summary>
            <typeparam name="TOutput"></typeparam>
            <param name="converter"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Find(System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})"/>
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindAll(System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})"/>
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
            </summary>
            <param name="startIndex"></param>
            <param name="count"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindIndex(System.Int32,System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})"/>
            </summary>
            <param name="startIndex"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindIndex(System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})"/>
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindLast(System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})"/>
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
            </summary>
            <param name="startIndex"></param>
            <param name="count"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindLastIndex(System.Int32,System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})"/>
            </summary>
            <param name="startIndex"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.FindLastIndex(System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})"/>
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.ForEach(System.Action{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})"/>
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.GetRange(System.Int32,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)"/>
            </summary>
            <param name="index"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.IndexOf(`0,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)"/>
            </summary>
            <param name="item"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)"/>
            </summary>
            <param name="item"></param>
            <param name="index"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})"/>
            </summary>
            <param name="index"></param>
            <param name="collection"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.LastIndexOf(`0)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)"/>
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.LastIndexOf(`0,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)"/>
            </summary>
            <param name="item"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)"/>
            </summary>
            <param name="item"></param>
            <param name="index"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.RemoveAll(System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})"/>
            </summary>
            <param name="match"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)"/>
            </summary>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Reverse">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Reverse"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)"/>
            </summary>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Sort">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Sort"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Sort(System.Comparison{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})"/>
            </summary>
            <param name="comparison"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})"/>
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})"/>
            </summary>
            <param name="index"></param>
            <param name="count"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.ToArray">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.ToArray"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.TrimExcess">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.TrimExcess"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentList`1.TrueForAll(System.Predicate{`0})">
            <summary>
            <inheritdoc cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})"/>
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.Ternary`3">
            <summary>
            三元组合
            </summary>
            <typeparam name="TKey1"></typeparam>
            <typeparam name="TKey2"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.Ternary`3.#ctor(`0,`1,`2)">
            <summary>
            三元组合
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <param name="value"></param>
        </member>
        <member name="P:TouchSocket.Core.Ternary`3.Key1">
            <summary>
            首键
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Ternary`3.Key2">
            <summary>
            次键
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Ternary`3.Value">
            <summary>
            值
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ConcurrentMultiDictionary`3">
            <summary>
            线程安全的双键字典
            </summary>
            <typeparam name="TKey1"></typeparam>
            <typeparam name="TKey2"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentMultiDictionary`3.Count">
            <summary>
            元素数量。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentMultiDictionary`3.Key1s">
            <summary>
            Key1集合
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConcurrentMultiDictionary`3.Key2s">
            <summary>
            Key2集合
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.Clear">
            <summary>
            清空所有元素。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.ContainsKey(`1)">
            <summary>
            是否包含指定键。
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.ContainsKey(`0)">
            <summary>
            是否包含指定键。
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.TryAdd(`0,`1,`2)">
            <summary>
            尝试添加。
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.TryRemove(`0,`2@)">
            <summary>
            由首键删除
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.TryRemove(`1,`2@)">
            <summary>
            由次键删除
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.TryGetValue(`0,`2@)">
            <summary>
            由首键获取值
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConcurrentMultiDictionary`3.TryGetValue(`1,`2@)">
            <summary>
            由次键获取值
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IntelligentConcurrentQueue`1">
            <summary>
            智能安全队列
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.IntelligentConcurrentQueue`1.#ctor(System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="maxCount"></param>
        </member>
        <member name="P:TouchSocket.Core.IntelligentConcurrentQueue`1.MaxCount">
            <summary>
            允许的最大长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IntelligentConcurrentQueue`1.Count">
            <summary>
            长度
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IntelligentConcurrentQueue`1.Enqueue(`0)">
            <summary>
            入队
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:TouchSocket.Core.IntelligentConcurrentQueue`1.TryDequeue(`0@)">
            <summary>
            出队
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IQueueData">
            <summary>
            队列数据
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IQueueData.Size">
            <summary>
            数据长度
            </summary>
        </member>
        <member name="T:TouchSocket.Core.QueueDataBytes">
            <summary>
            传输字节
            </summary>
        </member>
        <member name="M:TouchSocket.Core.QueueDataBytes.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Core.QueueDataBytes.CreateNew(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从指定内存创建一个新对象，且内存也为新创建。
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.QueueDataBytes.#ctor(System.Byte[])">
            <summary>
            构造函数
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="P:TouchSocket.Core.QueueDataBytes.Buffer">
            <summary>
            数据内存
            </summary>
        </member>
        <member name="P:TouchSocket.Core.QueueDataBytes.Length">
            <summary>
            长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.QueueDataBytes.Offset">
            <summary>
            偏移
            </summary>
        </member>
        <member name="P:TouchSocket.Core.QueueDataBytes.Size">
            <summary>
            尺寸
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IntelligentDataQueue`1">
            <summary>
            智能数据安全队列
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.IntelligentDataQueue`1.#ctor(System.Int64)">
            <summary>
            智能数据安全队列
            </summary>
            <param name="maxSize"></param>
        </member>
        <member name="M:TouchSocket.Core.IntelligentDataQueue`1.#ctor">
            <summary>
            智能数据安全队列
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IntelligentDataQueue`1.ActualSize">
            <summary>
            实际尺寸
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IntelligentDataQueue`1.Free">
            <summary>
            是否有空位允许入队
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IntelligentDataQueue`1.MaxSize">
            <summary>
            允许的最大长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IntelligentDataQueue`1.OnQueueChanged">
            <summary>
            在队列修改时
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IntelligentDataQueue`1.OverflowWait">
            <summary>
            溢出等待
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IntelligentDataQueue`1.Timeout">
            <summary>
            超时时间。默认1000*30ms；
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IntelligentDataQueue`1.Clear(System.Action{`0})">
            <summary>
            清空队列
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IntelligentDataQueue`1.Enqueue(`0)">
            <summary>
            入队
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:TouchSocket.Core.IntelligentDataQueue`1.TryDequeue(`0@)">
            <summary>
            出队
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.TriggerQueue`1">
            <summary>
            触发器队列
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.TriggerQueue`1.#ctor">
            <summary>
             触发器队列
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TriggerQueue`1.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TriggerQueue`1.OnDequeue">
            <summary>
            出队列处理。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TriggerQueue`1.OnError">
            <summary>
            发生错误
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TriggerQueue`1.Sending">
            <summary>
            是否处于发送状态
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TriggerQueue`1.Enqueue(`0)">
            <summary>
            发送
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TriggerQueue`1.Dispose(System.Boolean)">
            <summary>
            释放
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:TouchSocket.Core.IgnoreCaseNameValueCollection">
            <summary>
            IgnoreCaseNameValueCollection
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IgnoreCaseNameValueCollection.#ctor">
            <summary>
            IgnoreCaseNameValueCollection
            </summary>
        </member>
        <member name="T:TouchSocket.Core.NameValueCollectionDebugView">
            <summary>
            NameValueCollectionDebugView
            </summary>
        </member>
        <member name="M:TouchSocket.Core.NameValueCollectionDebugView.#ctor(System.Collections.Specialized.NameValueCollection)">
            <summary>
            NameValueCollectionDebugView
            </summary>
            <param name="nameValue"></param>
        </member>
        <member name="T:TouchSocket.Core.ConfigEventArgs">
            <summary>
            配置事件参数类，继承自PluginEventArgs
            该类用于封装配置相关的事件参数，主要携带了TouchSocket配置信息
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConfigEventArgs.#ctor(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            初始化ConfigEventArgs类的实例
            </summary>
            <param name="config">TouchSocket配置对象</param>
        </member>
        <member name="P:TouchSocket.Core.ConfigEventArgs.Config">
            <summary>
            具体配置
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ConfigObject">
            <summary>
            具有配置设置的对象
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConfigObject.Config">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ConfigObject.Logger">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ConfigObject.ThrowIfConfigIsNull">
            <summary>
            如果<see cref="P:TouchSocket.Core.ConfigObject.Config"/>为空，则抛出<see cref="T:System.ArgumentNullException"/>的异常。
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:TouchSocket.Core.IConfigObject">
            <summary>
            具有配置的对象接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IConfigObject.Config">
            <summary>
            配置项
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ILoadedConfigPlugin">
            <summary>
            定义了一个插件接口，用于在配置加载完成后执行特定操作。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ILoadedConfigPlugin.OnLoadedConfig(TouchSocket.Core.IConfigObject,TouchSocket.Core.ConfigEventArgs)">
            <summary>
            当配置加载完成时调用。
            </summary>
            <param name="sender">发送事件的对象，这里是配置对象本身。</param>
            <param name="e">包含事件数据的事件参数。</param>
            <returns>一个任务对象，表示异步操作的结果。</returns>
        </member>
        <member name="T:TouchSocket.Core.ILoadingConfigPlugin">
            <summary>
            当正在配置Config时触发。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ILoadingConfigPlugin.OnLoadingConfig(TouchSocket.Core.IConfigObject,TouchSocket.Core.ConfigEventArgs)">
            <summary>
            当载入配置时
            </summary>
            <param name="sender">发送事件的对象</param>
            <param name="e">事件参数，包含配置信息</param>
            <returns>一个异步任务</returns>
        </member>
        <member name="T:TouchSocket.Core.IResolverConfigObject">
            <summary>
            具有<see cref="T:TouchSocket.Core.IResolver"/>相关成员的配置对象接口
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ISetupConfigObject">
            <summary>
            具有设置配置的对象接口
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ISetupConfigObject.SetupAsync(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            异步配置设置项
            </summary>
            <param name="config">配置对象</param>
            <returns>异步任务</returns>
        </member>
        <member name="T:TouchSocket.Core.ResolverConfigObject">
            <summary>
            具有<see cref="T:TouchSocket.Core.IResolver"/>相关成员的配置对象
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ResolverConfigObject.PluginManager">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ResolverConfigObject.Resolver">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.SetupConfigObject">
            <summary>
            具有设置配置的对象
            </summary>
        </member>
        <member name="P:TouchSocket.Core.SetupConfigObject.Config">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.SetupConfigObject.PluginManager">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.SetupConfigObject.Resolver">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.SetupConfigObject.SetupAsync(TouchSocket.Core.TouchSocketConfig)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.SetupConfigObject.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.SetupConfigObject.LoadConfig(TouchSocket.Core.TouchSocketConfig)">
            <summary>
            加载配置
            </summary>
            <param name="config">要加载的配置对象</param>
        </member>
        <member name="T:TouchSocket.Core.SetupConfigObjectExtension">
            <summary>
            提供配置对象的扩展方法。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SetupConfigObjectExtension.Setup(TouchSocket.Core.ISetupConfigObject,TouchSocket.Core.TouchSocketConfig)">
            <summary>
            同步配置方法。
            使用给定的配置对象进行设置。
            </summary>
            <param name="setupConfigObject">要配置的配置对象。</param>
            <param name="config">用于配置的配置对象。</param>
        </member>
        <member name="T:TouchSocket.Core.TouchSocketConfig">
            <summary>
            配置文件基类
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketConfig.Clone">
            <summary>
            克隆配置依赖项，并返回一个新的克隆对象。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.TouchSocketCoreConfigExtension">
            <summary>
            TouchSocketCoreConfigExtension
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TouchSocketCoreConfigExtension.ConfigurePluginsProperty">
            <summary>
            配置插件。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketCoreConfigExtension.ConfigurePlugins(TouchSocket.Core.TouchSocketConfig,System.Action{TouchSocket.Core.IPluginManager})">
            <summary>
            配置插件。
            </summary>
            <param name="config">配置对象。</param>
            <param name="value">一个作用于IPluginManager的委托，用于配置插件。</param>
            <returns>返回更新后的配置对象。</returns>
        </member>
        <member name="F:TouchSocket.Core.TouchSocketCoreConfigExtension.ConfigureContainerProperty">
            <summary>
            配置容器注入。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TouchSocketCoreConfigExtension.RegistratorProperty">
            <summary>
            容器注册
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TouchSocketCoreConfigExtension.ResolverProperty">
            <summary>
            容器提供者
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketCoreConfigExtension.ConfigureContainer(TouchSocket.Core.TouchSocketConfig,System.Action{TouchSocket.Core.IRegistrator})">
            <summary>
            配置容器注入。
            </summary>
            <param name="config">待配置的TouchSocketConfig对象。</param>
            <param name="value">一个Action委托，用于注册依赖项。</param>
            <returns>返回配置对象，允许链式调用。</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketCoreConfigExtension.SetResolver(TouchSocket.Core.TouchSocketConfig,TouchSocket.Core.IResolver)">
            <summary>
            设置<see cref="T:TouchSocket.Core.IResolver"/>
            </summary>
            <param name="config">待设置的配置对象</param>
            <param name="value">要设置的解析器实例</param>
            <returns>返回配置对象</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketCoreConfigExtension.SetRegistrator(TouchSocket.Core.TouchSocketConfig,TouchSocket.Core.IRegistrator)">
            <summary>
            设置<see cref="T:TouchSocket.Core.IRegistrator"/>
            </summary>
            <param name="config">当前的<see cref="T:TouchSocket.Core.TouchSocketConfig"/>配置对象</param>
            <param name="value">要设置的<see cref="T:TouchSocket.Core.IRegistrator"/>实例</param>
            <returns>返回配置对象自身，以便进行链式调用</returns>
        </member>
        <member name="T:TouchSocket.Core.DependencyInjectAttribute">
            <summary>
            指定依赖类型。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyInjectAttribute.#ctor">
            <summary>
            默认注入配置
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyInjectAttribute.#ctor(System.String)">
            <summary>
            使用指定Key参数注入。
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:TouchSocket.Core.DependencyInjectAttribute.#ctor(System.Type,System.String)">
            <summary>
            类型，Key指定性注入。
            </summary>
            <param name="type"></param>
            <param name="key"></param>
        </member>
        <member name="M:TouchSocket.Core.DependencyInjectAttribute.#ctor(System.Type)">
            <summary>
            类型，指定性注入。
            </summary>
            <param name="type"></param>
        </member>
        <member name="P:TouchSocket.Core.DependencyInjectAttribute.Key">
            <summary>
            指定键。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyInjectAttribute.Type">
            <summary>
            注入类型
            </summary>
        </member>
        <member name="T:TouchSocket.Core.DependencyTypeAttribute">
            <summary>
            指定依赖类型。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyTypeAttribute.#ctor(TouchSocket.Core.DependencyType)">
            <summary>
            初始化一个依赖类型。当确定某个类型仅以某种特定方式注入时，可以过滤不必要的注入操作，以提高效率。
            </summary>
            <param name="type">可以叠加位域</param>
        </member>
        <member name="P:TouchSocket.Core.DependencyTypeAttribute.Type">
            <summary>
            支持类型。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.Container">
            <summary>
            IOC容器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Container.#ctor">
            <summary>
            IOC容器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Container.BuildResolver">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.Container.GetDescriptors">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.Container.GetService(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.Container.IsRegistered(System.Type,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.Container.IsRegistered(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.Container.Register(TouchSocket.Core.DependencyDescriptor,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.Container.Register(TouchSocket.Core.DependencyDescriptor)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.Container.Resolve(System.Type,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.Container.Resolve(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.Container.Unregister(TouchSocket.Core.DependencyDescriptor,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.Container.Unregister(TouchSocket.Core.DependencyDescriptor)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.CoreContainerExtension">
            <summary>
            ContainerExtension
            </summary>
        </member>
        <member name="F:TouchSocket.Core.CoreContainerExtension.DynamicallyAccessed">
            <summary>
            DynamicallyAccessed
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton``2(TouchSocket.Core.IRegistrator,``1)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTo"></typeparam>
            <param name="registrator"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton(TouchSocket.Core.IRegistrator,System.Object)">
            <summary>
            注册单例
            </summary>
            <param name="registrator"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton(TouchSocket.Core.IRegistrator,System.Type)">
            <summary>
            注册单例
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton``2(TouchSocket.Core.IRegistrator,System.String,``1)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTo"></typeparam>
            <param name="registrator"></param>
            <param name="key"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton(TouchSocket.Core.IRegistrator,System.Type,System.Object,System.String)">
            <summary>
            注册单例
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <param name="instance"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton(TouchSocket.Core.IRegistrator,System.Type,System.Object)">
            <summary>
            注册单例
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton``1(TouchSocket.Core.IRegistrator,System.Object,System.String)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <param name="registrator"></param>
            <param name="instance"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton``1(TouchSocket.Core.IRegistrator,System.Object)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <param name="registrator"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton(TouchSocket.Core.IRegistrator,System.Object,System.String)">
            <summary>
            注册单例
            </summary>
            <param name="registrator"></param>
            <param name="instance"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton``1(TouchSocket.Core.IRegistrator)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <param name="registrator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton``1(TouchSocket.Core.IRegistrator,System.String)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <param name="registrator"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton(TouchSocket.Core.IRegistrator,System.Type,System.Type)">
            <summary>
            注册单例
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <param name="toType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton(TouchSocket.Core.IRegistrator,System.Type,System.Type,System.String)">
            <summary>
            注册单例
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <param name="toType"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton``1(TouchSocket.Core.IRegistrator,System.Func{TouchSocket.Core.IResolver,System.Object})">
            <summary>
            注册单例
            </summary>
            <param name="registrator"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton``2(TouchSocket.Core.IRegistrator,System.Func{TouchSocket.Core.IResolver,System.Object})">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTo"></typeparam>
            <param name="registrator"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton``1(TouchSocket.Core.IRegistrator,System.Func{TouchSocket.Core.IResolver,System.Object},System.String)">
            <summary>
            注册单例
            </summary>
            <param name="registrator"></param>
            <param name="func"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton``2(TouchSocket.Core.IRegistrator,System.Func{TouchSocket.Core.IResolver,System.Object},System.String)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTo"></typeparam>
            <param name="registrator"></param>
            <param name="func"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton(TouchSocket.Core.IRegistrator,System.Type,System.Func{TouchSocket.Core.IResolver,System.Object})">
            <summary>
            注册单例
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton(TouchSocket.Core.IRegistrator,System.Type,System.Func{TouchSocket.Core.IResolver,System.Object},System.String)">
            <summary>
            注册单例
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <param name="func"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton``2(TouchSocket.Core.IRegistrator)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTO"></typeparam>
            <param name="registrator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterSingleton``2(TouchSocket.Core.IRegistrator,System.String)">
            <summary>
            注册单例
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTO"></typeparam>
            <param name="registrator"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterTransient``2(TouchSocket.Core.IRegistrator)">
            <summary>
            注册临时映射
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTO"></typeparam>
            <param name="registrator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterTransient``1(TouchSocket.Core.IRegistrator)">
            <summary>
            注册临时映射
            </summary>
            <typeparam name="TFrom"></typeparam>
            <param name="registrator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterTransient``1(TouchSocket.Core.IRegistrator,System.String)">
            <summary>
            注册临时映射
            </summary>
            <typeparam name="TFrom"></typeparam>
            <param name="registrator"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterTransient``2(TouchSocket.Core.IRegistrator,System.String)">
            <summary>
            注册临时映射
            </summary>
            <typeparam name="TFrom"></typeparam>
            <typeparam name="TTO"></typeparam>
            <param name="registrator"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterTransient(TouchSocket.Core.IRegistrator,System.Type)">
            <summary>
            注册临时映射
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterTransient(TouchSocket.Core.IRegistrator,System.Type,System.String)">
            <summary>
            注册临时映射
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterTransient(TouchSocket.Core.IRegistrator,System.Type,System.Type)">
            <summary>
            注册临时映射
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <param name="toType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterTransient(TouchSocket.Core.IRegistrator,System.Type,System.Type,System.String)">
            <summary>
            注册临时映射
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <param name="toType"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterTransient``1(TouchSocket.Core.IRegistrator,System.Func{TouchSocket.Core.IResolver,System.Object})">
            <summary>
            注册临时映射
            </summary>
            <param name="registrator"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterTransient``1(TouchSocket.Core.IRegistrator,System.Func{TouchSocket.Core.IResolver,System.Object},System.String)">
            <summary>
            注册临时映射
            </summary>
            <param name="registrator"></param>
            <param name="func"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterTransient(TouchSocket.Core.IRegistrator,System.Type,System.Func{TouchSocket.Core.IResolver,System.Object})">
            <summary>
            注册临时映射
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.RegisterTransient(TouchSocket.Core.IRegistrator,System.Type,System.Func{TouchSocket.Core.IResolver,System.Object},System.String)">
            <summary>
            注册临时映射
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <param name="func"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.Unregister(TouchSocket.Core.IRegistrator,System.Type)">
            <summary>
            移除注册信息
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.Unregister(TouchSocket.Core.IRegistrator,System.Type,System.String)">
            <summary>
            移除注册信息
            </summary>
            <param name="registrator"></param>
            <param name="fromType"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.Unregister``1(TouchSocket.Core.IRegistrator)">
            <summary>
            移除注册信息
            </summary>
            <param name="registrator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.Unregister``1(TouchSocket.Core.IRegistrator,System.String)">
            <summary>
            移除注册信息
            </summary>
            <param name="registrator"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.Resolve``1(TouchSocket.Core.IResolver)">
            <summary>
            创建类型对应的实例
            </summary>
            <typeparam name="T"></typeparam>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.Resolve``1(TouchSocket.Core.IResolver,System.String)">
            <summary>
            创建类型对应的实例
            </summary>
            <typeparam name="T"></typeparam>
            <param name="resolver"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.ResolveWithoutRoot(System.IServiceProvider,System.Type)">
            <summary>
            创建<see cref="F:TouchSocket.Core.Lifetime.Transient"/>生命的未注册的根类型实例。一般适用于：目标类型没有注册，但是其成员类型已经注册的情况。
            </summary>
            <param name="resolver"></param>
            <param name="fromType"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.ResolveWithoutRoot``1(System.IServiceProvider)">
            <summary>
            创建<see cref="F:TouchSocket.Core.Lifetime.Transient"/>生命的未注册的根类型实例。一般适用于：目标类型没有注册，但是其成员类型已经注册的情况。
            </summary>
            <param name="resolver"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.TryResolve(TouchSocket.Core.IResolver,System.Type)">
            <summary>
             尝试创建类型对应的实例，如果类型没有注册，则会返回null或者默认值类型。
            </summary>
            <param name="resolver"></param>
            <param name="fromType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.TryResolve(TouchSocket.Core.IResolver,System.Type,System.String)">
            <summary>
             尝试创建类型对应的实例，如果类型没有注册，则会返回null或者默认值类型。
            </summary>
            <param name="resolver"></param>
            <param name="fromType"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.TryResolve``1(TouchSocket.Core.IResolver)">
            <summary>
            尝试创建类型对应的实例，如果类型没有注册，则会返回null或者默认值类型。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.TryResolve``1(TouchSocket.Core.IResolver,System.String)">
            <summary>
            尝试创建类型对应的实例，如果类型没有注册，则会返回null或者默认值类型。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="resolver"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.IsRegistered``1(TouchSocket.Core.IRegistered)">
            <summary>
            <inheritdoc cref="M:TouchSocket.Core.IRegistered.IsRegistered(System.Type)"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="registered"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CoreContainerExtension.IsRegistered``1(TouchSocket.Core.IRegistered,System.String)">
            <summary>
            <inheritdoc cref="M:TouchSocket.Core.IRegistered.IsRegistered(System.Type,System.String)"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="registered"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.DependencyType">
            <summary>
            依赖注入类型。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DependencyType.Constructor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DependencyType.Property">
            <summary>
            属性
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DependencyType.Method">
            <summary>
            方法
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IContainer">
            <summary>
            注入容器接口
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IRegistered">
            <summary>
            IRegistered 接口定义了用于检查类型是否已注册的方法
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IRegistered.IsRegistered(System.Type,System.String)">
            <summary>
            判断某类型是否已经注册
            </summary>
            <param name="fromType">要检查的类型</param>
            <param name="key">与类型关联的唯一键，用于特定的注册场景</param>
            <returns>如果类型已注册，则返回 true；否则返回 false</returns>
        </member>
        <member name="M:TouchSocket.Core.IRegistered.IsRegistered(System.Type)">
            <summary>
            判断某类型是否已经注册
            </summary>
            <param name="fromType">要检查的类型</param>
            <returns>如果类型已注册，则返回 true；否则返回 false</returns>
        </member>
        <member name="T:TouchSocket.Core.IRegistrator">
            <summary>
            容器注册器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IRegistrator.Register(TouchSocket.Core.DependencyDescriptor,System.String)">
            <summary>
            添加类型描述符。
            </summary>
            <param name="key"></param>
            <param name="descriptor"></param>
        </member>
        <member name="M:TouchSocket.Core.IRegistrator.Register(TouchSocket.Core.DependencyDescriptor)">
            <summary>
            添加类型描述符
            </summary>
            <param name="descriptor"></param>
        </member>
        <member name="M:TouchSocket.Core.IRegistrator.Unregister(TouchSocket.Core.DependencyDescriptor,System.String)">
            <summary>
            移除注册信息。
            </summary>
            <param name="descriptor"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IRegistrator.Unregister(TouchSocket.Core.DependencyDescriptor)">
            <summary>
            移除注册信息
            </summary>
            <param name="descriptor"></param>
        </member>
        <member name="M:TouchSocket.Core.IRegistrator.GetDescriptors">
            <summary>
            获取已注册的所有类型描述
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IRegistrator.BuildResolver">
            <summary>
            构建一个服务获取器
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IResolver">
            <summary>
            IResolver 接口定义了如何解析类型实例。
            它继承自 IServiceProvider 和 IRegistered 接口。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IResolver.Resolve(System.Type,System.String)">
            <summary>
            解析给定类型和键对应的实例。
            </summary>
            <param name="fromType">要解析的目标类型。</param>
            <param name="key">可选的实例标识符。</param>
            <returns>解析出的实例。</returns>
        </member>
        <member name="M:TouchSocket.Core.IResolver.Resolve(System.Type)">
            <summary>
            解析给定类型的实例，不使用键。
            </summary>
            <param name="fromType">要解析的目标类型。</param>
            <returns>解析出的实例。</returns>
        </member>
        <member name="T:TouchSocket.Core.IResolverObject">
            <summary>
            IResolverObject接口定义了一个解析对象的标准，该对象包含一个解析器属性。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IResolverObject.Resolver">
            <summary>
            获取解析器实例。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.Lifetime">
            <summary>
            注入项的生命周期。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Lifetime.Singleton">
            <summary>
            单例对象
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Lifetime.Transient">
            <summary>
            瞬时对象
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ManualContainer">
            <summary>
            手动IOC容器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ManualContainer.BuildResolver">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ManualContainer.GetDescriptors">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ManualContainer.GetService(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ManualContainer.IsRegistered(System.Type,System.String)">
            <summary>
            判断指定的类型是否已在容器中注册。
            <para>
            在本容器中，一般均会返回<see langword="true"/>。
            </para>
            </summary>
            <param name="fromType"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ManualContainer.IsRegistered(System.Type)">
            <summary>
            判断指定的类型是否已在容器中注册。
            <para>
            在本容器中，一般均会返回<see langword="true"/>。
            </para>
            </summary>
            <param name="fromType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ManualContainer.Register(TouchSocket.Core.DependencyDescriptor,System.String)">
            <summary>
            注册描述符。
            <para>
            一般情况下，本容器只会处理单例实例模式。
            </para>
            </summary>
            <param name="descriptor"></param>
            <param name="key"></param>
        </member>
        <member name="M:TouchSocket.Core.ManualContainer.Register(TouchSocket.Core.DependencyDescriptor)">
            <summary>
            注册描述符。
            <para>
            一般情况下，本容器只会处理单例实例模式。
            </para>
            </summary>
            <param name="descriptor"></param>
        </member>
        <member name="M:TouchSocket.Core.ManualContainer.Resolve(System.Type,System.String)">
            <inheritdoc/>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.ManualContainer.Resolve(System.Type)">
            <inheritdoc/>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.ManualContainer.Unregister(TouchSocket.Core.DependencyDescriptor,System.String)">
            <summary>
            默认不实现该功能
            </summary>
            <param name="descriptor"></param>
            <param name="key"></param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ManualContainer.Unregister(TouchSocket.Core.DependencyDescriptor)">
            <summary>
            默认不实现该功能
            </summary>
            <param name="descriptor"></param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ManualContainer.TryResolve(System.Type,System.Object@,System.String)">
            <summary>
            尝试解决Ioc容器所需类型。
            <para>
            本方法仅实现了在单例实例注册下的获取。
            </para>
            </summary>
            <param name="fromType"></param>
            <param name="instance"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ManualContainer.TryResolve(System.Type,System.Object@)">
            <summary>
            尝试解决Ioc容器所需类型。
            <para>
            本方法仅实现了在单例实例注册下的获取。
            </para>
            </summary>
            <param name="fromType"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.DynamicBuilderType">
            <summary>
            动态构建类型
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DynamicBuilderType.IL">
            <summary>
            使用IL构建
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DynamicBuilderType.Expression">
            <summary>
            使用表达式树
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DynamicBuilderType.Reflect">
            <summary>
            使用反射
            </summary>
        </member>
        <member name="T:TouchSocket.Core.EndianType">
            <summary>
            大小端类型
            </summary>
        </member>
        <member name="F:TouchSocket.Core.EndianType.Little">
            <summary>
            小端模式，即DCBA
            </summary>
        </member>
        <member name="F:TouchSocket.Core.EndianType.Big">
            <summary>
            大端模式。即ABCD
            </summary>
        </member>
        <member name="F:TouchSocket.Core.EndianType.LittleSwap">
            <summary>
            以交换小端格式。即CDAB
            </summary>
        </member>
        <member name="F:TouchSocket.Core.EndianType.BigSwap">
            <summary>
            以交换大端，即：BADC
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ResultCode">
            <summary>
            结果类型
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ResultCode.Default">
            <summary>
            默认
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ResultCode.Error">
            <summary>
            错误
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ResultCode.Exception">
            <summary>
            异常
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ResultCode.Success">
            <summary>
            成功
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ResultCode.Fail">
            <summary>
            失败
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ResultCode.Overtime">
            <summary>
            操作超时
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ResultCode.Canceled">
            <summary>
            操作取消
            </summary>
        </member>
        <member name="T:TouchSocket.Core.GlobalEnvironment">
            <summary>
            全局环境设置
            </summary>
        </member>
        <member name="P:TouchSocket.Core.GlobalEnvironment.DynamicBuilderType">
            <summary>
            动态构建类型，默认使用IL
            </summary>
        </member>
        <member name="T:TouchSocket.Core.Metadata">
            <summary>
            元数据键值对。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Metadata.Item(System.String)">
            <inheritdoc/>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Metadata.Add(System.String,System.String)">
            <summary>
            向元数据集合添加一个键值对。如果键已经存在，则覆盖其值。
            </summary>
            <param name="name">要添加的键。</param>
            <param name="value">与键关联的值。</param>
            <returns>返回当前元数据对象，以支持链式调用。</returns>
        </member>
        <member name="M:TouchSocket.Core.Metadata.Package``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.Metadata.Unpackage``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.SnowflakeIdGenerator">
            <summary>
            雪花Id生成器(该代码来自网络)
            </summary>
        </member>
        <member name="F:TouchSocket.Core.SnowflakeIdGenerator.SequenceMask">
            <summary>
            一微秒内可以产生计数，如果达到该值则等到下一微妙在进行生成
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SnowflakeIdGenerator.#ctor(System.Int64)">
            <summary>
            初始化 SnowflakeIdGenerator 类的新实例。
            </summary>
            <param name="workerId">工作机器的唯一标识符，用于区分不同的工作机器。</param>
            <exception cref="T:System.Exception">如果 workerId 大于最大工作机器ID或小于0，则抛出异常。</exception>
        </member>
        <member name="P:TouchSocket.Core.SnowflakeIdGenerator.MaxWorkerId">
            <summary>
            最大机器Id
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SnowflakeIdGenerator.NextId">
            <summary>
            获取Id
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SnowflakeIdGenerator.TillNextMillis(System.Int64)">
            <summary>
            获取下一微秒时间戳
            </summary>
            <param name="lastTimestamp"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SnowflakeIdGenerator.TimeGen">
            <summary>
            生成当前时间戳
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.StringResStore">
            <summary>
            字符串资源字典
            </summary>
        </member>
        <member name="M:TouchSocket.Core.StringResStore.GetDescription(System.Enum,System.Object[])">
            <summary>
            获取资源字符
            </summary>
            <param name="enum">枚举值</param>
            <param name="objs">格式化字符串的参数</param>
            <returns>资源字符</returns>
        </member>
        <member name="T:TouchSocket.Core.TouchSocketCoreUtility">
            <summary>
            常量
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TouchSocketCoreUtility.Empty">
            <summary>
            空字符串常亮
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TouchSocketCoreUtility.ZeroBytes">
            <summary>
            0长度字节数组
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketCoreUtility.GenerateRandomInt64">
            <summary>
            生成指定范围内的随机Int64整数
            </summary>
            <returns>返回一个在0到10000000之间的随机Int64整数</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketCoreUtility.IsURL(System.String)">
            <summary>
            判断输入的字符串是否是一个超链接
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketCoreUtility.IsIPv4(System.String)">
            <summary>
            判断输入的字符串是否是表示一个IP地址
            </summary>
            <param name="input">被比较的字符串</param>
            <returns>是IP地址则为True</returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketCoreUtility.IsIPV6(System.String)">
            <summary>
            判断输入的字符串是否是合法的IPV6 地址
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketCoreUtility.HitBufferLength(System.Int64)">
            <summary>
            命中BufferLength
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.AdapterOption">
            <summary>
            适配器配置
            </summary>
        </member>
        <member name="P:TouchSocket.Core.AdapterOption.CacheTimeoutEnable">
            <summary>
            适配器数据包缓存启用。默认为缺省（null），如果有正常值会在设置适配器时，直接作用于<see cref="P:TouchSocket.Core.SingleStreamDataHandlingAdapter.CacheTimeout"/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.AdapterOption.CacheTimeout">
            <summary>
            适配器数据包缓存时长。默认为缺省（null）。当该值有效时会在设置适配器时，直接作用于<see cref="P:TouchSocket.Core.SingleStreamDataHandlingAdapter.CacheTimeout"/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.AdapterOption.MaxPackageSize">
            <summary>
            适配器数据包最大值。默认缺省（null），当该值有效时会在设置适配器时，直接作用于<see cref="P:TouchSocket.Core.DataHandlingAdapter.MaxPackageSize"/>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.AdapterOption.UpdateCacheTimeWhenRev">
            <summary>
             适配器数据包缓存策略。默认缺省（null），当该值有效时会在设置适配器时，直接作用于<see cref="P:TouchSocket.Core.SingleStreamDataHandlingAdapter.UpdateCacheTimeWhenRev"/>
            </summary>
        </member>
        <member name="T:TouchSocket.Core.CacheDataHandlingAdapter">
            <summary>
            CacheDataHandlingAdapter
            </summary>
        </member>
        <member name="F:TouchSocket.Core.CacheDataHandlingAdapter.m_cacheByteBlock">
            <summary>
            缓存数据，如果需要手动释放，请先判断，然后到调用<see cref="M:System.IDisposable.Dispose"/>后，再置空；
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CacheDataHandlingAdapter.Cache(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将数据缓存起来
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Core.CacheDataHandlingAdapter.Reset">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.CacheDataHandlingAdapter.TryGetCache(System.Byte[]@)">
            <summary>
            获取当前缓存，
            如果缓存超时，或者不存在，均会返回false。
            如果获取成功，则会清空内部缓存。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CacheDataHandlingAdapter.TryGetCache(TouchSocket.Core.ByteBlock@)">
            <summary>
            获取缓存，注意：获取的ByteBlock需要手动释放。
            </summary>
            <param name="byteBlock"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.CustomBetweenAndDataHandlingAdapter`1">
            <summary>
            区间数据包处理适配器，支持以任意字符、字节数组起始与结尾的数据包。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.CustomBetweenAndDataHandlingAdapter`1.StartCode">
            <summary>
            起始字符，不可以为null，可以为0长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.CustomBetweenAndDataHandlingAdapter`1.MinSize">
            <summary>
            即使找到了终止因子，也不会结束，默认0
            </summary>
        </member>
        <member name="P:TouchSocket.Core.CustomBetweenAndDataHandlingAdapter`1.EndCode">
            <summary>
            结束字符，不可以为null，不可以为0长度，必须具有有效值。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CustomBetweenAndDataHandlingAdapter`1.Filter``1(``0@,System.Boolean,`0@,System.Int32@)">
            <summary>
            筛选解析数据。实例化的TRequest会一直保存，直至解析成功，或手动清除。
            <para>当不满足解析条件时，请返回<see cref="F:TouchSocket.Core.FilterResult.Cache"/>，此时会保存<see cref="P:TouchSocket.Core.ByteBlock.CanReadLength"/>的数据</para>
            <para>当数据部分异常时，请移动<see cref="P:TouchSocket.Core.ByteBlock.Position"/>到指定位置，然后返回<see cref="F:TouchSocket.Core.FilterResult.GoOn"/></para>
            <para>当完全满足解析条件时，请返回<see cref="F:TouchSocket.Core.FilterResult.Success"/>最后将<see cref="P:TouchSocket.Core.ByteBlock.Position"/>移至指定位置。</para>
            </summary>
            <param name="byteBlock">字节块</param>
            <param name="beCached">是否为上次遗留对象，当该参数为True时，request也将是上次实例化的对象。</param>
            <param name="request">对象。</param>
            <param name="tempCapacity">缓存容量。当需要首次缓存时，指示申请的ByteBlock的容量。合理的值可避免ByteBlock扩容带来的性能消耗。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CustomBetweenAndDataHandlingAdapter`1.GetInstance">
            <summary>
            获取泛型实例。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IBetweenAndRequestInfo">
            <summary>
            区间类型的适配器数据模型接口。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IBetweenAndRequestInfo.OnParsingStartCode(System.ReadOnlySpan{System.Byte})">
            <summary>
            当解析到起始字符时。
            </summary>
            <param name="startCode"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IBetweenAndRequestInfo.OnParsingBody(System.ReadOnlySpan{System.Byte})">
            <summary>
            当解析数据体。
            <para>在此方法中，您必须手动保存Body内容</para>
            </summary>
            <param name="body"></param>
        </member>
        <member name="M:TouchSocket.Core.IBetweenAndRequestInfo.OnParsingEndCode(System.ReadOnlySpan{System.Byte})">
            <summary>
            当解析到起始字符时。
            </summary>
            <param name="endCode"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.CustomBigFixedHeaderDataHandlingAdapter`1">
            <summary>
            大数据用户自定义固定包头解析器，使用该适配器时，接收方收到的数据中，<see cref="T:TouchSocket.Core.ByteBlock"/>将为null，同时<see cref="T:TouchSocket.Core.IRequestInfo"/>将实现为TFixedHeaderRequestInfo。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.CustomBigFixedHeaderDataHandlingAdapter`1.HeaderLength">
            <summary>
            固定包头的长度。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CustomBigFixedHeaderDataHandlingAdapter`1.Filter``1(``0@,System.Boolean,`0@,System.Int32@)">
            <summary>
            筛选解析数据。实例化的TRequest会一直保存，直至解析成功，或手动清除。
            <para>当不满足解析条件时，请返回<see cref="F:TouchSocket.Core.FilterResult.Cache"/>，此时会保存<see cref="P:TouchSocket.Core.ByteBlock.CanReadLength"/>的数据</para>
            <para>当数据部分异常时，请移动<see cref="P:TouchSocket.Core.ByteBlock.Position"/>到指定位置，然后返回<see cref="F:TouchSocket.Core.FilterResult.GoOn"/></para>
            <para>当完全满足解析条件时，请返回<see cref="F:TouchSocket.Core.FilterResult.Success"/>最后将<see cref="P:TouchSocket.Core.ByteBlock.Position"/>移至指定位置。</para>
            </summary>
            <param name="byteBlock">字节块</param>
            <param name="beCached">是否为上次遗留对象，当该参数为True时，request也将是上次实例化的对象。</param>
            <param name="request">对象。</param>
            <param name="tempCapacity">缓存容量。当需要首次缓存时，指示申请的ByteBlock的容量。合理的值可避免ByteBlock扩容带来的性能消耗。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CustomBigFixedHeaderDataHandlingAdapter`1.GetInstance">
            <summary>
            获取泛型实例。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IBigFixedHeaderRequestInfo">
            <summary>
            用户自定义固定包头请求
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IBigFixedHeaderRequestInfo.BodyLength">
            <summary>
            数据体长度
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IBigFixedHeaderRequestInfo.OnParsingHeader(System.ReadOnlySpan{System.Byte})">
            <summary>
            当收到数据，由框架封送固定协议头。
            <para>您需要在此函数中，解析自己的固定包头，并且对<see cref="P:TouchSocket.Core.IBigFixedHeaderRequestInfo.BodyLength"/>赋值后续数据的长度，然后返回True。</para>
            <para>如果返回false，则意味着放弃本次解析</para>
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IBigFixedHeaderRequestInfo.OnAppendBody(System.ReadOnlySpan{System.Byte})">
            <summary>
            当收到数据，由框架封送数据。
            <para>您需要将有效数据自行保存。该方法可能会多次调用。</para>
            </summary>
            <param name="buffer"></param>
            <returns>是否成功有效</returns>
        </member>
        <member name="M:TouchSocket.Core.IBigFixedHeaderRequestInfo.OnFinished">
            <summary>
            当完成数据接收时调用。
            <para>当返回False时，将不会把该对象向Received传递。</para>
            </summary>
            <returns>是否成功有效</returns>
        </member>
        <member name="T:TouchSocket.Core.CustomBigUnfixedHeaderDataHandlingAdapter`1">
            <summary>
            大数据用户自定义固定包头解析器，使用该适配器时，接收方收到的数据中，<see cref="T:TouchSocket.Core.ByteBlock"/>将为null，同时<see cref="T:TouchSocket.Core.IRequestInfo"/>将实现为TFixedHeaderRequestInfo。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CustomBigUnfixedHeaderDataHandlingAdapter`1.Filter``1(``0@,System.Boolean,`0@,System.Int32@)">
            <summary>
            筛选解析数据。实例化的TRequest会一直保存，直至解析成功，或手动清除。
            <para>当不满足解析条件时，请返回<see cref="F:TouchSocket.Core.FilterResult.Cache"/>，此时会保存<see cref="P:TouchSocket.Core.ByteBlock.CanReadLength"/>的数据</para>
            <para>当数据部分异常时，请移动<see cref="P:TouchSocket.Core.ByteBlock.Position"/>到指定位置，然后返回<see cref="F:TouchSocket.Core.FilterResult.GoOn"/></para>
            <para>当完全满足解析条件时，请返回<see cref="F:TouchSocket.Core.FilterResult.Success"/>最后将<see cref="P:TouchSocket.Core.ByteBlock.Position"/>移至指定位置。</para>
            </summary>
            <param name="byteBlock">字节块</param>
            <param name="beCached">是否为上次遗留对象，当该参数为True时，request也将是上次实例化的对象。</param>
            <param name="request">对象。</param>
            <param name="tempCapacity">缓存容量。当需要首次缓存时，指示申请的ByteBlock的容量。合理的值可避免ByteBlock扩容带来的性能消耗。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CustomBigUnfixedHeaderDataHandlingAdapter`1.GetInstance">
            <summary>
            获取泛型实例。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IBigUnfixedHeaderRequestInfo">
            <summary>
            用户自定义固定包头请求
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IBigUnfixedHeaderRequestInfo.HeaderLength">
            <summary>
            协议头长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IBigUnfixedHeaderRequestInfo.BodyLength">
            <summary>
            数据体长度
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IBigUnfixedHeaderRequestInfo.OnParsingHeader``1(``0@)">
            <summary>
            当收到数据，由框架封送数据，您需要在此函数中，解析自己的数据包头。
            <para>如果满足包头的解析，请返回True，并且递增整个包头的长度到<see cref="P:TouchSocket.Core.ByteBlock.Position"/>，然后赋值<see cref="P:TouchSocket.Core.IBigUnfixedHeaderRequestInfo.BodyLength"/></para>
            <para>如果返回false，意味着缓存剩余数据，此时如果仅仅是因为长度不足，则不必修改其他。</para>
            <para>但是如果是因为数据错误，则需要修改<see cref="P:TouchSocket.Core.ByteBlock.Position"/>到正确位置，如果都不正确，则设置<see cref="P:TouchSocket.Core.ByteBlock.Position"/>等于<see cref="P:TouchSocket.Core.ByteBlock.Length"/></para>
            </summary>
            <param name="byteBlock"></param>
            <returns>是否满足解析包头</returns>
        </member>
        <member name="M:TouchSocket.Core.IBigUnfixedHeaderRequestInfo.OnAppendBody(System.ReadOnlySpan{System.Byte})">
            <summary>
            当收到数据，由框架封送数据。
            <para>您需要将有效数据自行保存。该方法可能会多次调用。</para>
            </summary>
            <param name="buffer"></param>
            <returns>是否成功有效</returns>
        </member>
        <member name="M:TouchSocket.Core.IBigUnfixedHeaderRequestInfo.OnFinished">
            <summary>
            当完成数据接收时调用。
            <para>当返回False时，将不会把该对象向Received传递。</para>
            </summary>
            <returns>是否成功有效</returns>
        </member>
        <member name="T:TouchSocket.Core.CustomDataHandlingAdapter`1">
            <summary>
            用户自定义数据处理适配器，使用该适配器时，接收方收到的数据中，<see cref="T:TouchSocket.Core.ByteBlock"/>将为null，
            同时<see cref="T:TouchSocket.Core.IRequestInfo"/>将实现为TRequest，发送数据直接发送。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CustomDataHandlingAdapter`1.#ctor">
            <summary>
            初始化自定义数据处理适配器。
            </summary>
            <remarks>
            该构造函数在创建<see cref="T:TouchSocket.Core.CustomDataHandlingAdapter`1"/>实例时，会指定请求类型。
            </remarks>
        </member>
        <member name="P:TouchSocket.Core.CustomDataHandlingAdapter`1.CanSendRequestInfo">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.CustomDataHandlingAdapter`1.CanSplicingSend">
            <summary>
            默认不支持拼接发送
            </summary>
        </member>
        <member name="P:TouchSocket.Core.CustomDataHandlingAdapter`1.SurLength">
            <summary>
            指示需要解析当前包的剩余长度。如果不能得知，请赋值<see cref="F:System.Int32.MaxValue"/>。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CustomDataHandlingAdapter`1.TryParseRequest``1(``0@,`0@)">
            <summary>
            尝试解析请求数据块。
            </summary>
            <typeparam name="TByteBlock">字节块类型，必须实现IByteBlock接口。</typeparam>
            <param name="byteBlock">待解析的字节块。</param>
            <param name="request">解析出的请求对象。</param>
            <returns>解析是否成功。</returns>
        </member>
        <member name="M:TouchSocket.Core.CustomDataHandlingAdapter`1.Filter``1(``0@,System.Boolean,`0@,System.Int32@)">
            <summary>
            筛选解析数据。实例化的TRequest会一直保存，直至解析成功，或手动清除。
            <para>当不满足解析条件时，请返回<see cref="F:TouchSocket.Core.FilterResult.Cache"/>，此时会保存<see cref="P:TouchSocket.Core.ByteBlock.CanReadLength"/>的数据</para>
            <para>当数据部分异常时，请移动<see cref="P:TouchSocket.Core.ByteBlock.Position"/>到指定位置，然后返回<see cref="F:TouchSocket.Core.FilterResult.GoOn"/></para>
            <para>当完全满足解析条件时，请返回<see cref="F:TouchSocket.Core.FilterResult.Success"/>最后将<see cref="P:TouchSocket.Core.ByteBlock.Position"/>移至指定位置。</para>
            </summary>
            <param name="byteBlock">字节块</param>
            <param name="beCached">是否为上次遗留对象，当该参数为True时，request也将是上次实例化的对象。</param>
            <param name="request">对象。</param>
            <param name="tempCapacity">缓存容量。当需要首次缓存时，指示申请的ByteBlock的容量。合理的值可避免ByteBlock扩容带来的性能消耗。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CustomDataHandlingAdapter`1.OnReceivedSuccess(`0)">
            <summary>
            成功执行接收以后。
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:TouchSocket.Core.CustomDataHandlingAdapter`1.OnReceivingSuccess(`0)">
            <summary>
            即将执行<see cref="M:TouchSocket.Core.SingleStreamDataHandlingAdapter.GoReceivedAsync(TouchSocket.Core.ByteBlock,TouchSocket.Core.IRequestInfo)"/>。
            </summary>
            <param name="request"></param>
            <returns>返回值标识是否继续执行</returns>
        </member>
        <member name="M:TouchSocket.Core.CustomDataHandlingAdapter`1.PreviewReceivedAsync(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.CustomDataHandlingAdapter`1.Reset">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.CustomDataHandlingAdapter`1.IsBeCached(`0@)">
            <summary>
            判断请求对象是否应该被缓存。
            </summary>
            <param name="request">请求对象。</param>
            <returns>返回布尔值，指示请求对象是否应该被缓存。</returns>
        </member>
        <member name="M:TouchSocket.Core.CustomDataHandlingAdapter`1.Single``1(``0@,`0@)">
            <summary>
            处理单个字节块，提取请求对象。
            </summary>
            <typeparam name="TByteBlock">字节块类型，需要实现IByteBlock接口。</typeparam>
            <param name="byteBlock">字节块，将被解析以提取请求对象。</param>
            <param name="request">输出参数，提取出的请求对象。</param>
            <returns>返回过滤结果，指示处理的状态。</returns>
        </member>
        <member name="T:TouchSocket.Core.CustomFixedHeaderByteBlockDataHandlingAdapter`1">
            <summary>
            用户自定义固定包头内存池解析器，使用该适配器时，接收方收到的数据中，<see cref="T:TouchSocket.Core.ByteBlock"/>将为null，同时<see cref="T:TouchSocket.Core.IRequestInfo"/>将实现为TFixedHeaderRequestInfo。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.CustomFixedHeaderByteBlockDataHandlingAdapter`1.HeaderLength">
            <summary>
            固定包头的长度。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CustomFixedHeaderByteBlockDataHandlingAdapter`1.Filter``1(``0@,System.Boolean,`0@,System.Int32@)">
            <summary>
            筛选解析数据。实例化的TRequest会一直保存，直至解析成功，或手动清除。
            <para>当不满足解析条件时，请返回<see cref="F:TouchSocket.Core.FilterResult.Cache"/>，此时会保存<see cref="P:TouchSocket.Core.ByteBlock.CanReadLength"/>的数据</para>
            <para>当数据部分异常时，请移动<see cref="P:TouchSocket.Core.ByteBlock.Position"/>到指定位置，然后返回<see cref="F:TouchSocket.Core.FilterResult.GoOn"/></para>
            <para>当完全满足解析条件时，请返回<see cref="F:TouchSocket.Core.FilterResult.Success"/>最后将<see cref="P:TouchSocket.Core.ByteBlock.Position"/>移至指定位置。</para>
            </summary>
            <param name="byteBlock">字节块</param>
            <param name="beCached">是否为上次遗留对象，当该参数为True时，request也将是上次实例化的对象。</param>
            <param name="request">对象。</param>
            <param name="tempCapacity">缓存容量。当需要首次缓存时，指示申请的ByteBlock的容量。合理的值可避免ByteBlock扩容带来的性能消耗。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CustomFixedHeaderByteBlockDataHandlingAdapter`1.GetInstance">
            <summary>
            获取泛型实例。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IFixedHeaderByteBlockRequestInfo">
            <summary>
            用户自定义固定包头请求
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IFixedHeaderByteBlockRequestInfo.BodyLength">
            <summary>
            数据体长度
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IFixedHeaderByteBlockRequestInfo.OnParsingHeader(System.ReadOnlySpan{System.Byte})">
            <summary>
            当收到数据，由框架封送固定协议头。
            <para>您需要在此函数中，解析自己的固定包头，并且对<see cref="P:TouchSocket.Core.IFixedHeaderByteBlockRequestInfo.BodyLength"/>赋值后续数据的长度，然后返回True。</para>
            <para>如果返回false，则意味着放弃本次解析</para>
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IFixedHeaderByteBlockRequestInfo.OnParsingBody(TouchSocket.Core.ByteBlock)">
            <summary>
            当收到数据，由框架封送有效载荷数据。
            <para>如果返回false，意味着放弃本次解析的所有数据，包括已经解析完成的Header</para>
            </summary>
            <param name="byteBlock">载荷数据，注意：该字节块生命周期不受框架控制，请一定自行调用Dispose</param>
            <returns>是否成功有效</returns>
        </member>
        <member name="T:TouchSocket.Core.CustomFixedHeaderDataHandlingAdapter`1">
            <summary>
            用户自定义固定包头解析器，使用该适配器时，接收方收到的数据中，<see cref="T:TouchSocket.Core.ByteBlock"/>将为null，同时<see cref="T:TouchSocket.Core.IRequestInfo"/>将实现为TFixedHeaderRequestInfo。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.CustomFixedHeaderDataHandlingAdapter`1.HeaderLength">
            <summary>
            固定包头的长度。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CustomFixedHeaderDataHandlingAdapter`1.Filter``1(``0@,System.Boolean,`0@,System.Int32@)">
            <summary>
            筛选解析数据。实例化的TRequest会一直保存，直至解析成功，或手动清除。
            <para>当不满足解析条件时，请返回<see cref="F:TouchSocket.Core.FilterResult.Cache"/>，此时会保存<see cref="P:TouchSocket.Core.ByteBlock.CanReadLength"/>的数据</para>
            <para>当数据部分异常时，请移动<see cref="P:TouchSocket.Core.ByteBlock.Position"/>到指定位置，然后返回<see cref="F:TouchSocket.Core.FilterResult.GoOn"/></para>
            <para>当完全满足解析条件时，请返回<see cref="F:TouchSocket.Core.FilterResult.Success"/>最后将<see cref="P:TouchSocket.Core.ByteBlock.Position"/>移至指定位置。</para>
            </summary>
            <param name="byteBlock">字节块</param>
            <param name="beCached">是否为上次遗留对象，当该参数为True时，request也将是上次实例化的对象。</param>
            <param name="request">对象。</param>
            <param name="tempCapacity">缓存容量。当需要首次缓存时，指示申请的ByteBlock的容量。合理的值可避免ByteBlock扩容带来的性能消耗。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CustomFixedHeaderDataHandlingAdapter`1.GetInstance">
            <summary>
            获取泛型实例。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IFixedHeaderRequestInfo">
            <summary>
            用户自定义固定包头请求
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IFixedHeaderRequestInfo.BodyLength">
            <summary>
            数据体长度
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IFixedHeaderRequestInfo.OnParsingHeader(System.ReadOnlySpan{System.Byte})">
            <summary>
            当收到数据，由框架封送固定协议头。
            <para>您需要在此函数中，解析自己的固定包头，并且对<see cref="P:TouchSocket.Core.IFixedHeaderRequestInfo.BodyLength"/>赋值后续数据的长度，然后返回True。</para>
            <para>如果返回false，则意味着放弃本次解析</para>
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IFixedHeaderRequestInfo.OnParsingBody(System.ReadOnlySpan{System.Byte})">
            <summary>
            当收到数据，由框架封送有效载荷数据。
            <para>如果返回false，意味着放弃本次解析的所有数据，包括已经解析完成的Header</para>
            </summary>
            <param name="body">载荷数据</param>
            <returns>是否成功有效</returns>
        </member>
        <member name="T:TouchSocket.Core.IUnfixedHeaderRequestInfo">
            <summary>
            用户自定义不固定包头请求
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IUnfixedHeaderRequestInfo.BodyLength">
            <summary>
            数据体长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IUnfixedHeaderRequestInfo.HeaderLength">
            <summary>
            协议头长度
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IUnfixedHeaderRequestInfo.OnParsingBody(System.ReadOnlySpan{System.Byte})">
            <summary>
            当收到数据，由框架封送有效载荷数据。
            <para>如果返回false，意味着放弃本次解析的所有数据，包括已经解析完成的Header</para>
            </summary>
            <param name="body">载荷数据</param>
            <returns>是否成功有效</returns>
        </member>
        <member name="M:TouchSocket.Core.IUnfixedHeaderRequestInfo.OnParsingHeader``1(``0@)">
            <summary>
            当收到数据，由框架封送数据，您需要在此函数中，解析自己的数据包头。
            <para>如果满足包头的解析，请返回True，并且递增整个包头的长度到<see cref="P:TouchSocket.Core.ByteBlock.Position"/>，然后赋值<see cref="P:TouchSocket.Core.IUnfixedHeaderRequestInfo.BodyLength"/></para>
            <para>如果返回false，意味着缓存剩余数据，此时如果仅仅是因为长度不足，则不必修改其他。</para>
            <para>但是如果是因为数据错误，则需要修改<see cref="P:TouchSocket.Core.ByteBlock.Position"/>到正确位置，如果都不正确，则设置<see cref="P:TouchSocket.Core.ByteBlock.Position"/>等于<see cref="P:TouchSocket.Core.ByteBlock.Length"/></para>
            </summary>
            <param name="byteBlock"></param>
            <returns>是否满足解析包头</returns>
        </member>
        <member name="T:TouchSocket.Core.CustomUnfixedHeaderDataHandlingAdapter`1">
            <summary>
            用户自定义固定包头解析器，使用该适配器时，接收方收到的数据中，<see cref="T:TouchSocket.Core.ByteBlock"/>将为null，同时<see cref="T:TouchSocket.Core.IRequestInfo"/>将实现为TUnfixedHeaderRequestInfo。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CustomUnfixedHeaderDataHandlingAdapter`1.Filter``1(``0@,System.Boolean,`0@,System.Int32@)">
            <summary>
            筛选解析数据。实例化的TRequest会一直保存，直至解析成功，或手动清除。
            <para>当不满足解析条件时，请返回<see cref="F:TouchSocket.Core.FilterResult.Cache"/>，此时会保存<see cref="P:TouchSocket.Core.ByteBlock.CanReadLength"/>的数据</para>
            <para>当数据部分异常时，请移动<see cref="P:TouchSocket.Core.ByteBlock.Position"/>到指定位置，然后返回<see cref="F:TouchSocket.Core.FilterResult.GoOn"/></para>
            <para>当完全满足解析条件时，请返回<see cref="F:TouchSocket.Core.FilterResult.Success"/>最后将<see cref="P:TouchSocket.Core.ByteBlock.Position"/>移至指定位置。</para>
            </summary>
            <param name="byteBlock">字节块</param>
            <param name="beCached">是否为上次遗留对象，当该参数为True时，request也将是上次实例化的对象。</param>
            <param name="request">对象。</param>
            <param name="tempCapacity">缓存容量。当需要首次缓存时，指示申请的ByteBlock的容量。合理的值可避免ByteBlock扩容带来的性能消耗。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.CustomUnfixedHeaderDataHandlingAdapter`1.GetInstance">
            <summary>
            获取泛型实例。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.DataHandlingAdapter">
            <summary>
            数据处理适配器
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DataHandlingAdapter.CanSendRequestInfo">
            <summary>
            是否允许发送<see cref="T:TouchSocket.Core.IRequestInfo"/>对象。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DataHandlingAdapter.CanSplicingSend">
            <summary>
            拼接发送
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DataHandlingAdapter.Logger">
            <summary>
            日志记录器。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DataHandlingAdapter.MaxPackageSize">
            <summary>
            获取或设置适配器能接收的最大数据包长度。默认1024*1024 Byte。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DataHandlingAdapter.ThrowIfMoreThanMaxPackageSize(System.Int32)">
            <summary>
            如果指定的长度超过最大包大小，则抛出异常。
            </summary>
            <param name="length">待检查的长度值。</param>
            <remarks>
            此方法用于确保传入的数据长度不会超过预设的最大包大小限制，
            以避免处理过大的数据包导致的性能问题或内存溢出等问题。
            </remarks>
        </member>
        <member name="P:TouchSocket.Core.DataHandlingAdapter.Owner">
            <summary>
            适配器所有者
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DataHandlingAdapter.OnLoaded(System.Object)">
            <summary>
            当适配器在被第一次加载时调用。
            </summary>
            <param name="owner"></param>
            <exception cref="T:System.Exception">此适配器已被其他终端使用，请重新创建对象。</exception>
        </member>
        <member name="M:TouchSocket.Core.DataHandlingAdapter.OnError(System.Exception,System.String,System.Boolean,System.Boolean)">
            <summary>
            在解析时发生错误。
            </summary>
            <param name="ex">异常</param>
            <param name="error">错误异常</param>
            <param name="reset">是否调用<see cref="M:TouchSocket.Core.DataHandlingAdapter.Reset"/></param>
            <param name="log">是否记录日志</param>
        </member>
        <member name="M:TouchSocket.Core.DataHandlingAdapter.Reset">
            <summary>
            重置解析器到初始状态，一般在<see cref="M:TouchSocket.Core.DataHandlingAdapter.OnError(System.Exception,System.String,System.Boolean,System.Boolean)"/>被触发时，由返回值指示是否调用。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.DataHandlingAdapterExtension">
            <summary>
            DateHandleAdapterExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DataHandlingAdapterExtension.Config(TouchSocket.Core.SingleStreamDataHandlingAdapter,TouchSocket.Core.TouchSocketConfig)">
            <summary>
            将<see cref="T:TouchSocket.Core.TouchSocketConfig"/>中的配置，装载在<see cref="T:TouchSocket.Core.SingleStreamDataHandlingAdapter"/>上。
            </summary>
            <param name="adapter"></param>
            <param name="config"></param>
        </member>
        <member name="M:TouchSocket.Core.DataHandlingAdapterExtension.Config(TouchSocket.Core.DataHandlingAdapter,TouchSocket.Core.TouchSocketConfig)">
            <summary>
            将<see cref="T:TouchSocket.Core.TouchSocketConfig"/>中的配置，装载在<see cref="T:TouchSocket.Core.SingleStreamDataHandlingAdapter"/>上。
            </summary>
            <param name="adapter"></param>
            <param name="config"></param>
        </member>
        <member name="F:TouchSocket.Core.DataHandlingAdapterExtension.AdapterOptionProperty">
            <summary>
            设置适配器相关的配置
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DataHandlingAdapterExtension.SetAdapterOption(TouchSocket.Core.TouchSocketConfig,TouchSocket.Core.AdapterOption)">
            <summary>
            设置适配器相关的配置
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DataHandlingAdapterExtension.BuildAsBytes(TouchSocket.Core.IRequestInfoBuilder)">
            <summary>
            将对象构建到字节数组
            </summary>
            <param name="requestInfo"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.FilterResult">
            <summary>
            过滤结果
            </summary>
        </member>
        <member name="F:TouchSocket.Core.FilterResult.Cache">
            <summary>
            缓存后续所有<see cref="P:TouchSocket.Core.ByteBlock.CanReadLength"/>数据。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.FilterResult.Success">
            <summary>
            操作成功
            </summary>
        </member>
        <member name="F:TouchSocket.Core.FilterResult.GoOn">
            <summary>
            继续操作，一般原因是本次数据有部分无效，但已经调整了<see cref="P:TouchSocket.Core.ByteBlock.Position"/>属性，所以继续后续解析。
            <para>或者想放弃当前数据的操作，直接设置<see cref="P:TouchSocket.Core.ByteBlock.Position"/>与<see cref="P:TouchSocket.Core.ByteBlock.Length"/>相等即可。</para>
            </summary>
        </member>
        <member name="T:TouchSocket.Core.FixedHeaderType">
            <summary>
            固定包头类型
            </summary>
        </member>
        <member name="F:TouchSocket.Core.FixedHeaderType.Byte">
            <summary>
            以1Byte标识长度，最长接收<see cref="F:System.Byte.MaxValue"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Core.FixedHeaderType.Ushort">
            <summary>
            以2Byte标识长度，最长接收<see cref="F:System.UInt16.MaxValue"/>
            </summary>
        </member>
        <member name="F:TouchSocket.Core.FixedHeaderType.Int">
            <summary>
            以4Byte标识长度，最长接收<see cref="F:System.Int32.MaxValue"/>
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IRequestInfo">
            <summary>
            请求解析对象接口。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IRequestInfoBuilder">
            <summary>
            指示<see cref="T:TouchSocket.Core.IRequestInfo"/>应当如何构建
            </summary>
        </member>
        <member name="T:TouchSocket.Core.NormalDataHandlingAdapter">
            <summary>
            普通Tcp数据处理器，该适配器不对数据做任何处理。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.NormalDataHandlingAdapter.CanSplicingSend">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.NormalDataHandlingAdapter.CanSendRequestInfo">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.NormalDataHandlingAdapter.PreviewReceivedAsync(TouchSocket.Core.ByteBlock)">
            <summary>
            当接收到数据时处理数据
            </summary>
            <param name="byteBlock">数据流</param>
        </member>
        <member name="M:TouchSocket.Core.NormalDataHandlingAdapter.PreviewSendAsync(System.ReadOnlyMemory{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.NormalDataHandlingAdapter.Reset">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.SingleStreamDataHandlingAdapter">
            <summary>
            单线程状况的流式数据处理适配器。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.SingleStreamDataHandlingAdapter.CacheTimeout">
            <summary>
            缓存超时时间。默认1秒。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.SingleStreamDataHandlingAdapter.CacheTimeoutEnable">
            <summary>
            是否启用缓存超时。默认false。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.SingleStreamDataHandlingAdapter.CanSendRequestInfo">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.SingleStreamDataHandlingAdapter.CanSplicingSend">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.SingleStreamDataHandlingAdapter.ReceivedAsyncCallBack">
            <summary>
            当接收数据处理完成后，回调该函数执行接收
            </summary>
        </member>
        <member name="P:TouchSocket.Core.SingleStreamDataHandlingAdapter.SendAsyncCallBack">
            <summary>
            当发送数据处理完成后，回调该函数执行异步发送
            </summary>
        </member>
        <member name="P:TouchSocket.Core.SingleStreamDataHandlingAdapter.UpdateCacheTimeWhenRev">
            <summary>
            是否在收到数据时，即刷新缓存时间。默认true。
            <list type="number">
            <item>当设为true时，将弱化<see cref="P:TouchSocket.Core.SingleStreamDataHandlingAdapter.CacheTimeout"/>的作用，只要一直有数据，则缓存不会过期。</item>
            <item>当设为false时，则在<see cref="P:TouchSocket.Core.SingleStreamDataHandlingAdapter.CacheTimeout"/>的时效内。必须完成单个缓存的数据。</item>
            </list>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.SingleStreamDataHandlingAdapter.LastCacheTime">
            <summary>
            最后缓存的时间
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataHandlingAdapter.ReceivedInputAsync(TouchSocket.Core.ByteBlock)">
            <summary>
            收到数据的切入点，该方法由框架自动调用。
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataHandlingAdapter.SendInputAsync(TouchSocket.Core.IRequestInfo)">
            <summary>
            发送数据的切入点，该方法由框架自动调用。
            </summary>
            <param name="requestInfo"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataHandlingAdapter.SendInputAsync(System.ReadOnlyMemory{System.Byte})">
            <summary>
            发送数据的切入点，该方法由框架自动调用。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataHandlingAdapter.SendInputAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            发送数据的切入点，该方法由框架自动调用。
            </summary>
            <param name="transferBytes"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataHandlingAdapter.PreviewSendAsync(TouchSocket.Core.IRequestInfo)">
            <summary>
            当发送数据前预先处理数据
            </summary>
            <param name="requestInfo"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataHandlingAdapter.PreviewSendAsync(System.ReadOnlyMemory{System.Byte})">
            <summary>
            当发送数据前预先处理数据
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataHandlingAdapter.PreviewSendAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <summary>
            组合发送预处理数据，
            当属性SplicingSend实现为True时，系统才会调用该方法。
            </summary>
            <param name="transferBytes">代发送数据组合</param>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataHandlingAdapter.Dispose(System.Boolean)">
            <inheritdoc/>
            <param name="disposing"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataHandlingAdapter.GoReceivedAsync(TouchSocket.Core.ByteBlock,TouchSocket.Core.IRequestInfo)">
            <summary>
            处理已经经过预先处理后的数据
            </summary>
            <param name="byteBlock">以二进制形式传递</param>
            <param name="requestInfo">以解析实例传递</param>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataHandlingAdapter.GoSendAsync(System.ReadOnlyMemory{System.Byte})">
            <summary>
            异步发送已经经过预先处理后的数据
            </summary>
            <param name="memory"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataHandlingAdapter.PreviewReceivedAsync(TouchSocket.Core.ByteBlock)">
            <summary>
            当接收到数据后预先处理数据,然后调用<see cref="M:TouchSocket.Core.SingleStreamDataHandlingAdapter.GoReceivedAsync(TouchSocket.Core.ByteBlock,TouchSocket.Core.IRequestInfo)"/>处理数据
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataHandlingAdapter.Reset">
            <summary>
            重置解析器到初始状态，一般在<see cref="M:TouchSocket.Core.DataHandlingAdapter.OnError(System.Exception,System.String,System.Boolean,System.Boolean)"/>被触发时，由返回值指示是否调用。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.SingleStreamDataAdapterTester">
             <summary>
            单线程状况的流式数据处理适配器测试
             </summary>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataAdapterTester.#ctor">
            <summary>
            Tcp数据处理适配器测试
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataAdapterTester.CreateTester(TouchSocket.Core.SingleStreamDataHandlingAdapter,System.Int32,System.Func{TouchSocket.Core.ByteBlock,TouchSocket.Core.IRequestInfo,System.Threading.Tasks.Task})">
            <summary>
            获取测试器
            </summary>
            <param name="adapter">待测试适配器</param>
            <param name="receivedCallBack">收到数据回调</param>
            <param name="bufferLength">缓存数据长度</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataAdapterTester.Run(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            模拟测试运行发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="testCount">测试次数</param>
            <param name="expectedCount">期待测试次数</param>
            <param name="millisecondsTimeout">超时</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataAdapterTester.Run(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            模拟发送
            </summary>
            <param name="buffer"></param>
            <param name="testCount">测试次数</param>
            <param name="expectedCount">期待测试次数</param>
            <param name="millisecondsTimeout">超时</param>
        </member>
        <member name="T:TouchSocket.Core.SingleStreamDataAdapterTester`2">
             <summary>
            单线程状况的流式数据处理适配器测试
             </summary>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataAdapterTester`2.#ctor(`0,System.Int32,System.Action{`1})">
            <summary>
            Tcp数据处理适配器测试
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataAdapterTester`2.Run(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            模拟测试运行发送
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="testCount">测试次数</param>
            <param name="expectedCount">期待测试次数</param>
            <param name="millisecondsTimeout">超时</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SingleStreamDataAdapterTester`2.Run(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            模拟发送
            </summary>
            <param name="buffer"></param>
            <param name="testCount">测试次数</param>
            <param name="expectedCount">期待测试次数</param>
            <param name="millisecondsTimeout">超时</param>
        </member>
        <member name="T:TouchSocket.Core.FixedHeaderPackageAdapter">
            <summary>
            固定包头数据包处理适配器，支持Byte、UShort、Int三种类型作为包头。使用<see cref="P:TouchSocket.Core.TouchSocketBitConverter.DefaultEndianType"/>大小端设置。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FixedHeaderPackageAdapter.CanSendRequestInfo">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.FixedHeaderPackageAdapter.CanSplicingSend">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.FixedHeaderPackageAdapter.FixedHeaderType">
            <summary>
            设置包头类型，默认为int
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FixedHeaderPackageAdapter.MinPackageSize">
            <summary>
            获取或设置包数据的最小值（默认为0）
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FixedHeaderPackageAdapter.PreviewReceivedAsync(TouchSocket.Core.ByteBlock)">
            <summary>
            当接收到数据时处理数据
            </summary>
            <param name="byteBlock">数据流</param>
        </member>
        <member name="M:TouchSocket.Core.FixedHeaderPackageAdapter.PreviewSendAsync(TouchSocket.Core.IRequestInfo)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.FixedHeaderPackageAdapter.PreviewSendAsync(System.ReadOnlyMemory{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.FixedHeaderPackageAdapter.PreviewSendAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.FixedHeaderPackageAdapter.Reset">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.FixedHeaderPackageAdapter.SeamPackage(System.Byte[],System.Int32)">
            <summary>
            缝合包
            </summary>
            <param name="buffer"></param>
            <param name="r"></param>
        </member>
        <member name="M:TouchSocket.Core.FixedHeaderPackageAdapter.SplitPackage(System.Byte[],System.Int32,System.Int32)">
            <summary>
            分解包
            </summary>
            <param name="dataBuffer"></param>
            <param name="index"></param>
            <param name="r"></param>
        </member>
        <member name="T:TouchSocket.Core.FixedSizePackageAdapter">
            <summary>
            固定长度数据包处理适配器。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.FixedSizePackageAdapter.m_surPlusLength">
            <summary>
            包剩余长度
            </summary>
        </member>
        <member name="F:TouchSocket.Core.FixedSizePackageAdapter.m_tempByteBlock">
            <summary>
            临时包
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FixedSizePackageAdapter.#ctor(System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="fixedSize">数据包的长度</param>
        </member>
        <member name="P:TouchSocket.Core.FixedSizePackageAdapter.CanSendRequestInfo">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.FixedSizePackageAdapter.CanSplicingSend">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.FixedSizePackageAdapter.FixedSize">
            <summary>
            获取已设置的数据包的长度
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FixedSizePackageAdapter.PreviewReceivedAsync(TouchSocket.Core.ByteBlock)">
            <summary>
            预处理
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.FixedSizePackageAdapter.PreviewSendAsync(System.ReadOnlyMemory{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.FixedSizePackageAdapter.PreviewSendAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.FixedSizePackageAdapter.Reset">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.PeriodPackageAdapter">
            <summary>
            周期包适配
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PeriodPackageAdapter.PreviewReceivedAsync(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.TerminatorPackageAdapter">
            <summary>
            终止字符数据包处理适配器，支持以任意字符、字节数组结尾的数据包。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TerminatorPackageAdapter.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="terminator"></param>
        </member>
        <member name="M:TouchSocket.Core.TerminatorPackageAdapter.#ctor(System.String,System.Text.Encoding)">
            <summary>
            构造函数
            </summary>
            <param name="terminator"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:TouchSocket.Core.TerminatorPackageAdapter.#ctor(System.Int32,System.Byte[])">
            <summary>
            构造函数
            </summary>
            <param name="minSize"></param>
            <param name="terminatorCode"></param>
        </member>
        <member name="P:TouchSocket.Core.TerminatorPackageAdapter.CanSendRequestInfo">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.TerminatorPackageAdapter.CanSplicingSend">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.TerminatorPackageAdapter.MinSize">
            <summary>
            即使找到了终止因子，也不会结束，默认0
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TerminatorPackageAdapter.ReserveTerminatorCode">
            <summary>
            保留终止因子
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TerminatorPackageAdapter.PreviewReceivedAsync(TouchSocket.Core.ByteBlock)">
            <summary>
            预处理
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.TerminatorPackageAdapter.PreviewSendAsync(System.ReadOnlyMemory{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.TerminatorPackageAdapter.PreviewSendAsync(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.TerminatorPackageAdapter.Reset">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.GZipDataCompressor">
            <summary>
            GZip压缩算法的压缩机
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IDataCompressor">
            <summary>
            数据压缩机接口
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IDataCompressor.Compress(System.ArraySegment{System.Byte})">
            <summary>
            压缩数据
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IDataCompressor.Decompress(System.ArraySegment{System.Byte})">
            <summary>
            解压数据
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.Crc">
            <summary>
            Crc相关。
            <para>该代码来源于网络</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc1(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-4/ITU    x4+x+1
             Poly: 0x03
             Init: 0x00
             Refin: true
             Refout: true
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc2(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-5/EPC    x5+x3+1
             Poly: 0x09
             Init: 0x09
             Refin: false
             Refout: false
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc3(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-5/ITU    x5+x4+x2+1
             Poly: 0x15
             Init: 0x00
             Refin: true
             Refout: true
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc4(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-5/USB    x5+x2+1
             Poly: 0x05
             Init: 0x1F
             Refin: true
             Refout: true
             Xorout: 0x1F
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc5(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-6/ITU    x6+x+1
             Poly: 0x03
             Init: 0x00
             Refin: true
             Refout: true
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc6(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-7/MMC    x7+x3+1
             Poly: 0x09
             Init: 0x00
             Refin: false
             Refout: false
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc7(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC8    x8+x2+x+1
             Poly: 0x07
             Init: 0x00
             Refin: false
             Refout: false
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc8(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-8/ITU    x8+x2+x+1
             Poly: 0x07
             Init: 0x00
             Refin: false
             Refout: false
             Xorout: 0x55
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc9(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-8/MAXIM    x8+x5+x4+1
             Poly: 0x31
             Init: 0x00
             Refin: true
             Refout: true
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc10(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-8/ROHC    x8+x2+x+1
             Poly: 0x07
             Init: 0xFF
             Refin: true
             Refout: true
             Xorout: 0x00
            *************************************************************************
        </member>
        <member name="F:TouchSocket.Core.Crc.table">
            Z1协议校验码计算
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc11(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Crc11
            </summary>
            <param name="buffer"></param>
            <param name="start"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc12(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-12    x16+x12+x5+1
             Poly: 0x80
             Init: 0x0000
             Refin: true
             Refout: true
             Xorout: 0x0000
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc13(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/CCITT    x16+x12+x5+1
             Poly: 0x1021
             Init: 0x0000
             Refin: true
             Refout: true
             Xorout: 0x0000
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc14(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/CCITT FALSE    x16+x12+x5+1
             Poly: 0x1021
             Init: 0xFFFF
             Refin: false
             Refout: false
             Xorout: 0x0000
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc15(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/DNP    x16+x13+x12+x11+x10+x8+x6+x5+x2+1
             Poly: 0x3D65
             Init: 0x0000
             Refin: true
             Refout: true
             Xorout: 0xFFFF
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.WriteCrc16(System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            计算并写入CRC16校验和
            </summary>
            <param name="storeSpan">用于存储CRC16校验和的目标字节序列</param>
            <param name="span">用于计算CRC16校验和的源字节序列</param>
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc16(System.ReadOnlySpan{System.Byte})">
             **********************************************************************
             Name: CRC-16/IBM    x16+x15+x2+1
             Poly: 0x8005
             Init: 0x0000
             Refin: true
             Refout: true
             Xorout: 0x0000
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc16Value(System.ReadOnlySpan{System.Byte})">
            <summary>
            计算给定字节序列的CRC-16校验值。
            </summary>
            <param name="span">要计算CRC-16校验值的字节序列。</param>
            <returns>计算得到的CRC-16校验值。</returns>
            <exception cref="T:System.ArgumentNullException">如果提供的字节序列为空，则抛出ArgumentNullException。</exception>
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc17(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/MAXIM    x16+x15+x2+1
             Poly: 0x8005
             Init: 0x0000
             Refin: true
             Refout: true
             Xorout: 0xFFFF
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc18(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/MODBUS    x16+x15+x2+1
             Poly: 0x8005
             Init: 0xFFFF
             Refin: true
             Refout: true
             Xorout: 0x0000
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc19(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/USB    x16+x15+x2+1
             Poly: 0x8005
             Init: 0xFFFF
             Refin: true
             Refout: true
             Xorout: 0xFFFF
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc20(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/X25    x16+x12+x5+1
             Poly: 0x1021
             Init: 0xFFFF
             Refin: true
             Refout: true
             Xorout: 0xFFFF
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc21(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC-16/XMODEM    x16+x12+x5+1
             Poly: 0x1021
             Init: 0x0000
             Refin: false
             Refout: false
             Xorout: 0x0000
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc22(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC32    x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1
             Poly: 0x04C11DB7
             Init: 0xFFFFFFFF
             Refin: true
             Refout: true
             Xorout: 0xFFFFFFFF
            *************************************************************************
        </member>
        <member name="M:TouchSocket.Core.Crc.Crc23(System.Byte[],System.Int32,System.Int32)">
             **********************************************************************
             Name: CRC32/MPEG-2    x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1
             Poly: 0x04C11DB7
             Init: 0xFFFFFFFF
             Refin: false
             Refout: false
             Xorout: 0x00000000
            *************************************************************************
        </member>
        <member name="T:TouchSocket.Core.GZip">
            <summary>
            Gzip操作类
            </summary>
        </member>
        <member name="M:TouchSocket.Core.GZip.Compress(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            压缩数据
            </summary>
            <param name="stream"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.GZip.Compress(System.IO.Stream,System.Byte[])">
            <summary>
            压缩数据
            </summary>
            <param name="stream"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.GZip.Compress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            压缩数据
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.GZip.Compress(System.Byte[])">
            <summary>
            压缩数据
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.GZip.Decompress``1(``0@,System.Byte[],System.Int32,System.Int32)">
            <summary>
            解压数据
            </summary>
            <param name="byteBlock"></param>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.GZip.Decompress``1(``0@,System.Byte[])">
            <summary>
            解压数据
            </summary>
            <param name="byteBlock"></param>
            <param name="data"></param>
        </member>
        <member name="M:TouchSocket.Core.GZip.Decompress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            解压数据
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.GZip.Decompress(System.Byte[])">
            <summary>
            解压数据
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.MD5">
            <summary>
            MD5相关操作类
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MD5.GetMD5Hash(System.String)">
            <summary>
            从字符串获取MD5值
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MD5.GetMD5Hash(System.IO.Stream)">
            <summary>
            从流中获取MD5值。
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MD5.GetMD5Hash(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从字节获取MD5值
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MD5.GetMD5Hash(System.Byte[])">
            <summary>
            从字节获取MD5值
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.MD5.VerifyMD5Hash(System.String,System.String)">
            <summary>
            验证MD5值。
            </summary>
            <param name="str"></param>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.DataSecurity">
            <summary>
            数据安全加密
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DataSecurity.Keys">
            <summary>
            自定义加密密钥。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DataSecurity.EncryptDES(System.Byte[],System.String)">
            <summary>
            使用3DES加密
            </summary>
            <param name="data">待加密字节</param>
            <param name="encryptKey">加密口令（长度为8）</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DataSecurity.DecryptDES(System.Byte[],System.String)">
            <summary>
            使用3DES解密
            </summary>
            <param name="data">待解密字节</param>
            <param name="encryptKey">解密口令（长度为8）</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DataSecurity.StreamEncryptDES(System.IO.Stream,System.IO.Stream,System.String)">
            <summary>
            使用3DES流数据加密。
            <para>注意：数据会从<see cref="P:System.IO.Stream.Position"/>开始</para>
            </summary>
            <param name="inStream"></param>
            <param name="outStream"></param>
            <param name="encryptKey">加密口令（长度为8）</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DataSecurity.StreamDecryptDES(System.IO.Stream,System.IO.Stream,System.String)">
            <summary>
            使用3DES流数据解密
            <para>注意：数据会从<see cref="P:System.IO.Stream.Position"/>开始</para>
            </summary>
            <param name="inStream"></param>
            <param name="outStream"></param>
            <param name="encryptKey">解密口令（长度为8）</param>
        </member>
        <member name="T:TouchSocket.Core.Swap">
            <summary>
            交换类。功能类似：a=1，b=2，交换后a=2，b=1。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Swap.Execute``1(``0@,``0@)">
            <summary>
            执行交换
            </summary>
            <typeparam name="T"></typeparam>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="T:TouchSocket.Core.DataValidationAttribute">
            <summary>
            依赖属性数据验证
            </summary>
        </member>
        <member name="T:TouchSocket.Core.DependencyDescriptor">
            <summary>
            注入依赖对象
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyDescriptor.#ctor(System.Type,System.Object)">
            <summary>
            初始化一个单例实例。
            </summary>
            <param name="fromType">要从该类型创建实例的类型。</param>
            <param name="instance">创建的单例实例。</param>
        </member>
        <member name="M:TouchSocket.Core.DependencyDescriptor.#ctor(System.Type,System.Type,TouchSocket.Core.Lifetime)">
            <summary>
            初始化一个完整的服务注册
            </summary>
            <param name="fromType">要注册的服务的类型</param>
            <param name="toType">服务在容器中实际使用的类型</param>
            <param name="lifetime">服务的生命周期</param>
        </member>
        <member name="M:TouchSocket.Core.DependencyDescriptor.#ctor(System.Type)">
            <summary>
            初始化一个简单的服务描述
            </summary>
            <param name="fromType">指定服务的类型</param>
        </member>
        <member name="P:TouchSocket.Core.DependencyDescriptor.FromType">
            <summary>
            注册类型
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyDescriptor.ImplementationFactory">
            <summary>
            实例化工厂委托
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyDescriptor.Lifetime">
            <summary>
            生命周期
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyDescriptor.OnResolved">
            <summary>
            在获取到注册时触发委托。
            <para>
            在单例实例注册时，不会触发。在单例注册时，只会触发一次，在瞬态注册时，会每次都触发。
            </para>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyDescriptor.ToInstance">
            <summary>
            实例
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyDescriptor.ToType">
            <summary>
            实例类型
            </summary>
        </member>
        <member name="T:TouchSocket.Core.DependencyObject">
            <summary>
            依赖项对象. 线程安全。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyObject.GetValue``1(TouchSocket.Core.DependencyProperty{``0})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.DependencyObject.HasValue``1(TouchSocket.Core.DependencyProperty{``0})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.DependencyObject.RemoveValue``1(TouchSocket.Core.DependencyProperty{``0})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.DependencyObject.SetValue``1(TouchSocket.Core.DependencyProperty{``0},``0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.DependencyObject.TryGetValue``1(TouchSocket.Core.DependencyProperty{``0},``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.DependencyObject.TryRemoveValue``1(TouchSocket.Core.DependencyProperty{``0},``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.DependencyObject.CloneTo(TouchSocket.Core.DependencyObject,System.Boolean)">
            <summary>
            将当前对象的依赖项克隆到目标对象中
            </summary>
            <param name="dependencyObject">目标对象</param>
            <param name="overwrite">当目标对象中存在相同依赖项时，是或否覆盖</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.DependencyObject.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.DependencyProperty`1">
            <summary>
            依赖属性
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DependencyProperty`1.m_name">
            <summary>
            属性名称
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyProperty`1.#ctor(System.String,System.Func{TouchSocket.Core.IDependencyObject,`0},System.Boolean)">
            <summary>
            初始化依赖属性。
            </summary>
            <param name="propertyName">属性名称</param>
            <param name="onFailedToGetTheValue">当<see cref="T:TouchSocket.Core.IDependencyObject"/>获取属性失败时，回调该函数</param>
            <param name="placeholder">占位重载，无实际意义</param>
        </member>
        <member name="M:TouchSocket.Core.DependencyProperty`1.#ctor(System.String,`0)">
            <summary>
            初始化依赖属性。
            </summary>
            <param name="propertyName">属性名称</param>
            <param name="defaultValue">当<see cref="T:TouchSocket.Core.IDependencyObject"/>获取属性失败时，回调函数将直接返回默认值。</param>
        </member>
        <member name="P:TouchSocket.Core.DependencyProperty`1.Name">
            <summary>
            属性名称
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyProperty`1.OnFailedToGetTheValue">
            <summary>
            当<see cref="T:TouchSocket.Core.IDependencyObject"/>获取属性失败时，回调该函数
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyProperty`1.op_Inequality(TouchSocket.Core.DependencyProperty{`0},TouchSocket.Core.DependencyProperty{`0})">
            <summary>
            判断否
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DependencyProperty`1.op_Equality(TouchSocket.Core.DependencyProperty{`0},TouchSocket.Core.DependencyProperty{`0})">
            <summary>
            判断是
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DependencyProperty`1.Register(System.String,`0)">
            <summary>
            注册依赖项属性。
            <para>依赖属性的默认值，可能会应用于所有的<see cref="T:TouchSocket.Core.IDependencyObject"/></para>
            </summary>
            <param name="propertyName"></param>
            <param name="value">依赖项属性值，一般该值应该是值类型，因为它可能会被用于多个依赖对象。</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DependencyProperty`1.Equals(TouchSocket.Core.DependencyProperty{`0})">
            <inheritdoc/>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DependencyProperty`1.Equals(System.Object)">
            <inheritdoc/>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DependencyProperty`1.GetHashCode">
            <inheritdoc/>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.DependencyPropertyBase">
            <summary>
            提供依赖属性(DependencyProperty)的基础实现。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DependencyPropertyBase.s_idCount">
            <summary>
            用于生成依赖属性标识的唯一ID。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DependencyPropertyBase.#ctor">
            <summary>
            初始化依赖属性对象，为每个属性分配唯一的ID。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DependencyPropertyBase.Id">
            <summary>
            标识属性的唯一ID。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IDependencyObject">
            <summary>
            依赖对象接口
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IDependencyObject.GetValue``1(TouchSocket.Core.DependencyProperty{``0})">
            <summary>
            获取依赖注入的值，当没有注入时，会返回默认行为的值。
            </summary>
            <typeparam name="TValue">值的类型</typeparam>
            <param name="dp">依赖属性</param>
            <returns>依赖注入的值</returns>
        </member>
        <member name="M:TouchSocket.Core.IDependencyObject.HasValue``1(TouchSocket.Core.DependencyProperty{``0})">
            <summary>
            判断在当前对象中是否有已设置的属性值。
            </summary>
            <param name="dp">依赖属性</param>
            <returns>是否有已设置的值</returns>
        </member>
        <member name="M:TouchSocket.Core.IDependencyObject.RemoveValue``1(TouchSocket.Core.DependencyProperty{``0})">
            <summary>
            移除属性值。
            </summary>
            <typeparam name="TValue">值的类型</typeparam>
            <param name="dp">依赖属性</param>
        </member>
        <member name="M:TouchSocket.Core.IDependencyObject.SetValue``1(TouchSocket.Core.DependencyProperty{``0},``0)">
            <summary>
            设置依赖注入的值，如果值已经存在，将被覆盖。
            </summary>
            <param name="dp">依赖属性</param>
            <param name="value">要设置的值</param>
        </member>
        <member name="M:TouchSocket.Core.IDependencyObject.TryGetValue``1(TouchSocket.Core.DependencyProperty{``0},``0@)">
            <summary>
            尝试获取依赖注入的值，当没有注入时，会返回<see langword="false"/>。
            </summary>
            <typeparam name="TValue">值的类型</typeparam>
            <param name="dp">依赖属性</param>
            <param name="value">获取到的值</param>
            <returns>是否成功获取到值</returns>
        </member>
        <member name="M:TouchSocket.Core.IDependencyObject.TryRemoveValue``1(TouchSocket.Core.DependencyProperty{``0},``0@)">
            <summary>
            尝试重置属性值，如果没有这个值，则返回<see langword="false"/>。
            </summary>
            <typeparam name="TValue">值的类型</typeparam>
            <param name="dp">依赖属性</param>
            <param name="value">被移除的值</param>
            <returns>是否成功重置值</returns>
        </member>
        <member name="T:TouchSocket.Core.TimeMeasurer">
            <summary>
            时间测量器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TimeMeasurer.Run(System.Action)">
            <summary>
            开始运行
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TimeMeasurer.Run(System.Func{System.Threading.Tasks.Task})">
            <summary>
            开始运行
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TimeMeasurer.RunAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            开始运行
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.DisposableObject">
            <summary>
            具有释放的对象。内部实现了<see cref="M:System.GC.SuppressFinalize(System.Object)"/>，但不包括析构函数相关。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.DisposableObject.m_disposedValue">
            <summary>
            判断是否已释放。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DisposableObject.DisposedValue">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.DisposableObject.ThrowIfDisposed">
            <summary>
            判断当前对象是否已经被释放。
            如果已经被释放，则抛出ObjectDisposedException异常。
            </summary>
            <exception cref="T:System.ObjectDisposedException">当对象已经被释放时抛出此异常</exception>
        </member>
        <member name="M:TouchSocket.Core.DisposableObject.Dispose(System.Boolean)">
            <summary>
            处置资源
            </summary>
            <param name="disposing">一个值，表示是否释放托管资源</param>
        </member>
        <member name="M:TouchSocket.Core.DisposableObject.Dispose">
            <summary>
            释放资源。内部已经处理了<see cref="M:System.GC.SuppressFinalize(System.Object)"/>
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IDisposableObject">
            <summary>
            具有释放的对象，包含一个<see cref="P:TouchSocket.Core.IDisposableObject.DisposedValue"/>来标识是否该对象已被释放。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IDisposableObject.DisposedValue">
            <summary>
            标识该对象是否已被释放
            </summary>
        </member>
        <member name="T:TouchSocket.Core.SafetyDisposableObject">
            <summary>
            线程安全的释放模型。无论是<see cref="T:System.IDisposable"/>还是<see cref="T:System.GC"/>执行，都只会触发1次<see cref="M:TouchSocket.Core.SafetyDisposableObject.SafetyDispose(System.Boolean)"/>方法。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SafetyDisposableObject.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.SafetyDisposableObject.SafetyDispose(System.Boolean)">
            <summary>
            线程安全模式的释放，无论是<see cref="T:System.IDisposable"/>还是<see cref="T:System.GC"/>执行，都只会触发一次
            </summary>
        </member>
        <member name="T:TouchSocket.Core.PluginEventHandler`2">
            <summary>
            插件泛型基础事件委托
            </summary>
            <typeparam name="TClient">客户端类型，表示事件发生的上下文环境</typeparam>
            <typeparam name="TEventArgs">事件参数类型，必须继承自PluginEventArgs</typeparam>
            <param name="client">触发事件的客户端实例</param>
            <param name="e">包含事件数据的事件参数</param>
        </member>
        <member name="T:TouchSocket.Core.TouchSocketEventHandler`2">
            <summary>
            TouchSocket基础泛型事件委托
            </summary>
            <typeparam name="TClient">触发事件的客户端类型</typeparam>
            <typeparam name="TEventArgs">事件参数类型</typeparam>
            <param name="client">触发事件的客户端实例</param>
            <param name="e">事件参数</param>
        </member>
        <member name="T:TouchSocket.Core.MsgEventArgs">
            <summary>
            消息事件参数类，继承自PluginEventArgs。
            该类用于封装消息相关的数据，在事件处理过程中传递。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MsgEventArgs.#ctor(System.String)">
            <summary>
            初始化MsgEventArgs类的新实例，指定消息内容。
            </summary>
            <param name="mes">要传递的消息字符串。</param>
        </member>
        <member name="M:TouchSocket.Core.MsgEventArgs.#ctor">
            <summary>
            初始化MsgEventArgs类的空实例。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MsgEventArgs.Message">
            <summary>
            获取或设置消息文本。
            该属性用于存储和检索事件期间的消息内容。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.MsgPermitEventArgs">
            <summary>
            MsgPermitEventArgs 类继承自 PermitEventArgs 类，用于封装消息许可的事件参数
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MsgPermitEventArgs.#ctor(System.String)">
            <summary>
            初始化 MsgPermitEventArgs 类的新实例，包含消息内容
            </summary>
            <param name="mes">要处理的消息</param>
        </member>
        <member name="M:TouchSocket.Core.MsgPermitEventArgs.#ctor">
            <summary>
            初始化 MsgPermitEventArgs 类的新实例，不带初始消息内容
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MsgPermitEventArgs.Message">
            <summary>
            获取或设置此许可事件关联的消息
            </summary>
        </member>
        <member name="T:TouchSocket.Core.PermitEventArgs">
            <summary>
            具有操作许可的事件参数类
            </summary>
        </member>
        <member name="P:TouchSocket.Core.PermitEventArgs.IsPermitOperation">
            <summary>
            是否允许操作
            </summary>
        </member>
        <member name="T:TouchSocket.Core.TouchSocketEventArgs">
            <summary>
            定义TouchSocketEventArgs类，继承自EventArgs，用于处理TouchSocket相关的事件
            </summary>
        </member>
        <member name="P:TouchSocket.Core.TouchSocketEventArgs.Handled">
            <summary>
            是否已处理
            </summary>
        </member>
        <member name="T:TouchSocket.Core.MessageNotFoundException">
            <summary>
            未找到消息异常类
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MessageNotFoundException.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="mes">异常消息</param>
        </member>
        <member name="T:TouchSocket.Core.MessageRegisteredException">
            <summary>
            消息已注册
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MessageRegisteredException.#ctor(System.String)">
             <summary>
            构造函数
             </summary>
             <param name="mes"></param>
        </member>
        <member name="T:TouchSocket.Core.OverlengthException">
            <summary>
            超长异常
            </summary>
        </member>
        <member name="M:TouchSocket.Core.OverlengthException.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Core.OverlengthException.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:TouchSocket.Core.OverlengthException.#ctor(System.String,System.Exception)">
            <summary>
            构造函数
            </summary>
            <param name="message"></param>
            <param name="inner"></param>
        </member>
        <member name="T:TouchSocket.Core.UnknownErrorException">
            <summary>
            未知错误异常类，继承自Exception，用于处理未知类型的错误。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.UnknownErrorException.#ctor">
            <summary>
            默认构造函数，当不指定错误消息时，默认使用资源文件中定义的未知错误消息。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.UnknownErrorException.#ctor(System.String)">
            <summary>
            构造函数，允许指定自定义的错误消息。
            </summary>
            <param name="message">发生的未知错误的详细信息。</param>
        </member>
        <member name="T:TouchSocket.Core.CollectionsExtension">
            <summary>
            CollectionsExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.CollectionsExtension.RemoveWhen``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,``1},System.Boolean})">
            <summary>
            移除满足条件的项目。
            </summary>
            <typeparam name="TKey">字典中键的类型。</typeparam>
            <typeparam name="TValue">字典中值的类型。</typeparam>
            <param name="pairs">要处理的并发字典。</param>
            <param name="func">用于判断项目是否应被移除的函数。</param>
            <returns>返回移除的项目数量。</returns>
        </member>
        <member name="M:TouchSocket.Core.CollectionsExtension.TryAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>
            尝试向字典中添加键值对。
            </summary>
            <typeparam name="TKey">键的类型。</typeparam>
            <typeparam name="TValue">值的类型。</typeparam>
            <param name="dictionary">要添加键值对的字典。</param>
            <param name="key">要添加的键。</param>
            <param name="value">要添加的值。</param>
            <returns>如果添加成功则返回true，否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Core.CollectionsExtension.AddOrUpdate``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>
            向字典中添加或更新指定键的值。
            </summary>
            <param name="dictionary">要操作的字典。</param>
            <param name="key">要添加或更新的键。</param>
            <param name="value">与键关联的值。</param>
            <typeparam name="TKey">字典中键的类型。</typeparam>
            <typeparam name="TValue">字典中值的类型。</typeparam>
        </member>
        <member name="M:TouchSocket.Core.CollectionsExtension.AddOrUpdate``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0,``1)">
            <summary>
            向 ConcurrentDictionary 中添加键值对，如果键已存在，则更新其值。
            </summary>
            <param name="dictionary">要操作的 ConcurrentDictionary。</param>
            <param name="key">键，用于在字典中查找。</param>
            <param name="value">值，要添加到字典中或更新已存在的项。</param>
            <typeparam name="TKey">键的类型。</typeparam>
            <typeparam name="TValue">值的类型。</typeparam>
        </member>
        <member name="M:TouchSocket.Core.CollectionsExtension.GetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            获取字典中与指定键关联的值。
            </summary>
            <param name="dictionary">要搜索的字典。</param>
            <param name="key">要查找的键。</param>
            <typeparam name="TKey">键的类型。</typeparam>
            <typeparam name="TValue">值的类型。</typeparam>
            <returns>如果找到了与指定键关联的值，则返回该值；否则返回该类型的默认值。</returns>
        </member>
        <member name="M:TouchSocket.Core.CollectionsExtension.Clear``1(System.Collections.Concurrent.ConcurrentQueue{``0})">
            <summary>
            清空并发队列中的所有元素。
            </summary>
            <typeparam name="T">队列中元素的类型。</typeparam>
            <param name="queue">要清空的并发队列。</param>
        </member>
        <member name="M:TouchSocket.Core.CollectionsExtension.Clear``1(System.Collections.Concurrent.ConcurrentQueue{``0},System.Action{``0})">
            <summary>
            清空并发队列并执行指定操作。
            </summary>
            <typeparam name="T">队列元素的类型。</typeparam>
            <param name="queue">要清空的并发队列。</param>
            <param name="action">在每个队列元素上执行的操作。</param>
        </member>
        <member name="M:TouchSocket.Core.CollectionsExtension.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            循环遍历每个元素，执行Action动作
            </summary>
            <typeparam name="T"></typeparam>
            <param name="values">要遍历的集合</param>
            <param name="action">对每个元素执行的动作</param>
            <returns>返回原始集合</returns>
        </member>
        <member name="M:TouchSocket.Core.CollectionsExtension.ForEachAsync``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            循环遍历每个元素，执行异步动作
            </summary>
            <typeparam name="T"></typeparam>
            <param name="values">要遍历的集合</param>
            <param name="func">对每个元素执行的异步操作</param>
            <returns>返回原始集合</returns>
        </member>
        <member name="T:TouchSocket.Core.ReflectionExtension">
            <summary>
            反射工具类
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ReflectionExtension.GetDeterminantName(System.Reflection.MethodInfo)">
            <summary>
            获取方法的确定性名称，即使在重载时，也能区分。
            <para>计算规则是：命名空间.类名.方法名(参数：全名)</para>
            </summary>
            <param name="methodInfo"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ReflectionExtension.GetName(System.Reflection.MethodInfo)">
            <summary>
            获取方法的方法名。主要解决显式实现时函数名称的问题。
            </summary>
            <param name="methodInfo"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ReflectionExtension.GetTupleElementNames(System.Reflection.ParameterInfo)">
            <summary>
            获取元组的名称列表。
            </summary>
            <param name="parameter"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ReflectionExtension.IsNullableType(System.Reflection.PropertyInfo)">
            <summary>
            判断该类型是否为可空类型
            </summary>
            <param name="propertyInfo"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ReflectionExtension.GetTupleElementNames(System.Reflection.MemberInfo)">
            <summary>
            获取元组的名称列表。
            </summary>
            <param name="memberInfo"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ReflectionExtension.IsNullableType(System.Reflection.FieldInfo)">
            <summary>
            判断该类型是否为可空类型
            </summary>
            <param name="fieldInfo"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ReflectionExtension.CanPublicWrite(System.Reflection.PropertyInfo)">
            <summary>
            检查属性是否可以公开写入
            </summary>
            <param name="propertyInfo">要检查的属性信息</param>
            <returns>如果属性可以公开写入则返回true，否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Core.ReflectionExtension.CanPublicRead(System.Reflection.PropertyInfo)">
            <summary>
            判断属性是否可以公共读取
            </summary>
            <param name="propertyInfo">要检查的属性信息</param>
            <returns>如果属性可以公共读取，则为 true；否则为 false</returns>
        </member>
        <member name="T:TouchSocket.Core.StringExtension">
            <summary>
            StringExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.IsNullOrEmpty(System.String)">
            <summary>
            检查字符串是否为空或只包含空格。
            </summary>
            <param name="str">要检查的字符串。</param>
            <returns>如果字符串为空或只包含空格，则返回 true；否则返回 false。</returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.IsNullOrWhiteSpace(System.String)">
            <summary>
            检查字符串是否为 null 或仅包含空白字符。
            </summary>
            <param name="str">要检查的字符串。</param>
            <returns>如果字符串为 null 或仅包含空白字符，则返回 true；否则返回 false。</returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.HasValue(System.String)">
            <summary>
            检查字符串是否具有有效值。
            </summary>
            <param name="str">要检查的字符串。</param>
            <returns>如果字符串不是null且非空格或制表符等，则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.TryParseToType(System.String,System.Type,System.Object@)">
            <summary>
             将字符串格式化成指定的基本数据类型
            </summary>
            <param name="value">待解析的字符串</param>
            <param name="destinationType">目标数据类型</param>
             <param name="returnValue">解析后的值，输出参数</param>
               <returns>如果解析成功返回true，否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.HitStringCount(System.String,System.String)">
            <summary>
            判断字符串compare 在 input字符串中出现的次数
            </summary>
            <param name="input">源字符串</param>
            <param name="compare">用于比较的字符串</param>
            <returns>字符串compare 在 input字符串中出现的次数</returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.ParseToType(System.String,System.Type)">
            <summary>
            将字符转换为对应的基础类型类型。
            </summary>
            <param name="value"></param>
            <param name="destinationType">目标类型必须为基础类型</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.SplitFirst(System.String,System.Char)">
            <summary>
            只按第一个匹配项分割
            </summary>
            <param name="str"></param>
            <param name="split"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.Split(System.String,System.String)">
            <summary>
            按字符串分割
            </summary>
            <param name="str"></param>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.SplitLast(System.String,System.Char)">
            <summary>
            只按最后一个匹配项分割
            </summary>
            <param name="str"></param>
            <param name="split"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.Format(System.String,System.Object[])">
            <summary>
            按格式填充
            </summary>
            <param name="str"></param>
            <param name="ps"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.ToSha1(System.String,System.Text.Encoding)">
            <summary>
            转换为SHA1。
            </summary>
            <param name="value"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.ToUTF8Bytes(System.String)">
            <summary>
            转换为UTF-8数据，效果等于<see cref="P:System.Text.Encoding.UTF8"/>
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.ByHexStringToBytes(System.String,System.String)">
            <summary>
            将16进制的字符转换为数组。
            </summary>
            <param name="hexString"></param>
            <param name="split"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.ByHexStringToInt32(System.String)">
            <summary>
            将16进制的字符转换为int32。
            </summary>
            <param name="hexString"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringExtension.ByBase64ToBytes(System.String)">
            <summary>
            从Base64转到数组。
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.SystemExtension">
            <summary>
            为System提供扩展。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.SafeDispose(System.IDisposable)">
            <summary>
            安全性释放（不用判断对象是否为空）。不会抛出任何异常。
            </summary>
            <param name="dis"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.SafeDispose(TouchSocket.Core.IDisposableObject)">
            <summary>
            安全性释放（不用判断对象是否为空）。不会抛出任何异常。
            <para>
            内部会判断<see cref="P:TouchSocket.Core.IDisposableObject.DisposedValue"/>的值，如果为<see langword="true"/>，则不会再执行<see cref="M:System.IDisposable.Dispose"/>。
            </para>
            </summary>
            <param name="disposableObject"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.GetAttribute``1(System.Enum)">
            <summary>
            获取枚举成员上绑定的指定类型的自定义属性
            </summary>
            <param name="enumObj">枚举对象</param>
            <typeparam name="T">要获取的属性类型</typeparam>
            <returns>指定类型的自定义属性</returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.SetBit(System.UInt64,System.Int32,System.Boolean)">
            <summary>
            对于给定的无符号长整型数值，设置指定索引位置的位值为指定的布尔值。
            </summary>
            <param name="b">原始数值。</param>
            <param name="index">位索引，范围为0到63。</param>
            <param name="bitvalue">要设置的位值（true为1，false为0）。</param>
            <returns>修改后的数值。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">当索引值不在有效范围内时抛出异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.SetBit(System.UInt32,System.Int32,System.Boolean)">
            <summary>
            对于给定的无符号整型数值，设置指定索引位置的位值为指定的布尔值。
            </summary>
            <param name="b">原始数值。</param>
            <param name="index">位索引，范围为0到31。</param>
            <param name="bitvalue">要设置的位值（true为1，false为0）。</param>
            <returns>修改后的数值。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">当索引值不在有效范围内时抛出异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.SetBit(System.UInt16,System.Int32,System.Boolean)">
            <summary>
            对于给定的无符号短整型数值，设置指定索引位置的位值为指定的布尔值。
            </summary>
            <param name="b">原始数值。</param>
            <param name="index">位索引，范围为0到15。</param>
            <param name="bitvalue">要设置的位值（true为1，false为0）。</param>
            <returns>修改后的数值。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">当索引值不在有效范围内时抛出异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.SetBit(System.Byte,System.Int32,System.Boolean)">
            <summary>
            对于给定的无符号字节型数值，设置指定索引位置的位值为指定的布尔值。
            </summary>
            <param name="b">原始数值。</param>
            <param name="index">位索引，范围为0到7。</param>
            <param name="bitvalue">要设置的位值（true为1，false为0）。</param>
            <returns>修改后的数值。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">当索引值不在有效范围内时抛出异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.GetBit(System.UInt64,System.Int32)">
            <summary>
            获取无符号长整型数值中的指定位置的位是否为1。
            </summary>
            <param name="b">要检查的无符号长整型数值。</param>
            <param name="index">要检查的位的位置，从0到63。</param>
            <returns>如果指定位置的位为1，则返回true；否则返回false。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">当索引值不在0到63之间时，抛出此异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.GetBit(System.UInt32,System.Int32)">
            <summary>
            获取无符号整型数值中的指定位置的位是否为1。
            </summary>
            <param name="b">要检查的无符号整型数值。</param>
            <param name="index">要检查的位的位置，从0到31。</param>
            <returns>如果指定位置的位为1，则返回true；否则返回false。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">当索引值不在0到31之间时，抛出此异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.GetBit(System.UInt16,System.Int32)">
            <summary>
            获取无符号短整型数值中的指定位置的位是否为1。
            </summary>
            <param name="b">要检查的无符号短整型数值。</param>
            <param name="index">要检查的位的位置，从0到15。</param>
            <returns>如果指定位置的位为1，则返回true；否则返回false。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">当索引值不在0到15之间时，抛出此异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.GetBit(System.Byte,System.Int32)">
            <summary>
            获取字节型数值中的指定位置的位是否为1。
            </summary>
            <param name="b">要检查的字节型数值。</param>
            <param name="index">要检查的位的位置，从0到7。</param>
            <returns>如果指定位置的位为1，则返回true；否则返回false。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">当索引值不在0到7之间时，抛出此异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.ByBytesToHexString(System.Byte[],System.Int32,System.Int32,System.String)">
            <summary>
            字节数组转16进制字符
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="split"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.ByBytesToHexString(System.Byte[],System.String)">
            <summary>
            将字节缓冲区转换为十六进制字符串。
            </summary>
            <param name="buffer">要转换的字节缓冲区。</param>
            <param name="split">可选参数，用于指定分隔符，默认为空。</param>
            <returns>转换后的十六进制字符串。</returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IndexOfFirst(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            索引第一个包含数组的索引位置，例如：在{0,1,2,3,1,2,3}中索引{2,3}，则返回3。
            <para>如果目标数组为null或长度为0，则直接返回offset的值</para>
            </summary>
            <param name="srcByteArray"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="subByteArray"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IndexOfFirst(System.ReadOnlySpan{System.Byte},System.Int32,System.Int32,System.Byte[])">
            <summary>
            索引第一个包含数组的索引位置，例如：在{0,1,2,3,1,2,3}中索引{2,3}，则返回3。
            <para>如果目标数组为null或长度为0，则直接返回offset的值</para>
            </summary>
            <param name="srcByteArray"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="subByteArray"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IndexOfInclude(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            索引包含数组。
            <para>
            例如：在{0,1,2,3,1,2,3}中搜索{1,2}，则会返回list:[2,5]，均为最后索引的位置。
            </para>
            </summary>
            <param name="srcByteArray"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="subByteArray"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IndexOfInclude(System.ReadOnlySpan{System.Byte},System.Int32,System.Int32,System.Byte[])">
            <summary>
            索引包含数组。
            <para>
            例如：在{0,1,2,3,1,2,3}中搜索{1,2}，则会返回list:[2,5]，均为最后索引的位置。
            </para>
            </summary>
            <param name="srcByteArray"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="subByteArray"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.ToBase64(System.Byte[])">
            <summary>
            转Base64。
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.ToUtf8String(System.Byte[])">
            <summary>
            将字节数组转换为UTF-8编码的字符串。
            </summary>
            <param name="data">要转换的字节数组。</param>
            <returns>转换后的UTF-8编码字符串。</returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.ToUtf8String(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将字节数组的一部分转换为UTF-8编码的字符串。
            </summary>
            <param name="data">要转换的字节数组。</param>
            <param name="offset">数组中开始转换的索引位置。</param>
            <param name="length">要转换的字节数。</param>
            <returns>转换后的UTF-8编码字符串。</returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.GetDefault(System.Type)">
            <summary>
            获取默认值
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.GetRefOutType(System.Type)">
            <summary>
            获取类型
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IsAnonymous(System.Type)">
            <summary>
            检查类型是否是匿名类型
            </summary>
            <param name="type"><see cref="T:System.Type"/></param>
            <returns><see cref="T:System.Boolean"/></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IsDecimal(System.Type)">
            <summary>
            检查类型是否是小数类型
            </summary>
            <param name="type"><see cref="T:System.Type"/></param>
            <returns><see cref="T:System.Boolean"/></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IsDictionary(System.Type)">
            <summary>
            检查类型是否是字典类型
            </summary>
            <param name="type"><see cref="T:System.Type"/></param>
            <returns><see cref="T:System.Boolean"/></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IsInstantiable(System.Type)">
            <summary>
            检查类型是否可实例化
            </summary>
            <param name="type"><see cref="T:System.Type"/></param>
            <returns><see cref="T:System.Boolean"/></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IsInteger(System.Type)">
            <summary>
            检查类型是否是整数类型
            </summary>
            <param name="type"><see cref="T:System.Type"/></param>
            <returns><see cref="T:System.Boolean"/></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IsList(System.Type)">
            <summary>
            是否是<see cref="T:System.Collections.Generic.List`1"/>类型。
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IsNullableType(System.Type)">
            <summary>
            判断该类型是否为可空类型
            </summary>
            <param name="theType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IsNumeric(System.Type)">
            <summary>
            检查类型是否是数值类型
            </summary>
            <param name="type"><see cref="T:System.Type"/></param>
            <returns><see cref="T:System.Boolean"/></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IsStatic(System.Type)">
            <summary>
            判断是否为静态类。
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IsStruct(System.Type)">
            <summary>
            判断为结构体
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.IsValueTuple(System.Type)">
            <summary>
            判断该类型是否为值元组类型
            </summary>
            <param name="theType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.GetArray(System.Memory{System.Byte})">
            <summary>
            从指定的 <see cref="T:System.Memory`1"/> 对象中获取内部数组。
            </summary>
            <param name="memory">要获取内部数组的内存对象。</param>
            <returns>一个表示内存内部数组的 <see cref="T:System.ArraySegment`1"/> 对象。</returns>
            <remarks>
            此方法通过将 <see cref="T:System.Memory`1"/> 对象转换为 <see cref="T:System.ReadOnlyMemory`1"/> 对象，
            然后调用 <see cref="M:TouchSocket.Core.SystemExtension.GetArray(System.ReadOnlyMemory{System.Byte})"/> 方法来获取内部数组。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.GetArray(System.ReadOnlyMemory{System.Byte})">
            <summary>
            从指定的 <see cref="T:System.ReadOnlyMemory`1"/> 对象中获取内部数组。
            </summary>
            <param name="memory">要获取内部数组的只读内存对象。</param>
            <returns>一个表示内存内部数组的 <see cref="T:System.ArraySegment`1"/> 对象。</returns>
            <remarks>
            此方法尝试通过 <see cref="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)"/> 方法获取内存的内部数组。
            如果成功，直接返回结果；如果失败（即内存不是由数组支持的），则将内存复制到数组并返回该数组的段。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.GetIP(System.Net.EndPoint)">
            <summary>
            从<see cref="T:System.Net.EndPoint"/>中获得IP地址。
            </summary>
            <param name="endPoint"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.GetPort(System.Net.EndPoint)">
            <summary>
            从<see cref="T:System.Net.EndPoint"/>中获得Port。
            </summary>
            <param name="endPoint"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.ToString(System.Span{System.Byte},System.Text.Encoding)">
            <summary>
            将字节的连续内存表示形式转换为字符串。
            </summary>
            <param name="span">要转换为字符串的字节范围。</param>
            <param name="encoding">用于解码字节的编码。</param>
            <returns>转换后的字符串。</returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.ToString(System.ReadOnlySpan{System.Byte},System.Text.Encoding)">
            <summary>
            将只读的字节连续内存表示形式转换为字符串。
            </summary>
            <param name="span">要转换为字符串的只读字节范围。</param>
            <param name="encoding">用于解码字节的编码。</param>
            <returns>转换后的字符串。</returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.ToGMTString(System.DateTime)">
            <summary>
            将DateTime对象转换为GMT格式的字符串。
            </summary>
            <param name="dt">要转换的DateTime对象。</param>
            <returns>转换后的GMT格式字符串。</returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.ToUnsignedMillis(System.DateTime@)">
            <summary>
            将DateTime对象转换为自1970年1月1日以来的毫秒数的32位无符号整数表示。
            </summary>
            <param name="time">要转换的DateTime对象。</param>
            <returns>自1970年1月1日以来的毫秒数的32位无符号整数。</returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.ToUnsignedMillis(System.DateTimeOffset@)">
            <summary>
            将DateTimeOffset对象转换为自1970年1月1日以来的毫秒数的32位无符号整数表示。
            </summary>
            <param name="time">要转换的DateTimeOffset对象。</param>
            <returns>自1970年1月1日以来的毫秒数的32位无符号整数。</returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.ReadAsync(System.IO.Stream,System.Memory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            异步读取数据到指定的内存区域。
            </summary>
            <param name="stream">要读取数据的流。</param>
            <param name="memory">要读取数据到的内存区域。</param>
            <param name="cancellationToken">用于取消操作的令牌。</param>
            <returns>读取到的数据长度。</returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.Read(System.IO.Stream,System.Span{System.Byte})">
            <summary>
            从流中读取数据到指定的字节跨度。
            </summary>
            <param name="stream">要读取数据的流。</param>
            <param name="span">要读取数据到的字节跨度。</param>
            <returns>读取到的数据长度。</returns>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.WriteAsync(System.IO.Stream,System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            异步地将只读内存块中的字节内容写入流中，并支持取消操作。
            </summary>
            <param name="stream">此方法扩展的流对象，表示要写入的流。</param>
            <param name="memory">只读内存块，其中包含要写入的字节数据。</param>
            <param name="token">用于取消异步写入操作的取消令牌。</param>
            <remarks>
            此方法利用内存块的 GetArray 方法获取数组段信息，然后使用现有的 WriteAsync 方法异步地将内容写入流中，提高了写入操作的效率和灵活性。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.SystemExtension.Write(System.IO.Stream,System.ReadOnlySpan{System.Byte})">
            <summary>
            使用缓冲区高效地将只读字节跨度写入流。
            </summary>
            <param name="stream">要写入的流。</param>
            <param name="span">要写入流的只读字节跨度。</param>
            <remarks>
            该方法通过使用字节池来优化内存分配和释放，减少内存分配的开销。
            </remarks>
        </member>
        <member name="T:TouchSocket.Core.SystemThreadingExtension">
            <summary>
            SystemThreadingExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SystemThreadingExtension.CreateReadLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            创建一个可释放的读取锁
            </summary>
            <param name="lockSlim"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemThreadingExtension.CreateWriteLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            创建一个可释放的写入锁
            </summary>
            <param name="lockSlim"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemThreadingExtension.WaitTime(System.Threading.SemaphoreSlim,System.Int32,System.Threading.CancellationToken)">
            <summary>
            使用指定的超时和取消令牌等待信号量。
            </summary>
            <param name="semaphoreSlim">要等待的信号量。</param>
            <param name="millisecondsTimeout">等待的超时时间（以毫秒为单位）。</param>
            <param name="token">用于取消操作的取消令牌。</param>
            <remarks>
            如果信号量未在指定的超时时间内释放，则抛出超时异常。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.SystemThreadingExtension.WaitTimeAsync(System.Threading.SemaphoreSlim,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步等待信号量，具有指定的超时和取消令牌。
            </summary>
            <param name="semaphoreSlim">要等待的信号量。</param>
            <param name="millisecondsTimeout">等待的超时时间（以毫秒为单位）。</param>
            <param name="token">用于取消操作的取消令牌。</param>
            <returns>一个Task对象，表示异步等待操作。</returns>
            <remarks>
            如果信号量未在指定的超时时间内释放，则抛出超时异常。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.SystemThreadingExtension.GetFalseAwaitResult``1(System.Threading.Tasks.Task{``0})">
            <summary>
            同步获取配置ConfigureAwait为false时的结果。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemThreadingExtension.GetFalseAwaitResult(System.Threading.Tasks.Task)">
            <summary>
            同步配置ConfigureAwait为false时的执行。
            </summary>
            <param name="task"></param>
        </member>
        <member name="M:TouchSocket.Core.SystemThreadingExtension.ConfigureFalseAwait``1(System.Threading.Tasks.Task{``0})">
            <summary>
            配置ConfigureAwait为false。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SystemThreadingExtension.ConfigureFalseAwait(System.Threading.Tasks.Task)">
            <summary>
            配置ConfigureAwait为false。
            </summary>
            <param name="task"></param>
        </member>
        <member name="M:TouchSocket.Core.SystemThreadingExtension.WaitAsync``1(System.Threading.Tasks.Task{``0},System.TimeSpan)">
            <summary>
            异步等待指定最大时间
            </summary>
            <typeparam name="TResult">任务完成后的结果类型</typeparam>
            <param name="task">需要等待完成的任务</param>
            <param name="millisecondsTimeout">最大等待时间（毫秒）</param>
            <returns>如果在指定时间内完成，则返回任务结果；否则返回默认值</returns>
            <exception cref="T:System.TimeoutException">如果任务超时未完成，则抛出超时异常</exception>
        </member>
        <member name="M:TouchSocket.Core.SystemThreadingExtension.WaitAsync(System.Threading.Tasks.Task,System.TimeSpan)">
            <summary>
            异步等待指定最大时间
            </summary>
            <param name="task">要等待完成的任务</param>
            <param name="millisecondsTimeout">最大等待时间，以毫秒为单位</param>
            <exception cref="T:System.TimeoutException">当等待超时时抛出</exception>
            <remarks>
            此方法允许调用者指定一个最大等待时间，如果指定时间内任务未能完成，将抛出超时异常。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.SystemThreadingExtension.FireAndForget(System.Threading.Tasks.Task)">
            <summary>
            启动一个任务并立即返回，任务执行过程中发生的异常不会导致程序崩溃。
            </summary>
            <param name="task">要启动的异步任务。</param>
        </member>
        <member name="T:TouchSocket.Core.XElementExtension">
            <summary>
            扩展XElement类，为其添加属性操作相关的方法。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.XElementExtension.AddAttribute(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Object)">
            <summary>
            向指定的XElement元素添加一个属性。
            </summary>
            <param name="element">要添加属性的XElement对象。</param>
            <param name="name">要添加的属性的名称。</param>
            <param name="value">要添加的属性的值。</param>
            <remarks>
            此方法简化了向XElement对象添加属性的流程。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.XElementExtension.GetAttributeValue``1(System.Xml.Linq.XElement,System.Xml.Linq.XName,``0)">
            <summary>
            获取指定名称的属性值，如果属性不存在或值为空，则返回默认值。
            </summary>
            <typeparam name="T">属性值的类型，必须是值类型。</typeparam>
            <param name="xmlNode">要获取属性值的XElement对象。</param>
            <param name="name">属性的名称。</param>
            <param name="defaultValue">如果属性不存在或值为空时返回的默认值。</param>
            <returns>属性值或默认值。</returns>
        </member>
        <member name="M:TouchSocket.Core.XElementExtension.GetAttributeValue``1(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            获取指定名称的属性值，如果属性不存在，则返回默认值。
            </summary>
            <typeparam name="T">属性值的类型，必须是值类型。</typeparam>
            <param name="xmlNode">要获取属性值的XElement对象。</param>
            <param name="name">属性的名称。</param>
            <returns>属性值或默认值。</returns>
            <remarks>
            此方法重载了GetAttributeValue方法，用于在未指定默认值的情况下获取属性值。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.XElementExtension.GetAttributeValue(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            获取指定名称的属性值。
            </summary>
            <param name="xmlNode">要获取属性值的XElement对象。</param>
            <param name="name">属性的名称。</param>
            <returns>属性值，如果属性不存在则返回null。</returns>
        </member>
        <member name="M:TouchSocket.Core.XElementExtension.GetAttributeValue(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.String)">
            <summary>
            获取指定名称的属性值，如果属性不存在，则返回默认值。
            </summary>
            <param name="xmlNode">要获取属性值的XElement对象。</param>
            <param name="name">属性的名称。</param>
            <param name="defaultValue">如果属性不存在时返回的默认值。</param>
            <returns>属性值或默认值。</returns>
        </member>
        <member name="T:TouchSocket.Core.Counter">
            <summary>
            计数器
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Counter.m_count">
            <summary>
            周期内的累计计数值。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Counter.m_lastIncrement">
            <summary>
            最后一次递增时间
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Counter.Count">
            <summary>
            周期内的累计计数值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Counter.LastIncrement">
            <summary>
            最后一次递增时间
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Counter.OnPeriod">
            <summary>
            当达到一个周期时触发。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Counter.Period">
            <summary>
            计数周期。默认1秒。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Counter.Increment(System.Int64)">
            <summary>
            累计增加计数
            </summary>
            <param name="value">要增加的值</param>
            <returns>返回值表示当前递增的是否在一个新的周期内。</returns>
        </member>
        <member name="M:TouchSocket.Core.Counter.Increment">
            <summary>
            累计增加一个计数
            </summary>
            <returns>返回是否成功增加计数</returns>
        </member>
        <member name="M:TouchSocket.Core.Counter.Reset">
            <summary>
            重置<see cref="P:TouchSocket.Core.Counter.Count"/>和<see cref="P:TouchSocket.Core.Counter.LastIncrement"/>
            </summary>
        </member>
        <member name="T:TouchSocket.Core.FlowGate">
            <summary>
            流量控制器。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FlowGate.Maximum">
            <summary>
            最大值
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FlowGate.MaximumWaitTime">
            <summary>
            最长休眠周期。默认为5s.
            <para>当设置为5s时，假如设置的<see cref="P:TouchSocket.Core.FlowGate.Maximum"/>=10，而一次递增了100，则理应会休眠10s，但是会休眠5s。反之，如果设置1，则每秒周期都会清空。</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FlowGate.AddCheckWait(System.Int64)">
            <summary>
            检测等待
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FlowGate.AddCheckWaitAsync(System.Int64)">
            <summary>
            异步添加并检查等待
            </summary>
            <param name="increment">要增加的值</param>
            <returns>任务延迟后的异步结果</returns>
            <remarks>
            该方法主要用于限流，通过增加内部计数器并检查是否超过最大值，
            如果超过，则根据设定的周期计算需要等待的时间，以Task.Delay的形式实现等待。
            </remarks>
        </member>
        <member name="T:TouchSocket.Core.ValueCounter">
            <summary>
            值类型计数器。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ValueCounter.m_count">
            <summary>
            周期内的累计计数值。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ValueCounter.m_lastIncrement">
            <summary>
            最后一次递增时间
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueCounter.Count">
            <summary>
            周期内的累计计数值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueCounter.LastIncrement">
            <summary>
            最后一次递增时间
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueCounter.OnPeriod">
            <summary>
            当达到一个周期时触发。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueCounter.Period">
            <summary>
            计数周期。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueCounter.Increment(System.Int64)">
            <summary>
            累计增加计数
            </summary>
            <param name="value">要增加的值</param>
            <returns>返回值表示当前递增的是否在一个新的周期内。</returns>
        </member>
        <member name="M:TouchSocket.Core.ValueCounter.Increment">
            <summary>
            累计增加一个计数
            </summary>
            <returns>返回是否成功增加计数</returns>
        </member>
        <member name="M:TouchSocket.Core.ValueCounter.Reset">
            <summary>
            重置<see cref="P:TouchSocket.Core.ValueCounter.Count"/>和<see cref="P:TouchSocket.Core.ValueCounter.LastIncrement"/>
            </summary>
        </member>
        <member name="T:TouchSocket.Core.BlockSegment`1">
            <summary>
            表示一个块段，用于异步操作中作为值任务的源，提供 <see cref="T:TouchSocket.Core.IBlockResult`1"/> 类型的结果。
            </summary>
            <typeparam name="T">块段中元素的类型。</typeparam>
        </member>
        <member name="P:TouchSocket.Core.BlockSegment`1.Result">
            <summary>
            获取当前块段的结果。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BlockSegment`1.#ctor">
            <summary>
            初始化BlockSegment类的新实例。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BlockSegment`1.Reset">
            <summary>
            重置块段的状态，为下一次使用做准备。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BlockSegment`1.Scheduler(System.Action{System.Object},System.Object)">
            <summary>
            调度执行指定操作。
            </summary>
            <param name="action">要执行的操作。</param>
            <param name="state">操作的状态信息。</param>
        </member>
        <member name="M:TouchSocket.Core.BlockSegment`1.GetResult">
            <summary>
            获取当前块段的结果。
            </summary>
            <returns>块段的结果。</returns>
        </member>
        <member name="M:TouchSocket.Core.BlockSegment`1.InputAsync(System.ReadOnlyMemory{`0})">
            <summary>
            异步地输入数据到块段中。
            </summary>
            <param name="memory">要输入的数据内存。</param>
        </member>
        <member name="M:TouchSocket.Core.BlockSegment`1.Complete(System.String)">
            <summary>
            标记块段为完成，并可选地提供完成消息。
            </summary>
            <param name="msg">完成消息。</param>
        </member>
        <member name="M:TouchSocket.Core.BlockSegment`1.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.BlockSegment`1.BlockResult.#ctor(System.Action)">
            <summary>
            ReceiverResult
            </summary>
            <param name="disAction"></param>
        </member>
        <member name="T:TouchSocket.Core.VAction">
            <summary>
            控制台行为
            </summary>
        </member>
        <member name="M:TouchSocket.Core.VAction.#ctor(System.String,System.String,System.Func{System.Threading.Tasks.Task})">
            <summary>
            构造函数
            </summary>
            <param name="action"></param>
            <param name="description"></param>
            <param name="fullOrder"></param>
        </member>
        <member name="T:TouchSocket.Core.ConsoleAction">
            <summary>
            控制台行为
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConsoleAction.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="helpOrder">帮助信息指令，如："h|help|?"</param>
        </member>
        <member name="E:TouchSocket.Core.ConsoleAction.OnException">
            <summary>
            执行异常
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConsoleAction.HelpOrder">
            <summary>
            帮助信息指令
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConsoleAction.Add(System.String,System.String,System.Action)">
            <summary>
            添加
            </summary>
            <param name="order">指令，多个指令用“|”分割</param>
            <param name="description">描述</param>
            <param name="action"></param>
        </member>
        <member name="M:TouchSocket.Core.ConsoleAction.Add(System.String,System.String,System.Func{System.Threading.Tasks.Task})">
            <summary>
            添加
            </summary>
            <param name="order">指令，多个指令用“|”分割</param>
            <param name="description">描述</param>
            <param name="action"></param>
        </member>
        <member name="M:TouchSocket.Core.ConsoleAction.RunAsync(System.String)">
            <summary>
            执行，返回值仅表示是否有这个指令，异常获取请使用<see cref="E:TouchSocket.Core.ConsoleAction.OnException"/>
            </summary>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ConsoleAction.RunCommandLineAsync">
            <summary>
            运行
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConsoleAction.ShowAll">
            <summary>
            显示所有注册指令
            </summary>
        </member>
        <member name="T:TouchSocket.Core.DirectoryUtility">
            <summary>
            DirectoryUtility
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DirectoryUtility.CopyDirectory(System.String,System.String)">
            <summary>
            复制文件夹及文件
            </summary>
            <param name="sourceFolder">原文件路径</param>
            <param name="destFolder">目标文件路径</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.DirectoryUtility.GetDirectories(System.String)">
            <summary>
            获取文件夹下的一级文件夹目录名称，不含子文件夹。
            </summary>
            <param name="sourceFolder"></param>
        </member>
        <member name="T:TouchSocket.Core.FilePool">
            <summary>
            文件池。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetAllPaths">
            <summary>
            获取所有的路径。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetFileStorageForRead(System.String)">
            <summary>
            加载文件为读取流
            </summary>
            <param name="path"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetFileStorageForRead(System.IO.FileInfo)">
            <summary>
            加载文件为读取流
            </summary>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetFileStorageForWrite(System.String)">
            <summary>
            加载文件为写流
            </summary>
            <param name="path"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetFileStorageForWrite(System.IO.FileInfo)">
            <summary>
            加载文件为写流
            </summary>
            <param name="fileInfo"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetFileStorageStream(System.String)">
            <summary>
            获取一个可读可写的Stream对象。
            </summary>
            <param name="path"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetFileStorageStream(System.IO.FileInfo)">
            <summary>
            获取一个可读可写的Stream对象。
            </summary>
            <param name="fileInfo"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetReader(System.String)">
            <summary>
            获取一个文件读取访问器
            </summary>
            <param name="path"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetReader(System.IO.FileInfo)">
            <summary>
            获取一个文件读取访问器
            </summary>
            <param name="fileInfo"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetReferenceCount(System.String)">
            <summary>
            获取引用次数。
            </summary>
            <param name="path">必须是全路径。</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetWriter(System.String)">
            <summary>
            获取一个文件写入访问器
            </summary>
            <param name="path">路径</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.GetWriter(System.IO.FileInfo)">
            <summary>
            获取一个文件写入访问器
            </summary>
            <param name="fileInfo"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FilePool.TryReleaseFile(System.String,System.Int32)">
            <summary>
            减少引用次数，并尝试释放流。
            </summary>
            <param name="path"></param>
            <param name="delayTime">延迟释放时间。当设置为0时，立即释放,单位毫秒。</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:TouchSocket.Core.FileStorage">
            <summary>
            文件存储器。在该存储器中，读写线程安全。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorage.#ctor(System.IO.FileInfo,System.IO.FileAccess)">
            <summary>
            初始化一个文件存储器。在该存储器中，读写线程安全。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.AccessTime">
            <summary>
            最后访问时间。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.AccessTimeout">
            <summary>
            访问超时时间。默认60s
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.FileAccess">
            <summary>
            访问属性
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.FileInfo">
            <summary>
            文件信息
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.FileStream">
            <summary>
            文件流。
            一般情况下，请不要直接访问该对象。否则有可能会产生不可预测的错误。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.Length">
            <summary>
            文件长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.Path">
            <summary>
            文件路径
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorage.Reference">
            <summary>
            引用次数。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorage.Flush">
            <summary>
            写入时清空缓存区
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorage.Read(System.Int64,System.Span{System.Byte})">
            <summary>
            从当前文件中读取字节。
            </summary>
            <param name="startPos">开始读取的位置。</param>
            <param name="span">用于接收读取数据的字节跨度。</param>
            <returns>实际读取的字节数。</returns>
            <exception cref="T:System.ObjectDisposedException">如果当前对象已被处置。</exception>
            <exception cref="T:System.IO.IOException">如果文件仅被写入。</exception>
        </member>
        <member name="M:TouchSocket.Core.FileStorage.TryReleaseFile(System.Int32)">
            <summary>
            减少引用次数，并尝试释放流。
            </summary>
            <param name="delayTime">延迟释放时间。当设置为0时，立即释放,单位毫秒。</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Core.FileStorage.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <summary>
            写入数据到文件的特定位置。
            </summary>
            <param name="startPos">开始写入的位置。</param>
            <param name="span">要写入的字节跨度。</param>
        </member>
        <member name="T:TouchSocket.Core.FileStorageReader">
            <summary>
            文件读取器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorageReader.#ctor(TouchSocket.Core.FileStorage)">
            <summary>
            初始化FileStorageReader实例。
            </summary>
            <param name="fileStorage">文件存储对象，用于处理文件读取操作。</param>
            <remarks>
            此构造函数接收一个FileStorage对象作为参数，用于后续的文件读取操作。
            如果传入的FileStorage对象为null，则抛出ArgumentNullException异常，
            这确保了文件读取操作不会在不合法的参数状态下执行，提高了代码的健壮性。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.FileStorageReader.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageReader.FileStorage">
            <summary>
            文件存储器
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageReader.Position">
            <summary>
            游标位置
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorageReader.Read(System.Span{System.Byte})">
            <summary>
            从文件存储中读取字节到指定的字节跨度。
            </summary>
            <param name="span">要读取数据的字节跨度。</param>
            <returns>实际读取到的字节数。</returns>
        </member>
        <member name="M:TouchSocket.Core.FileStorageReader.SafetyDispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.FileStorageStream">
            <summary>
            FileStorageStream。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.#ctor(TouchSocket.Core.FileStorage)">
            <summary>
            构造函数
            </summary>
            <param name="fileStorage"></param>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageStream.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.FileStorageStream.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.FileStorageStream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.FileStorageStream.FileStorage">
            <summary>
            文件存储器
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageStream.Length">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.FileStorageStream.Position">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.Flush">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.FileStorageStream.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.FileStorageWriter">
            <summary>
            文件写入器。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorageWriter.#ctor(TouchSocket.Core.FileStorage)">
            <summary>
            初始化FileStorageWriter的实例。
            </summary>
            <param name="fileStorage">文件存储服务的实例，用于后续的文件写入操作。</param>
        </member>
        <member name="M:TouchSocket.Core.FileStorageWriter.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageWriter.FileStorage">
            <summary>
            文件存储器
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileStorageWriter.Position">
            <summary>
            游标位置
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileStorageWriter.SeekToEnd">
            <summary>
            将文件指针移动到文件末尾。
            </summary>
            <returns>返回文件末尾的位置。</returns>
        </member>
        <member name="M:TouchSocket.Core.FileStorageWriter.Write(System.ReadOnlySpan{System.Byte})">
            <summary>
            将一组只读字节写入文件存储。
            </summary>
            <param name="span">要写入的只读字节范围。</param>
        </member>
        <member name="M:TouchSocket.Core.FileStorageWriter.SafetyDispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.FileUtility">
            <summary>
            文件操作
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetDuplicateFileName(System.String)">
            <summary>
            获取不重复文件名。
            <para>例如：New.txt已存在时，会返回New(1).txt</para>
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetDuplicateDirectoryName(System.String)">
            <summary>
            获取不重复文件夹名称.
            <para>例如：NewDir已存在时，会返回NewDir(1)</para>
            </summary>
            <param name="dirName"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.ToFileLengthString(System.Int64)">
            <summary>
            转化为文件大小的字符串，类似10B，10Kb，10Mb，10Gb。
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetFileMD5(System.String)">
            <summary>
            获取文件MD5
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetStreamMD5(System.IO.Stream)">
            <summary>
            获取流MD5
            </summary>
            <param name="fileStream"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetFileHash256(System.String)">
            <summary>
            获得文件Hash值
            </summary>
            <param name="filePath">文件路径</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetStreamHash256(System.IO.Stream)">
            <summary>
            获得流Hash值
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetFileHash(System.String,System.Security.Cryptography.HashAlgorithm)">
            <summary>
            获得文件Hash值
            </summary>
            <param name="filePath">文件路径</param>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetStreamHash(System.IO.Stream,System.Security.Cryptography.HashAlgorithm)">
            <summary>
            获得流Hash值
            </summary>
            <param name="stream"></param>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetIncludeFileNames(System.String)">
            <summary>
            获取仅当前文件夹中包含的文件名称，不含全路径。
            </summary>
            <param name="dirPath"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.GetRelativePath(System.String,System.String)">
            <summary>
            获取相对路径。
            </summary>
            <param name="relativeTo"></param>
            <param name="path"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.Delete(System.String)">
            <summary>
            删除路径文件
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.PathFormat(System.String)">
            <summary>
            路径格式化。
            </summary>
            <remarks>
            此操作会把路径中的所有反斜杠替换为正斜杠。例如：C:\\a.txt替换为C:/a.txt
            </remarks>
            <param name="pathString"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FileUtility.IsDirectory(System.String)">
            <summary>
            判断该路径是否为文件夹
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IBlockResult`1">
            <summary>
            定义了一个泛型接口，用于表示一块不可变内存的处理结果。
            </summary>
            <typeparam name="T">内存中元素的类型。</typeparam>
        </member>
        <member name="P:TouchSocket.Core.IBlockResult`1.Memory">
            <summary>
            获取只读内存块。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IBlockResult`1.IsCompleted">
            <summary>
            获取表示内存处理是否完成的布尔值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IBlockResult`1.Message">
            <summary>
            获取处理结果的消息。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.WrapStream">
            <summary>
            包装的流。为避免该流释放时，内部流也会被释放的问题
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.#ctor(System.IO.Stream)">
            <summary>
            包装的流。为避免该流释放时，内部流也会被释放的问题
            </summary>
            <param name="stream"></param>
        </member>
        <member name="P:TouchSocket.Core.WrapStream.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.WrapStream.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.WrapStream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.WrapStream.Length">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.WrapStream.Position">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.Flush">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.SetLength(System.Int64)">
            <inheritdoc/>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.Close">
            <summary>
            没有关闭效果
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WrapStream.Dispose(System.Boolean)">
            <summary>
            没有释放效果
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:TouchSocket.Core.ConsoleLogger">
            <summary>
            控制台日志记录器
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ConsoleLogger.Default">
            <summary>
            默认的实例
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ConsoleLogger.WriteLog(TouchSocket.Core.LogLevel,System.Object,System.String,System.Exception)">
            <inheritdoc/>
            <param name="logLevel"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="T:TouchSocket.Core.EasyLogger">
            <summary>
            一个简单的委托日志
            </summary>
        </member>
        <member name="M:TouchSocket.Core.EasyLogger.#ctor(System.Action{TouchSocket.Core.LogLevel,System.Object,System.String,System.Exception})">
            <summary>
            一个简单的委托日志
            </summary>
            <param name="action">参数依次为：日志类型，触发源，消息，异常</param>
        </member>
        <member name="M:TouchSocket.Core.EasyLogger.#ctor(System.Action{System.String})">
            <summary>
            一个简单的委托日志
            </summary>
            <param name="action">参数为日志消息输出。</param>
        </member>
        <member name="M:TouchSocket.Core.EasyLogger.WriteLog(TouchSocket.Core.LogLevel,System.Object,System.String,System.Exception)">
            <inheritdoc/>
            <param name="logLevel"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="T:TouchSocket.Core.FileLogger">
            <summary>
            文件日志记录器
            <para>会在指定目录下，生成logs文件夹，然后按[yyyy-MM-dd].log的形式，每日生成日志</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileLogger.#ctor">
            <summary>
            初始化文件日志记录器
            </summary>
            <remarks>
            在类的构造函数中定义了一个lambda表达式，用于创建日志文件夹的路径
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.FileLogger.Finalize">
            <summary>
            析构函数，用于在对象被垃圾回收时进行资源清理
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileLogger.CreateLogFolder">
            <summary>
            获取或设置一个函数，用于根据日志级别创建日志文件夹。
            </summary>
            <value>
            当前用于根据日志级别创建日志文件夹的函数。
            </value>
            <exception cref="T:System.ArgumentNullException">
            如果尝试设置的值为 null，则抛出此异常。
            </exception>
        </member>
        <member name="P:TouchSocket.Core.FileLogger.FileNameFormat">
            <summary>
            文件名格式化字符串。默认为“0000”，当第1个文件，即为0001.log，第2个文件为0002.log，以此类推。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FileLogger.MaxSize">
            <summary>
            最大日志尺寸
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FileLogger.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.FileLogger.WriteLog(TouchSocket.Core.LogLevel,System.Object,System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.ILog">
            <summary>
            日志接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ILog.LogLevel">
            <summary>
            日志输出级别。
            当<see cref="M:TouchSocket.Core.ILog.Log(TouchSocket.Core.LogLevel,System.Object,System.String,System.Exception)"/>的类型，在该设置之内时，才会真正输出日志。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ILog.Log(TouchSocket.Core.LogLevel,System.Object,System.String,System.Exception)">
            <summary>
            日志记录
            </summary>
            <param name="logLevel"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="T:TouchSocket.Core.ILoggerObject">
            <summary>
            具有日志记录器的对象接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ILoggerObject.Logger">
            <summary>
            日志记录器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.LoggerBase">
            <summary>
            日志基类
            </summary>
        </member>
        <member name="P:TouchSocket.Core.LoggerBase.LogLevel">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.LoggerBase.Log(TouchSocket.Core.LogLevel,System.Object,System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.LoggerBase.WriteLog(TouchSocket.Core.LogLevel,System.Object,System.String,System.Exception)">
            <summary>
            筛选日志后输出
            </summary>
            <param name="logLevel"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="P:TouchSocket.Core.LoggerBase.DateTimeFormat">
            <summary>
            获取或设置日期时间格式
            </summary>
            <remarks>
            这个属性用于定义如何格式化或解析字符串中的日期和时间
            默认格式为 "yyyy-MM-dd HH:mm:ss ffff"，其中 "yyyy" 代表年份，
            "MM" 代表月份，"dd" 代表日期，"HH" 代表小时，
            "mm" 代表分钟，"ss" 代表秒，"ffff" 代表毫秒
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.LoggerBase.CreateLogString(TouchSocket.Core.LogLevel,System.Object,System.String,System.Exception)">
            <summary>
            创建日志字符串。
            </summary>
            <param name="logLevel">日志级别。</param>
            <param name="source">日志来源对象。</param>
            <param name="message">日志信息内容。</param>
            <param name="exception">关联的异常对象。</param>
            <returns>格式化后的日志字符串。</returns>
        </member>
        <member name="T:TouchSocket.Core.LoggerContainerExtension">
            <summary>
            日志记录器容器扩展类
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddConsoleLogger(TouchSocket.Core.LoggerGroup)">
            <summary>
            添加控制台日志到日志组。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddConsoleLogger(TouchSocket.Core.IRegistrator)">
            <summary>
            为注册器容器添加控制台日志记录器的扩展方法。
            </summary>
            <param name="container">要添加控制台日志记录器的注册器。</param>
            <returns>添加了控制台日志记录器的注册器。</returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddEasyLogger(TouchSocket.Core.LoggerGroup,System.Action{TouchSocket.Core.LogLevel,System.Object,System.String,System.Exception})">
            <summary>
            添加委托日志到日志组。
            </summary>
            <param name="loggerGroup">日志组对象，表示要添加委托日志到哪个日志组。</param>
            <param name="action">一个委托，表示日志记录的行动，包含日志级别、日志信息、标签以及异常信息。</param>
            <returns>该方法没有返回值。</returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddEasyLogger(TouchSocket.Core.LoggerGroup,System.Action{System.String})">
            <summary>
            添加委托日志到日志组。
            </summary>
            <param name="loggerGroup">日志组对象，表示要向其添加新日志器的组。</param>
            <param name="action">一个委托，定义了日志记录的方式。</param>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddEasyLogger(TouchSocket.Core.IRegistrator,System.Action{TouchSocket.Core.LogLevel,System.Object,System.String,System.Exception})">
            <summary>
            为注册容器添加一个简易的日志记录器。
            </summary>
            <param name="container">日志记录器需要注册到的容器。</param>
            <param name="action">一个委托动作，当记录日志时将被执行。它接收日志级别、日志消息、发生日志的源和任何异常信息作为参数。</param>
            <returns>返回注册容器，以便进行链式调用。</returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddEasyLogger(TouchSocket.Core.IRegistrator,System.Action{System.String})">
            <summary>
            向注册容器中添加一个简易的日志记录器
            </summary>
            <param name="container">要添加日志记录器的注册容器</param>
            <param name="action">一个委托，定义了如何处理日志消息</param>
            <returns>返回修改后的注册容器，支持链式调用</returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddFileLogger(TouchSocket.Core.LoggerGroup,System.String)">
            <summary>
            添加文件日志到日志组。
            </summary>
            <param name="loggerGroup">要添加文件日志的LoggerGroup实例。</param>
            <param name="rootPath">日志文件的根路径，默认为"logs"。</param>
            <returns>此方法不返回任何值。</returns>
            <remarks>
            该方法扩展了LoggerGroup类的功能，允许轻松添加文件日志记录器。
            文件日志记录器会根据当前日期在指定的根路径下创建日志文件夹。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddFileLogger(TouchSocket.Core.LoggerGroup,System.Action{TouchSocket.Core.FileLogger})">
            <summary>
            为 LoggerGroup 实例添加 FileLogger 功能的扩展方法。
            </summary>
            <param name="loggerGroup">要添加 FileLogger 的 LoggerGroup 实例。</param>
            <param name="action">一个包含 FileLogger 实例操作的委托，允许设置 FileLogger。</param>
            <remarks>
            此方法通过创建一个新的 FileLogger 实例，应用提供的配置操作，然后将配置好的 FileLogger 添加到 LoggerGroup 中。
            它提供了一种简洁的方式，将 FileLogger 集成到现有的 LoggerGroup 结构中，增强了日志记录能力。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddFileLogger(TouchSocket.Core.IRegistrator,System.String)">
            <summary>
            为注册器添加文件日志记录器扩展方法。
            </summary>
            <param name="container">要添加文件日志记录器的注册器。</param>
            <param name="rootPath">日志文件的基础路径，默认为"logs"。</param>
            <returns>添加了文件日志记录器后的注册器。</returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddFileLogger(TouchSocket.Core.IRegistrator,System.Action{TouchSocket.Core.FileLogger})">
            <summary>
            为注册器添加文件日志记录器的扩展方法。
            </summary>
            <param name="container">要添加文件日志记录器的注册器。</param>
            <param name="action">一个接受 FileLogger 实例作为参数的委托，用于配置文件日志记录器。</param>
            <returns>返回添加了文件日志记录器后的注册器，以便进行链式调用。</returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddLogger(TouchSocket.Core.IRegistrator,TouchSocket.Core.ILog)">
            <summary>
            添加单例日志到容器。
            </summary>
            <param name="registrator">要添加日志单例的注册器。</param>
            <param name="logger">要添加到容器的日志对象。</param>
            <returns>返回更新后的注册器对象，以便进行链式调用。</returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerContainerExtension.AddLogger(TouchSocket.Core.IRegistrator,System.Action{TouchSocket.Core.LoggerGroup})">
            <summary>
            添加单例日志到容器
            </summary>
            <param name="registrator">要扩展的注册器接口</param>
            <param name="loggerAction">用于配置LoggerGroup的委托</param>
            <returns>返回被扩展的注册器接口</returns>
        </member>
        <member name="T:TouchSocket.Core.LoggerExtensions">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Critical``1(TouchSocket.Core.ILog,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出中断日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Debug``1(TouchSocket.Core.ILog,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出调试日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Error``1(TouchSocket.Core.ILog,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出错误日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Error``1(TouchSocket.Core.ILog,System.Object,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出错误日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Exception``1(TouchSocket.Core.ILog,System.Exception)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出异常日志
            </summary>
            <param name="logger"></param>
            <param name="ex"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Exception``1(TouchSocket.Core.ILog,System.Object,System.Exception)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出异常日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="ex"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Info``1(TouchSocket.Core.ILog,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出消息日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Info``1(TouchSocket.Core.ILog,System.Object,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出消息日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Log``1(TouchSocket.Core.ILog,TouchSocket.Core.LogLevel,System.Object,System.String,System.Exception)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出日志
            </summary>
            <param name="logLevel"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
            <param name="logger"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Trace``1(TouchSocket.Core.ILog,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出详细日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Warning``1(TouchSocket.Core.ILog,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出警示日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Warning``1(TouchSocket.Core.ILog,System.Object,System.String)">
            <summary>
            指定在<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定日志类型中输出警示日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Critical(TouchSocket.Core.ILog,System.String)">
            <summary>
            输出中断日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Debug(TouchSocket.Core.ILog,System.String)">
            <summary>
            输出调试日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Error(TouchSocket.Core.ILog,System.String)">
            <summary>
            输出错误日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Error(TouchSocket.Core.ILog,System.Object,System.String)">
            <summary>
            输出错误日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Exception(TouchSocket.Core.ILog,System.Exception)">
            <summary>
            输出异常日志
            </summary>
            <param name="logger"></param>
            <param name="ex"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Exception(TouchSocket.Core.ILog,System.Object,System.Exception)">
            <summary>
            输出异常日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="ex"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Exception(TouchSocket.Core.ILog,System.Object,System.String,System.Exception)">
            <summary>
            输出异常日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="msg"></param>
            <param name="ex"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Info(TouchSocket.Core.ILog,System.String)">
            <summary>
            输出消息日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Info(TouchSocket.Core.ILog,System.Object,System.String)">
            <summary>
            输出消息日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Trace(TouchSocket.Core.ILog,System.String)">
            <summary>
            输出详细日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Warning(TouchSocket.Core.ILog,System.String)">
            <summary>
            输出警示日志
            </summary>
            <param name="logger"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerExtensions.Warning(TouchSocket.Core.ILog,System.Object,System.String)">
            <summary>
            输出警示日志
            </summary>
            <param name="logger"></param>
            <param name="source"></param>
            <param name="msg"></param>
        </member>
        <member name="T:TouchSocket.Core.LoggerGroup">
            <summary>
            一组日志记录器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.#ctor(TouchSocket.Core.ILog[])">
            <summary>
            一组日志记录器
            </summary>
            <param name="logs"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.#ctor">
            <summary>
             一组日志记录器
            </summary>
        </member>
        <member name="P:TouchSocket.Core.LoggerGroup.Logs">
            <summary>
            组内的日志记录器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.AddLogger(TouchSocket.Core.ILog)">
            <summary>
            添加日志组件
            </summary>
            <param name="logger"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.Log``1(TouchSocket.Core.LogLevel,System.Object,System.String,System.Exception)">
            <summary>
            指定输出<see cref="T:TouchSocket.Core.LoggerGroup"/>中的特定类型的日志
            </summary>
            <param name="logLevel"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.RemoveLogger(TouchSocket.Core.ILog)">
            <summary>
            移除指定日志日志
            </summary>
            <param name="logger"></param>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.RemoveLogger(System.Type)">
            <summary>
            移除指定类型的所有日志。
            </summary>
            <param name="loggerType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup.WriteLog(TouchSocket.Core.LogLevel,System.Object,System.String,System.Exception)">
            <inheritdoc/>
            <param name="logLevel"></param>
            <param name="source"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="T:TouchSocket.Core.LoggerGroup`2">
            <summary>
            一组日志记录器
            </summary>
            <typeparam name="TLog1"></typeparam>
            <typeparam name="TLog2"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup`2.#ctor(`0,`1)">
            <summary>
            一组日志记录器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.LoggerGroup`3">
            <summary>
            一组日志记录器
            </summary>
            <typeparam name="TLog1"></typeparam>
            <typeparam name="TLog2"></typeparam>
            <typeparam name="TLog3"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup`3.#ctor(`0,`1,`2)">
            <summary>
            一组日志记录器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.LoggerGroup`4">
            <summary>
            一组日志记录器
            </summary>
            <typeparam name="TLog1"></typeparam>
            <typeparam name="TLog2"></typeparam>
            <typeparam name="TLog3"></typeparam>
            <typeparam name="TLog4"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup`4.#ctor(`0,`1,`2,`3)">
            <summary>
            一组日志记录器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.LoggerGroup`5">
            <summary>
            一组日志记录器
            </summary>
            <typeparam name="TLog1"></typeparam>
            <typeparam name="TLog2"></typeparam>
            <typeparam name="TLog3"></typeparam>
            <typeparam name="TLog4"></typeparam>
            <typeparam name="TLog5"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>
            一组日志记录器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.LoggerGroup`6">
            <summary>
            一组日志记录器
            </summary>
            <typeparam name="TLog1"></typeparam>
            <typeparam name="TLog2"></typeparam>
            <typeparam name="TLog3"></typeparam>
            <typeparam name="TLog4"></typeparam>
            <typeparam name="TLog5"></typeparam>
            <typeparam name="TLog6"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.LoggerGroup`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>
            一组日志记录器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.LogLevel">
            <summary>
            日志类型。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LogLevel.Trace">
            <summary>
            更为详细的步骤型日志输出
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LogLevel.Debug">
            <summary>
            调试信息日志
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LogLevel.Info">
            <summary>
            消息类日志输出
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LogLevel.Warning">
            <summary>
            警告类日志输出
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LogLevel.Error">
            <summary>
            错误类日志输出
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LogLevel.Critical">
            <summary>
            不可控中断类日输出
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LogLevel.None">
            <summary>
            不使用日志类输出
            </summary>
        </member>
        <member name="T:TouchSocket.Core.Mapper">
            <summary>
            映射数据
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Mapper.Map``1(System.Object,TouchSocket.Core.MapperOption)">
            <summary>
            简单映射
            </summary>
            <typeparam name="TTarget"></typeparam>
            <param name="source"></param>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Mapper.Map``1(``0,TouchSocket.Core.MapperOption)">
            <summary>
            简单映射
            </summary>
            <typeparam name="TTarget"></typeparam>
            <param name="source"></param>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Mapper.Map``2(``0,TouchSocket.Core.MapperOption)">
            <summary>
            简单映射
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TTarget"></typeparam>
            <param name="source"></param>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Mapper.Map(System.Object,System.Type,TouchSocket.Core.MapperOption)">
            <summary>
            简单对象映射
            </summary>
            <param name="source"></param>
            <param name="targetType"></param>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Mapper.Map(System.Object,System.Object,TouchSocket.Core.MapperOption)">
            <summary>
            简单对象映射
            </summary>
            <param name="source"></param>
            <param name="target"></param>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Mapper.MapList``2(System.Collections.Generic.IEnumerable{``0},TouchSocket.Core.MapperOption)">
            <summary>
            映射List
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T1"></typeparam>
            <param name="list"></param>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Mapper.MapList``1(System.Collections.Generic.IEnumerable{System.Object},TouchSocket.Core.MapperOption)">
            <summary>
            映射List
            </summary>
            <typeparam name="T1"></typeparam>
            <param name="list"></param>
            <param name="option"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:TouchSocket.Core.MapperOption">
            <summary>
            映射配置
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MapperOption.IgnoreProperties">
            <summary>
            需要忽略的属性名称
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MapperOption.MapperProperties">
            <summary>
            映射属性名称
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IPackage">
            <summary>
            包接口规范
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IPackage.Package``1(``0@)">
            <summary>
            打包。
            <para>重写的话，约定基类方法必须先执行</para>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.IPackage.Unpackage``1(``0@)">
            <summary>
            解包。
            <para>重写的话，约定基类方法必须先执行</para>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="T:TouchSocket.Core.IReadonlyRouterPackage">
            <summary>
            只读的路由包接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IReadonlyRouterPackage.Route">
            <summary>
            标识是否路由
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IReadonlyRouterPackage.SourceId">
            <summary>
            源Id
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IReadonlyRouterPackage.TargetId">
            <summary>
            目标Id
            </summary>
        </member>
        <member name="T:TouchSocket.Core.MsgPackage">
            <summary>
            消息包
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MsgPackage.Message">
            <summary>
            消息
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MsgPackage.Package``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MsgPackage.Unpackage``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.MsgRouterPackage">
            <summary>
            可承载消息的路由包
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MsgRouterPackage.Message">
            <summary>
            消息
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MsgRouterPackage.PackageBody``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MsgRouterPackage.UnpackageBody``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.PackageBase">
            <summary>
            PackageBase包结构数据。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PackageBase.Package``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.PackageBase.Unpackage``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.PackageExtensions">
            <summary>
            PackageExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PackageExtensions.PackageAsBytes``1(``0)">
            <summary>
            将指定类型的实例序列化为字节流
            </summary>
            <typeparam name="TPackage">实现IPackage接口的类型</typeparam>
            <param name="package">要序列化的实例</param>
            <returns>序列化后的字节流</returns>
        </member>
        <member name="M:TouchSocket.Core.PackageExtensions.Package``1(``0,TouchSocket.Core.ByteBlock)">
            <summary>
            将指定类型的对象打包为字节块。
            </summary>
            <param name="package">要打包的对象，必须实现IPackage接口。</param>
            <param name="byteBlock">用于存储打包后数据的字节块。</param>
            <typeparam name="TPackage">要打包的对象的类型，必须实现IPackage接口。</typeparam>
        </member>
        <member name="M:TouchSocket.Core.PackageExtensions.Unpackage``1(``0,TouchSocket.Core.ByteBlock)">
            <summary>
            从字节块中解包出指定类型的对象。
            </summary>
            <param name="package">要解包的对象，必须实现IPackage接口。</param>
            <param name="byteBlock">包含要解包数据的字节块。</param>
            <typeparam name="TPackage">要解包对象的类型，必须实现IPackage接口。</typeparam>
        </member>
        <member name="T:TouchSocket.Core.RouterPackage">
            <summary>
            具有目标id和源id的路由包
            </summary>
        </member>
        <member name="P:TouchSocket.Core.RouterPackage.Route">
            <summary>
            获取是否路由此包数据。实际上是判断<see cref="P:TouchSocket.Core.RouterPackage.TargetId"/>与<see cref="P:TouchSocket.Core.RouterPackage.SourceId"/>是否有值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.RouterPackage.SourceId">
            <summary>
            源Id
            </summary>
        </member>
        <member name="P:TouchSocket.Core.RouterPackage.TargetId">
            <summary>
            目标Id
            </summary>
        </member>
        <member name="M:TouchSocket.Core.RouterPackage.Package``1(``0@)">
            <summary>
            打包所有的路由包信息。顺序为：先调用<see cref="M:TouchSocket.Core.RouterPackage.PackageRouter``1(``0@)"/>，然后<see cref="M:TouchSocket.Core.RouterPackage.PackageBody``1(``0@)"/>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.RouterPackage.PackageBody``1(``0@)">
            <summary>
            打包数据体。一般不需要单独调用该方法。
            <para>重写的话，约定基类方法必须先执行</para>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.RouterPackage.PackageRouter``1(``0@)">
            <summary>
            打包路由。
            <para>重写的话，约定基类方法必须先执行</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.RouterPackage.SwitchId">
            <summary>
            转换目标和源的id。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.RouterPackage.Unpackage``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.RouterPackage.UnpackageBody``1(``0@)">
            <summary>
            解包数据体。一般不需要单独调用该方法。
            <para>重写的话，约定基类方法必须先执行</para>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="M:TouchSocket.Core.RouterPackage.UnpackageRouter``1(``0@)">
            <summary>
            只解包路由部分。一般不需要单独调用该方法。
            <para>重写的话，约定基类方法必须先执行</para>
            </summary>
            <param name="byteBlock"></param>
        </member>
        <member name="T:TouchSocket.Core.WaitPackage">
            <summary>
            WaitPackage
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitPackage.Message">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.WaitPackage.Sign">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.WaitPackage.Status">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitPackage.Package``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitPackage.Unpackage``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.WaitRouterPackage">
            <summary>
            可等待的路由包。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitRouterPackage.Sign">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.WaitRouterPackage.Status">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.WaitRouterPackage.IncludedRouter">
            <summary>
            是否将<see cref="P:TouchSocket.Core.WaitRouterPackage.Sign"/>和<see cref="P:TouchSocket.Core.WaitRouterPackage.Status"/>等参数放置在Router中。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WaitRouterPackage.PackageBody``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitRouterPackage.PackageRouter``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitRouterPackage.UnpackageBody``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitRouterPackage.UnpackageRouter``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.IPlugin">
            <summary>
            插件接口
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IPlugin.Loaded(TouchSocket.Core.IPluginManager)">
            <summary>
            在插件被成功添加在<see cref="T:TouchSocket.Core.IPluginManager"/>时执行。
            </summary>
            <param name="pluginManager"></param>
        </member>
        <member name="T:TouchSocket.Core.IPluginManager">
            <summary>
            插件管理器接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IPluginManager.Enable">
            <summary>
            标识该插件管理器是否可用。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IPluginManager.GetPluginCount(System.Type)">
            <summary>
            获取已添加的指定名称的插件数量。
            </summary>
            <param name="interfeceType"></param>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Core.IPluginManager.Plugins">
            <summary>
            所包含的所有插件。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IPluginManager.Add(TouchSocket.Core.IPlugin)">
            <summary>
            添加插件
            </summary>
            <param name="plugin">插件</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.IPluginManager.Add(System.Type)">
            <summary>
            添加插件
            </summary>
            <param name="pluginType">插件类型</param>
        </member>
        <member name="M:TouchSocket.Core.IPluginManager.Add``1(System.Func{TouchSocket.Core.IResolver,``0})">
            <summary>
            添加插件
            </summary>
            <typeparam name="TPlugin"></typeparam>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IPluginManager.Add(System.Type,System.Func{System.Object,TouchSocket.Core.PluginEventArgs,System.Threading.Tasks.Task})">
            <summary>
            添加插件异步执行委托
            </summary>
            <param name="interfeceType"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IPluginManager.RaiseAsync(System.Type,System.Object,TouchSocket.Core.PluginEventArgs)">
            <summary>
            触发对应插件
            </summary>
            <param name="interfeceType"></param>
            <param name="sender"></param>
            <param name="e"></param>
            <returns>表示在执行的插件中，是否处理<see cref="P:TouchSocket.Core.TouchSocketEventArgs.Handled"/>为<see langword="true"/>。</returns>
        </member>
        <member name="T:TouchSocket.Core.IPluginObject">
            <summary>
            具有插件功能的对象
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IPluginObject.PluginManager">
            <summary>
            插件管理器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.PluginBase">
            <summary>
            PluginBase
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PluginBase.Loaded(TouchSocket.Core.IPluginManager)">
            <inheritdoc cref="M:TouchSocket.Core.IPlugin.Loaded(TouchSocket.Core.IPluginManager)"/>
        </member>
        <member name="P:TouchSocket.Core.PluginBase.PluginManager">
            <summary>
            插件管理器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.PluginEventArgs">
            <summary>
            插件事件类
            </summary>
        </member>
        <member name="P:TouchSocket.Core.PluginEventArgs.State">
            <summary>
            由使用者自定义的状态对象。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.PluginEventArgs.Count">
            <summary>
            执行的插件数量。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PluginEventArgs.InvokeNext">
            <summary>
            调用下一个插件。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.PluginManager">
            <summary>
            表示插件管理器。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PluginManager.#ctor(TouchSocket.Core.IResolver)">
            <summary>
            表示插件管理器
            </summary>
            <param name="resolver"></param>
        </member>
        <member name="P:TouchSocket.Core.PluginManager.Enable">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.PluginManager.Plugins">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.PluginManager.GetPluginCount(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.PluginManager.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.PluginManagerContainerExtension">
            <summary>
            PluginManagerContainerExtension
            </summary>
        </member>
        <member name="T:TouchSocket.Core.PluginManagerExtension">
            <summary>
            PluginManagerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.PluginManagerExtension.Add``1(TouchSocket.Core.IPluginManager)">
            <summary>
            添加插件
            </summary>
            <typeparam name="TPlugin">插件类型</typeparam>
            <returns>插件类型实例</returns>
        </member>
        <member name="M:TouchSocket.Core.PluginManagerExtension.Add``2(TouchSocket.Core.IPluginManager,System.Type,System.Func{``0,``1,System.Threading.Tasks.Task})">
            <summary>
            添加插件委托
            </summary>
            <typeparam name="TSender"></typeparam>
            <typeparam name="TEventArgs"></typeparam>
            <param name="pluginManager"></param>
            <param name="interfeceType"></param>
            <param name="func"></param>
        </member>
        <member name="M:TouchSocket.Core.PluginManagerExtension.Add``1(TouchSocket.Core.IPluginManager,System.Type,System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            添加插件委托
            </summary>
            <typeparam name="TEventArgs"></typeparam>
            <param name="pluginManager"></param>
            <param name="interfeceType"></param>
            <param name="func"></param>
        </member>
        <member name="M:TouchSocket.Core.PluginManagerExtension.Add(TouchSocket.Core.IPluginManager,System.Type,System.Func{System.Threading.Tasks.Task})">
            <summary>
            添加插件委托
            </summary>
            <param name="pluginManager"></param>
            <param name="interfeceType"></param>
            <param name="func"></param>
        </member>
        <member name="M:TouchSocket.Core.PluginManagerExtension.Add``1(TouchSocket.Core.IPluginManager,System.Type,System.Action{``0})">
            <summary>
            添加插件委托
            </summary>
            <param name="pluginManager"></param>
            <param name="interfeceType"></param>
            <param name="action"></param>
        </member>
        <member name="M:TouchSocket.Core.PluginManagerExtension.Add(TouchSocket.Core.IPluginManager,System.Type,System.Action)">
            <summary>
            添加插件委托
            </summary>
            <param name="pluginManager"></param>
            <param name="interfeceType"></param>
            <param name="action"></param>
        </member>
        <member name="T:TouchSocket.Core.PluginOptionAttribute">
            <summary>
            插件配置。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.PluginOptionAttribute.Singleton">
            <summary>
            标识该插件在一个<see cref="T:TouchSocket.Core.IPluginManager"/>中仅仅只会有一个实例。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ArrayPool`1">
            <summary>
            提供一个数组对象的池化容器。
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.ArrayPool`1.#ctor">
            <summary>
            提供一个数组对象的池化容器。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ArrayPool`1.#ctor(System.Int32,System.Int32)">
            <summary>
            提供一个数组对象的池化容器。
            </summary>
            <param name="maxArrayLength"></param>
            <param name="maxArraysPerBucket"></param>
        </member>
        <member name="P:TouchSocket.Core.ArrayPool`1.Capacity">
            <summary>
            对象池的最大容量。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ArrayPool`1.Clear">
            <summary>
            清理池中所有对象。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ArrayPool`1.GetPoolSize">
            <summary>
            获取当前池中的所有对象。
            </summary>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Core.ArrayPool`1.MaxBucketsToTry">
            <summary>
            最大请求尺寸梯度。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ArrayPool`1.Rent(System.Int32)">
            <summary>
            获取一个不小于指定尺寸的池化数组对象。
            </summary>
            <param name="minimumLength"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ArrayPool`1.Return(`0[],System.Boolean)">
            <summary>
            归还池化对象。
            </summary>
            <param name="array"></param>
            <param name="clearArray"></param>
        </member>
        <member name="M:TouchSocket.Core.ArrayPool`1.HitSize(System.Int32)">
            <summary>
            命中匹配尺寸
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.ByteBlockBuilderExtension">
            <summary>
            提供扩展方法以方便地构建字节块。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockBuilderExtension.Build(TouchSocket.Core.IByteBlockBuilder,TouchSocket.Core.ByteBlock)">
            <summary>
            扩展方法，用于构建给定的字节块。
            该方法通过引用传递字节块，以利用ref参数提高性能，避免不必要的复制。
            </summary>
            <param name="builder">实现IByteBlockBuilder接口的构建器对象。</param>
            <param name="byteBlock">要构建的字节块对象。</param>
        </member>
        <member name="T:TouchSocket.Core.ByteBlockExtension">
            <summary>
            提供字节块扩展方法的静态类。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockExtension.AsByteBlock(TouchSocket.Core.ValueByteBlock@)">
            <summary>
            将值类型的字节块转换为普通的字节块。
            </summary>
            <param name="valueByteBlock">要转换的值类型字节块。</param>
            <returns>一个新的字节块对象。</returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockExtension.AsStream(TouchSocket.Core.ByteBlock,System.Boolean)">
            <summary>
            将字节块转换为字节块流。
            </summary>
            <param name="byteBlock">要转换的字节块。</param>
            <param name="releaseTogether">是否在释放字节块时一起释放关联的资源，默认为true。</param>
            <returns>一个新的字节块流对象。</returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockExtension.ToArray``1(``0,System.Int32,System.Int32)">
            <summary>
            将指定的字节块转换为【新】字节数组。
            </summary>
            <typeparam name="TByteBlock">实现<see cref="T:TouchSocket.Core.IByteBlock"/>接口的字节块类型。</typeparam>
            <param name="byteBlock">字节块对象。</param>
            <param name="offset">起始偏移量。</param>
            <param name="length">要转换为数组的长度。</param>
            <returns>包含指定长度的【新】字节数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockExtension.ToArray``1(``0,System.Int32)">
            <summary>
            将指定的字节块转换为【新】字节数组，从指定偏移量开始，直到字节块的末尾。
            </summary>
            <typeparam name="TByteBlock">实现<see cref="T:TouchSocket.Core.IByteBlock"/>接口的字节块类型。</typeparam>
            <param name="byteBlock">字节块对象。</param>
            <param name="offset">起始偏移量。</param>
            <returns>从指定偏移量到字节块末尾的【新】字节数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockExtension.ToArray``1(``0)">
            <summary>
            将指定的字节块转换为【新】字节数组，从索引0开始，直到字节块的末尾。
            </summary>
            <typeparam name="TByteBlock">实现<see cref="T:TouchSocket.Core.IByteBlock"/>接口的字节块类型。</typeparam>
            <param name="byteBlock">字节块对象。</param>
            <returns>整个字节块的【新】字节数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockExtension.ToArrayTake``1(``0)">
            <summary>
            将指定的字节块从当前位置<see cref="P:TouchSocket.Core.IByteBlock.Position"/>转换为【新】字节数组，直到字节块的末尾。
            </summary>
            <typeparam name="TByteBlock">实现<see cref="T:TouchSocket.Core.IByteBlock"/>接口的字节块类型。</typeparam>
            <param name="byteBlock">字节块对象。</param>
            <returns>从当前位置到字节块末尾的【新】字节数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockExtension.ToArrayTake``1(``0,System.Int32)">
            <summary>
            将指定的字节块从当前位置<see cref="P:TouchSocket.Core.IByteBlock.Position"/>转换为【新】字节数组，指定长度。
            </summary>
            <typeparam name="TByteBlock">实现<see cref="T:TouchSocket.Core.IByteBlock"/>接口的字节块类型。</typeparam>
            <param name="byteBlock">字节块对象。</param>
            <param name="length">要转换为数组的长度。</param>
            <returns>从当前位置开始，指定长度的【新】字节数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockExtension.AsSegment``1(``0,System.Int32,System.Int32)">
            <summary>
            将字节块【作为】数组段。
            <para>
            【作为】的意思是，导出的数据内存实际上依旧是<see cref="T:TouchSocket.Core.IByteBlock"/>生命周期内的，不能脱离生命周期使用。
            </para>
            </summary>
            <typeparam name="TByteBlock">实现<see cref="T:TouchSocket.Core.IByteBlock"/>接口的字节块类型。</typeparam>
            <param name="byteBlock">要转换的字节块实例。</param>
            <param name="offset">数组段的起始偏移量。</param>
            <param name="length">数组段的长度。</param>
            <returns>一个包含指定偏移量和长度的数组段。</returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockExtension.AsSegment``1(``0,System.Int32)">
            <summary>
            将字节块【作为】数组段，从指定偏移量开始，长度为可读长度。
            <para>
            【作为】的意思是，导出的数据内存实际上依旧是<see cref="T:TouchSocket.Core.IByteBlock"/>生命周期内的，不能脱离生命周期使用。
            </para>
            </summary>
            <typeparam name="TByteBlock">实现<see cref="T:TouchSocket.Core.IByteBlock"/>接口的字节块类型。</typeparam>
            <param name="byteBlock">要转换的字节块实例。</param>
            <param name="offset">数组段的起始偏移量。</param>
            <returns>一个从指定偏移量开始，长度为可读长度的数组段。</returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockExtension.AsSegment``1(``0)">
            <summary>
            将字节块【作为】数组段，从头开始，长度为指定长度。
            <para>
            【作为】的意思是，导出的数据内存实际上依旧是<see cref="T:TouchSocket.Core.IByteBlock"/>生命周期内的，不能脱离生命周期使用。
            </para>
            </summary>
            <typeparam name="TByteBlock">实现<see cref="T:TouchSocket.Core.IByteBlock"/>接口的字节块类型。</typeparam>
            <param name="byteBlock">要转换的字节块实例。</param>
            <returns>一个从头开始，长度为字节块长度的数组段。</returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockExtension.AsSegmentTake``1(``0,System.Int32)">
            <summary>
            将字节块【作为】数组段，从当前位置开始，指定长度。
            <para>
            【作为】的意思是，导出的数据内存实际上依旧是<see cref="T:TouchSocket.Core.IByteBlock"/>生命周期内的，不能脱离生命周期使用。
            </para>
            </summary>
            <typeparam name="TByteBlock">实现<see cref="T:TouchSocket.Core.IByteBlock"/>接口的字节块类型。</typeparam>
            <param name="byteBlock">要转换的字节块实例。</param>
            <param name="length">数组段的长度。</param>
            <returns>一个从当前位置开始，指定长度的数组段。</returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockExtension.AsSegmentTake``1(``0)">
            <summary>
            将字节块【作为】数组段，从当前位置开始，长度为可读长度。
            <para>
            【作为】的意思是，导出的数据内存实际上依旧是<see cref="T:TouchSocket.Core.IByteBlock"/>生命周期内的，不能脱离生命周期使用。
            </para>
            </summary>
            <typeparam name="TByteBlock">实现<see cref="T:TouchSocket.Core.IByteBlock"/>接口的字节块类型。</typeparam>
            <param name="byteBlock">要转换的字节块实例。</param>
            <returns>一个从当前位置开始，长度为可读长度的数组段。</returns>
        </member>
        <member name="T:TouchSocket.Core.ByteBlock">
            <summary>
            字节块流
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.#ctor(TouchSocket.Core.ValueByteBlock@)">
            <summary>
            使用 ValueByteBlock 初始化 ByteBlock 对象。
            </summary>
            <param name="valueByteBlock">包含字节数据的 ValueByteBlock 对象。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.#ctor(System.Int32)">
            <summary>
            无参数构造函数，初始化一个具有默认大小的 ByteBlock 对象。
            </summary>
            <param name="byteSize">ByteBlock 的初始大小，默认为 64KB。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.#ctor(System.Int32,TouchSocket.Core.BytePool)">
            <summary>
            使用指定的字节池和大小初始化 ByteBlock 对象。
            </summary>
            <param name="byteSize">ByteBlock 的初始大小。</param>
            <param name="bytePool">用于 ByteBlock 的 BytePool 实例。</param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.#ctor(System.Byte[],System.Int32)">
            <summary>
            实例化一个已知内存的对象。且该内存不会被回收。
            </summary>
            <param name="bytes"></param>
            <param name="length"></param>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.#ctor(System.Byte[])">
            <summary>
            实例化一个已知内存的对象。且该内存不会被回收。
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Memory">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.TotalMemory">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Span">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.CanReadLength">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Capacity">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.FreeLength">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Holding">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Length">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Position">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Using">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.IsStruct">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.BytePool">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ByteBlock.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Clear">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Reset">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.SetCapacity(System.Int32,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.SetHolding(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.SetLength(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Seek(System.Int32,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Seek(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.SeekToEnd">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.SeekToStart">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToString">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToString(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToString(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Advance(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.GetMemory(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.GetSpan(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Read(System.Span{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadToSpan(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadByteBlock">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadPackage``1">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadBytesPackage">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadBytesPackageMemory">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadByte">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadString(TouchSocket.Core.FixedHeaderType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadVarUInt32">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadInt32">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadInt32(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToInt32s">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToInt32s(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadInt16">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadInt16(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToInt16s">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToInt16s(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadInt64">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadInt64(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToInt64s">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToInt64s(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadBoolean">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadBooleans">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToBoolensFromBit">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToBoolensFromByte">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadChar">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadChar(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToChars">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToChars(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadDouble">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadDouble(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToDoubles">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToDoubles(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadFloat">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadFloat(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToFloats">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToFloats(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadUInt16">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadUInt16(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToUInt16s">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToUInt16s(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadUInt32">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadUInt32(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToUInt32s">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToUInt32s(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadUInt64">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadUInt64(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToUInt64s">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToUInt64s(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadDecimal">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadDecimal(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToDecimals">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToDecimals(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadIsNull">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadDateTime">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToDateTimes">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadTimeSpan">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ToTimeSpans">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.ReadGuid">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.Write(System.ReadOnlySpan{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteByteBlock(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WritePackage``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteIsNull``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteIsNull``1(System.Nullable{``0})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteNotNull">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteNull">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteBytesPackage(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteBytesPackage(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteString(System.String,TouchSocket.Core.FixedHeaderType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteVarUInt32(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteInt32(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteInt32(System.Int32,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteInt16(System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteInt16(System.Int16,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteInt64(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteInt64(System.Int64,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteBoolean(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteBooleans(System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteByte(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteChar(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteChar(System.Char,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteDouble(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteDouble(System.Double,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteFloat(System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteFloat(System.Single,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteUInt16(System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteUInt16(System.UInt16,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteUInt32(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteUInt32(System.UInt32,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteUInt64(System.UInt64)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteUInt64(System.UInt64,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteDecimal(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteDecimal(System.Decimal,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteDateTime(System.DateTime)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteTimeSpan(System.TimeSpan)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ByteBlock.WriteGuid(System.Guid@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.ByteBlockStream">
            <summary>
            字节块流
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.#ctor(TouchSocket.Core.ByteBlock,System.Boolean)">
            <summary>
            初始化 ByteBlockStream 类的新实例。
            </summary>
            <param name="byteBlock">一个 ByteBlock 对象，表示字节块。</param>
            <param name="releaseTogether">一个布尔值，指示是否在释放流时同时释放字节块。</param>
        </member>
        <member name="P:TouchSocket.Core.ByteBlockStream.ByteBlock">
            <summary>
            获取此实例关联的 ByteBlock 对象。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlockStream.CanRead">
            <summary>
            仅当内存块可用，且<see cref="P:TouchSocket.Core.ByteBlockStream.CanReadLength"/>>0时为True。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlockStream.CanReadLength">
            <summary>
            还能读取的长度，计算为<see cref="P:TouchSocket.Core.ByteBlockStream.Length"/>与<see cref="P:TouchSocket.Core.ByteBlockStream.Position"/>的差值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlockStream.CanSeek">
            <summary>
            支持查找
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlockStream.CanWrite">
            <summary>
            可写入
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlockStream.Capacity">
            <summary>
            容量
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlockStream.FreeLength">
            <summary>
            空闲长度，准确掌握该值，可以避免内存扩展，计算为<see cref="P:TouchSocket.Core.ByteBlockStream.Capacity"/>与<see cref="P:TouchSocket.Core.ByteBlockStream.Position"/>的差值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlockStream.Length">
            <summary>
            真实长度
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlockStream.Position">
            <summary>
            流位置
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ByteBlockStream.Using">
            <summary>
            使用状态
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.Clear">
            <summary>
            清空所有内存数据
            </summary>
            <exception cref="T:System.ObjectDisposedException">内存块已释放</exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.Flush">
            <summary>
            无实际效果
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            读取数据，然后递增Pos
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.ReadByte">
            <summary>
            从当前流位置读取一个<see cref="T:System.Byte"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            设置流位置
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.Seek(System.Int32)">
            <summary>
            移动游标
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.SeekToEnd">
            <summary>
            设置游标到末位
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.SeekToStart">
            <summary>
            设置游标到首位
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.SetLength(System.Int64)">
            <summary>
            设置实际长度
            </summary>
            <param name="value"></param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.ToArray(System.Int32,System.Int32)">
            <summary>
            从指定位置转化到指定长度的有效内存。本操作不递增<see cref="P:TouchSocket.Core.ByteBlockStream.Position"/>
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.ToArray">
            <summary>
            转换为有效内存。本操作不递增<see cref="P:TouchSocket.Core.ByteBlockStream.Position"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.ToArray(System.Int32)">
            <summary>
            从指定位置转为有效内存。本操作不递增<see cref="P:TouchSocket.Core.ByteBlockStream.Position"/>
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.ToArrayTake(System.Int32)">
            <summary>
            将当前<see cref="P:TouchSocket.Core.ByteBlockStream.Position"/>至指定长度转化为有效内存。本操作不递增<see cref="P:TouchSocket.Core.ByteBlockStream.Position"/>
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            写入
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.ByteBlockStream.Dispose(System.Boolean)">
            <inheritdoc/>
            <param name="disposing"></param>
        </member>
        <member name="T:TouchSocket.Core.BytePool">
            <summary>
            内存池
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytePool.#ctor">
            <summary>
            内存池
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytePool.#ctor(System.Int32,System.Int32)">
            <summary>
            内存池
            </summary>
            <param name="maxArrayLength"></param>
            <param name="maxArraysPerBucket"></param>
        </member>
        <member name="P:TouchSocket.Core.BytePool.Default">
            <summary>
            默认的内存池实例
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytePool.SetDefault(TouchSocket.Core.BytePool)">
            <summary>
            设置默认内存池实例。
            </summary>
            <param name="bytePool"></param>
        </member>
        <member name="P:TouchSocket.Core.BytePool.AutoZero">
            <summary>
            回收内存时，自动归零
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BytePool.MaxBlockSize">
            <summary>
            单个块最大值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytePool.GetByteBlock(System.Int32)">
            <summary>
            获取ByteBlock
            </summary>
            <param name="byteSize">长度</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytePool.GetValueByteBlock(System.Int32)">
            <summary>
             获取ValueByteBlock
            </summary>
            <param name="byteSize"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.ValueByteBlock">
            <summary>
            字节块流
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.#ctor(System.Int32)">
            <summary>
            初始化 ValueByteBlock 类的新实例，从默认字节池租用指定大小的字节。
            </summary>
            <param name="byteSize">要从字节池租用的字节数。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.#ctor(System.Int32,TouchSocket.Core.BytePool)">
            <summary>
            初始化 ValueByteBlock 类的新实例，从指定的字节池租用指定大小的字节。
            </summary>
            <param name="byteSize">要从字节池租用的字节数。</param>
            <param name="bytePool">用于租用字节的 BytePool 实例。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.#ctor(System.Byte[],System.Int32)">
            <summary>
            初始化 ValueByteBlock 类的新实例，使用现有的字节数组。
            </summary>
            <param name="bytes">包含字节的数组。</param>
            <param name="length">数组中要使用的字节数。</param>
            <exception cref="T:System.ArgumentNullException">如果 bytes 参数为 null，则引发此异常。</exception>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.#ctor(System.Byte[])">
            <summary>
            初始化 ValueByteBlock 类的新实例，使用现有的字节数组，并使用整个数组的长度。
            </summary>
            <param name="bytes">要使用的字节数组。</param>
            <exception cref="T:System.ArgumentNullException">如果 bytes 参数为 null，则引发此异常。</exception>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Empty">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.BytePool">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.CanReadLength">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Capacity">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.FreeLength">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Holding">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.IsStruct">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Length">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Memory">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Position">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Span">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.TotalMemory">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Using">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ValueByteBlock.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Clear">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Equals(TouchSocket.Core.ValueByteBlock)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Reset">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.SetCapacity(System.Int32,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.SetHolding(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.SetLength(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Seek(System.Int32,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Seek(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.SeekToEnd">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.SeekToStart">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToString">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToString(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToString(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Advance(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.GetMemory(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.GetSpan(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Read(System.Span{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadToSpan(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadByteBlock">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadPackage``1">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadBytesPackage">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadBytesPackageMemory">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadByte">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadString(TouchSocket.Core.FixedHeaderType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadVarUInt32">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadInt32">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadInt32(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToInt32s">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToInt32s(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadInt16">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadInt16(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToInt16s">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToInt16s(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadInt64">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadInt64(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToInt64s">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToInt64s(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadBoolean">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadBooleans">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToBoolensFromBit">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToBoolensFromByte">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadChar">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadChar(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToChars">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToChars(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadDouble">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadDouble(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToDoubles">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToDoubles(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadFloat">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadFloat(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToFloats">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToFloats(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadUInt16">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadUInt16(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToUInt16s">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToUInt16s(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadUInt32">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadUInt32(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToUInt32s">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToUInt32s(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadUInt64">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadUInt64(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToUInt64s">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToUInt64s(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadDecimal">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadDecimal(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToDecimals">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToDecimals(TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadIsNull">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadDateTime">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToDateTimes">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadTimeSpan">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ToTimeSpans">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.ReadGuid">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.Write(System.ReadOnlySpan{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteByteBlock(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WritePackage``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteIsNull``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteIsNull``1(System.Nullable{``0})">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteNotNull">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteNull">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteBytesPackage(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteBytesPackage(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteString(System.String,TouchSocket.Core.FixedHeaderType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteVarUInt32(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteInt32(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteInt32(System.Int32,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteInt16(System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteInt16(System.Int16,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteInt64(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteInt64(System.Int64,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteBoolean(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteBooleans(System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteByte(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteChar(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteChar(System.Char,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteDouble(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteDouble(System.Double,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteFloat(System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteFloat(System.Single,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteUInt16(System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteUInt16(System.UInt16,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteUInt32(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteUInt32(System.UInt32,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteUInt64(System.UInt64)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteUInt64(System.UInt64,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteDecimal(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteDecimal(System.Decimal,TouchSocket.Core.EndianType)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteDateTime(System.DateTime)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteTimeSpan(System.TimeSpan)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueByteBlock.WriteGuid(System.Guid@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.BytesReader">
            <summary>
            字节块流
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.#ctor(System.ReadOnlySpan{System.Byte})">
            <summary>
            初始化 BytesReader 类的新实例。
            </summary>
            <param name="span">一个只读字节跨度，用于初始化 BytesReader。</param>
        </member>
        <member name="P:TouchSocket.Core.BytesReader.CanReadLength">
            <summary>
            还能读取的长度，计算为<see cref="P:TouchSocket.Core.BytesReader.Length"/>与<see cref="P:TouchSocket.Core.BytesReader.Position"/>的差值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BytesReader.Length">
            <summary>
            获取当前实例的长度。
            </summary>
            <value>实例的长度。</value>
        </member>
        <member name="P:TouchSocket.Core.BytesReader.Position">
            <summary>
            流位置
            </summary>
        </member>
        <member name="P:TouchSocket.Core.BytesReader.Span">
            <summary>
            获取当前实例的只读字节序列视图。
            </summary>
            <remarks>
            此属性提供了一个只读的字节序列视图，它允许对内部存储的字节数据进行只读访问，
            而不需要修改或拥有这些数据。这对于读取数据而不更改其原始值时非常有用。
            </remarks>
            <value>
            当前实例的只读字节序列视图。
            </value>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.Read(System.Span{System.Byte})">
            <summary>
            从当前流中读取数据到指定的字节 span 中。
            </summary>
            <param name="span">要写入数据的字节 span。</param>
            <returns>实际读取到的字节数。</returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadToSpan(System.Int32)">
            <summary>
            从当前位置读取指定长度的数组。并递增<see cref="P:TouchSocket.Core.BytesReader.Position"/>
            </summary>
            <param name="length"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToArray(System.Int32,System.Int32)">
            <summary>
            从指定位置转化到指定长度的有效内存。本操作不递增<see cref="P:TouchSocket.Core.BytesReader.Position"/>
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToArray">
            <summary>
            转换为有效内存。本操作不递增<see cref="P:TouchSocket.Core.BytesReader.Position"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToArray(System.Int32)">
            <summary>
            从指定位置转为有效内存。本操作不递增<see cref="P:TouchSocket.Core.BytesReader.Position"/>
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToArrayTake(System.Int32)">
            <summary>
            将当前<see cref="P:TouchSocket.Core.BytesReader.Position"/>至指定长度转化为有效内存。本操作不递增<see cref="P:TouchSocket.Core.BytesReader.Position"/>
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToArrayTake">
            <summary>
            将当前<see cref="P:TouchSocket.Core.BytesReader.Position"/>至有效长度转化为有效内存。本操作不递增<see cref="P:TouchSocket.Core.BytesReader.Position"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadVarUInt32">
            <summary>
            从当前的字节序列位置开始读取一个使用可变长度编码的无符号32位整数。
            </summary>
            <returns>解码后的无符号32位整数。</returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadByteBlock">
            <summary>
            从当前流位置读取一个<see cref="T:TouchSocket.Core.ByteBlock"/>值。
            <para>
            注意，使用该方式读取到的内存块，会脱离释放周期，所以最好在使用完成后自行释放。
            </para>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.Seek(System.Int32,System.IO.SeekOrigin)">
            <summary>
            设置流位置
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.Seek(System.Int32)">
            <summary>
            移动游标
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.SeekToEnd">
            <summary>
            设置游标到末位
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.SeekToStart">
            <summary>
            设置游标到首位
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadBytesPackage">
            <summary>
            从当前流位置读取一个独立的<see cref="T:System.Byte"/>数组包
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadBytesPackageMemory">
            <summary>
            从当前的字节流中读取一个长度确定的字节包。
            </summary>
            <returns>一个只读的字节跨度，表示读取的字节包，如果读取失败则返回null。</returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadByte">
            <summary>
            从当前流位置读取一个<see cref="T:System.Byte"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadString(TouchSocket.Core.FixedHeaderType)">
            <summary>
            从当前流位置读取一个<see cref="T:System.String"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadInt32">
            <summary>
            从当前的输入流中读取一个32位整数。
            </summary>
            <returns>读取到的32位整数。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">当可读取长度小于4字节时抛出。</exception>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadInt32(TouchSocket.Core.EndianType)">
            <summary>
            从当前流位置读取一个指定端序的<see cref="T:System.Int32"/>值
            </summary>
            <param name="endianType"></param>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToInt32s">
            <summary>
            将当前有效内存转为默认端序的<see cref="T:System.Int32"/>集合。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToInt32s(TouchSocket.Core.EndianType)">
            <summary>
            将当前有效内存转为指定端序的<see cref="T:System.Int32"/>集合。
            </summary>
            <param name="endianType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadInt16">
            <summary>
            从当前流位置读取一个默认端序的<see cref="T:System.Int16"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadInt16(TouchSocket.Core.EndianType)">
            <summary>
            从当前流位置读取一个<see cref="T:System.Int16"/>值
            </summary>
            <param name="endianType">指定端序</param>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToInt16s">
            <summary>
            将当前有效内存转为默认端序的<see cref="T:System.Int16"/>集合。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToInt16s(TouchSocket.Core.EndianType)">
            <summary>
            将当前有效内存转为指定端序的<see cref="T:System.Int16"/>集合。
            </summary>
            <param name="endianType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadInt64">
            <summary>
            从当前流位置读取一个默认端序的<see cref="T:System.Int64"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadInt64(TouchSocket.Core.EndianType)">
            <summary>
            从当前流位置读取一个<see cref="T:System.Int64"/>值
            </summary>
            <param name="endianType">指定端序</param>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToInt64s">
            <summary>
            将当前有效内存转为默认端序的<see cref="T:System.Int64"/>集合。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToInt64s(TouchSocket.Core.EndianType)">
            <summary>
            将当前有效内存转为指定端序的<see cref="T:System.Int64"/>集合。
            </summary>
            <param name="endianType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadBoolean">
            <summary>
            从当前流位置读取1个<see cref="T:System.Boolean"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadBooleans">
            <summary>
            从当前流位置读取1个字节，按位解析为bool值数组。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToBoolensFromBit">
            <summary>
            将当前有效内存按位转为<see cref="T:System.Boolean"/>集合。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToBoolensFromByte">
            <summary>
            将当前有效内存按字节转为<see cref="T:System.Boolean"/>集合。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadChar">
            <summary>
            从当前流位置读取一个默认端序的<see cref="T:System.Char"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadChar(TouchSocket.Core.EndianType)">
            <summary>
            从当前流位置读取一个<see cref="T:System.Char"/>值
            </summary>
            <param name="endianType">指定端序</param>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToChars">
            <summary>
            将当前有效内存转为默认端序的<see cref="T:System.Char"/>集合。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToChars(TouchSocket.Core.EndianType)">
            <summary>
            将当前有效内存转为指定端序的<see cref="T:System.Char"/>集合。
            </summary>
            <param name="endianType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadDouble">
            <summary>
            从当前流位置读取一个默认端序的<see cref="T:System.Double"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadDouble(TouchSocket.Core.EndianType)">
            <summary>
            从当前流位置读取一个<see cref="T:System.Double"/>值
            </summary>
            <param name="endianType">指定端序</param>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToDoubles">
            <summary>
            将当前有效内存转为默认端序的<see cref="T:System.Double"/>集合。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToDoubles(TouchSocket.Core.EndianType)">
            <summary>
            将当前有效内存转为指定端序的<see cref="T:System.Double"/>集合。
            </summary>
            <param name="endianType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadFloat">
            <summary>
            从当前流位置读取一个默认端序的<see cref="T:System.Single"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadFloat(TouchSocket.Core.EndianType)">
            <summary>
            从当前流位置读取一个<see cref="T:System.Single"/>值
            </summary>
            <param name="endianType">指定端序</param>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToFloats">
            <summary>
            将当前有效内存转为默认端序的<see cref="T:System.Single"/>集合。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToFloats(TouchSocket.Core.EndianType)">
            <summary>
            将当前有效内存转为指定端序的<see cref="T:System.Single"/>集合。
            </summary>
            <param name="endianType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadUInt16">
            <summary>
            从当前流位置读取一个默认端序的<see cref="T:System.UInt16"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadUInt16(TouchSocket.Core.EndianType)">
            <summary>
            从当前流位置读取一个<see cref="T:System.UInt16"/>值
            </summary>
            <param name="endianType">指定端序</param>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToUInt16s">
            <summary>
            将当前有效内存转为默认端序的<see cref="T:System.UInt16"/>集合。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToUInt16s(TouchSocket.Core.EndianType)">
            <summary>
            将当前有效内存转为指定端序的<see cref="T:System.UInt16"/>集合。
            </summary>
            <param name="endianType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadUInt32">
            <summary>
            从当前流位置读取一个默认端序的<see cref="T:System.UInt32"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadUInt32(TouchSocket.Core.EndianType)">
            <summary>
            从当前流位置读取一个<see cref="T:System.UInt32"/>值
            </summary>
            <param name="endianType">指定端序</param>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToUInt32s">
            <summary>
            将当前有效内存转为默认端序的<see cref="T:System.UInt32"/>集合。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToUInt32s(TouchSocket.Core.EndianType)">
            <summary>
            将当前有效内存转为指定端序的<see cref="T:System.UInt32"/>集合。
            </summary>
            <param name="endianType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadUInt64">
            <summary>
            从当前流位置读取一个默认端序的<see cref="T:System.UInt64"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadUInt64(TouchSocket.Core.EndianType)">
            <summary>
            从当前流位置读取一个<see cref="T:System.UInt64"/>值
            </summary>
            <param name="endianType">指定端序</param>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToUInt64s">
            <summary>
            将当前有效内存转为默认端序的<see cref="T:System.UInt64"/>集合。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToUInt64s(TouchSocket.Core.EndianType)">
            <summary>
            将当前有效内存转为指定端序的<see cref="T:System.UInt64"/>集合。
            </summary>
            <param name="endianType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadDecimal">
            <summary>
            从当前流位置读取一个默认端序的<see cref="T:System.Decimal"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadDecimal(TouchSocket.Core.EndianType)">
            <summary>
            从当前流位置读取一个<see cref="T:System.Decimal"/>值
            </summary>
            <param name="endianType">指定端序</param>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToDecimals">
            <summary>
            将当前有效内存转为默认端序的<see cref="T:System.Decimal"/>集合。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToDecimals(TouchSocket.Core.EndianType)">
            <summary>
            将当前有效内存转为指定端序的<see cref="T:System.Decimal"/>集合。
            </summary>
            <param name="endianType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadIsNull">
            <summary>
            从当前流位置读取一个标识值，判断是否为null。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadDateTime">
            <summary>
            从当前流位置读取一个<see cref="T:System.DateTime"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToDateTimes">
            <summary>
            将当前有效内存转为<see cref="T:System.DateTime"/>集合。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ReadTimeSpan">
            <summary>
            从当前流位置读取一个<see cref="T:System.TimeSpan"/>值
            </summary>
        </member>
        <member name="M:TouchSocket.Core.BytesReader.ToTimeSpans">
            <summary>
            将当前有效内存转为<see cref="T:System.TimeSpan"/>集合。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.IByteBlock">
            <summary>
            定义了一个可释放的字节块接口，用于支持将字节数据写入缓冲区。
            该接口继承自<see cref="T:System.IDisposable"/>和<see cref="T:System.Buffers.IBufferWriter`1"/>，表明它既是一个可释放资源的对象，
            也是一个能够将字节数据写入缓冲区的对象。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.CanRead">
            <summary>
            获取是否可以读取。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.CanReadLength">
            <summary>
            获取可以读取的长度。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Capacity">
            <summary>
            获取容量。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.FreeLength">
            <summary>
            获取空闲长度。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Holding">
            <summary>
            获取是否持有数据。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.IsStruct">
            <summary>
            获取是否为结构类型。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Length">
            <summary>
            获取长度。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Memory">
            <summary>
            获取只读内存。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Position">
            <summary>
            获取或设置位置。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Span">
            <summary>
            获取只读字节跨度。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.TotalMemory">
            <summary>
            获取总内存。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Using">
            <summary>
            获取是否正在使用。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.BytePool">
            <summary>
            获取字节池。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlock.Item(System.Int32)">
            <summary>
            获取或设置指定索引处的字节。
            </summary>
            <param name="index">索引位置。</param>
            <value>指定索引处的字节。</value>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.Clear">
            <summary>
            清空当前数据结构中的所有数据。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadBoolean">
            <summary>
            读取一个布尔值。
            </summary>
            <returns>返回读取的布尔值。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadBooleans">
            <summary>
            读取一个布尔值数组。
            </summary>
            <returns>返回读取的布尔值数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToBoolensFromBit">
            <summary>
            从位数据中转换为布尔值集合。
            </summary>
            <returns>返回转换得到的布尔值集合。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToBoolensFromByte">
            <summary>
            从字节数据中转换为布尔值集合。
            </summary>
            <returns>返回转换得到的布尔值集合。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteBoolean(System.Boolean)">
            <summary>
            写入一个布尔值。
            </summary>
            <param name="value">要写入的布尔值。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteBooleans(System.Boolean[])">
            <summary>
            写入一个布尔值数组。
            </summary>
            <param name="values">要写入的布尔值数组。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadByte">
            <summary>
            读取一个字节。
            </summary>
            <returns>返回读取到的字节。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteByte(System.Byte)">
            <summary>
            写入一个字节。
            </summary>
            <param name="value">要写入的字节值。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.Write(System.ReadOnlySpan{System.Byte})">
            <summary>
            将指定的字节序列写入到当前内存的<see cref="P:TouchSocket.Core.IByteBlock.Position"/>处。
            </summary>
            <param name="span">一个只读的字节序列，表示要写入的数据。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.Read(System.Span{System.Byte})">
            <summary>
            从数据源读取字节并将其写入指定的字节范围。
            </summary>
            <param name="span">要写入读取字节的字节范围。</param>
            <returns>实际写入字节范围的字节数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadByteBlock">
            <summary>
            读取一个字节块。
            </summary>
            <returns>返回读取到的字节块。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteByteBlock(TouchSocket.Core.ByteBlock)">
            <summary>
            写入一个字节块。
            </summary>
            <param name="byteBlock">要写入的字节块。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadChar">
            <summary>
            从输入流中读取一个字符。
            </summary>
            <returns>返回读取的字符。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadChar(TouchSocket.Core.EndianType)">
            <summary>
            根据指定的字节序从输入流中读取一个字符。
            </summary>
            <param name="endianType">指定的字节序类型。</param>
            <returns>返回读取的字符。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToChars">
            <summary>
            从输入流中读取一系列字符。
            </summary>
            <returns>返回一个字符序列。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToChars(TouchSocket.Core.EndianType)">
            <summary>
            根据指定的字节序从输入流中读取一系列字符。
            </summary>
            <param name="endianType">指定的字节序类型。</param>
            <returns>返回一个字符序列。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteChar(System.Char)">
            <summary>
            向输出流写入一个字符。
            </summary>
            <param name="value">要写入的字符。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteChar(System.Char,TouchSocket.Core.EndianType)">
            <summary>
            根据指定的字节序向输出流写入一个字符。
            </summary>
            <param name="value">要写入的字符。</param>
            <param name="endianType">指定的字节序类型。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadDecimal">
            <summary>
            读取一个字节序列并将其转换为十进制数。
            </summary>
            <returns>转换后的十进制数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadDecimal(TouchSocket.Core.EndianType)">
            <summary>
            根据指定的字节序读取一个字节序列并将其转换为十进制数。
            </summary>
            <param name="endianType">指定的字节序。</param>
            <returns>转换后的十进制数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToDecimals">
            <summary>
            将一系列字节序列转换为十进制数的集合。
            </summary>
            <returns>转换后的十进制数集合。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToDecimals(TouchSocket.Core.EndianType)">
            <summary>
            根据指定的字节序将一系列字节序列转换为十进制数的集合。
            </summary>
            <param name="endianType">指定的字节序。</param>
            <returns>转换后的十进制数集合。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteDecimal(System.Decimal)">
            <summary>
            将一个十进制数转换为字节序列并写入。
            </summary>
            <param name="value">要转换并写入的十进制数。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteDecimal(System.Decimal,TouchSocket.Core.EndianType)">
            <summary>
            根据指定的字节序将一个十进制数转换为字节序列并写入。
            </summary>
            <param name="value">要转换并写入的十进制数。</param>
            <param name="endianType">指定的字节序。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadFloat">
            <summary>
            读取一个浮点数。
            </summary>
            <returns>读取到的浮点数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadFloat(TouchSocket.Core.EndianType)">
            <summary>
            按指定的字节序读取一个浮点数。
            </summary>
            <param name="endianType">指定的字节序类型。</param>
            <returns>读取到的浮点数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToFloats">
            <summary>
            读取一系列浮点数。
            </summary>
            <returns>一个浮点数的集合。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToFloats(TouchSocket.Core.EndianType)">
            <summary>
            按指定的字节序读取一系列浮点数。
            </summary>
            <param name="endianType">指定的字节序类型。</param>
            <returns>一个浮点数的集合。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteFloat(System.Single)">
            <summary>
            写入一个浮点数。
            </summary>
            <param name="value">要写入的浮点数值。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteFloat(System.Single,TouchSocket.Core.EndianType)">
            <summary>
            按指定的字节序写入一个浮点数。
            </summary>
            <param name="value">要写入的浮点数值。</param>
            <param name="endianType">指定的字节序类型。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadInt64">
            <summary>
            读取一个 Int64 类型的值。
            </summary>
            <returns>读取到的 Int64 类型的值。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadInt64(TouchSocket.Core.EndianType)">
            <summary>
            按指定的字节序读取一个 Int64 类型的值。
            </summary>
            <param name="endianType">指定的字节序类型。</param>
            <returns>读取到的 Int64 类型的值。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToInt64s">
            <summary>
            将当前对象转换为一系列 Int64 类型的值。
            </summary>
            <returns>一系列 Int64 类型的值。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToInt64s(TouchSocket.Core.EndianType)">
            <summary>
            按指定的字节序将当前对象转换为一系列 Int64 类型的值。
            </summary>
            <param name="endianType">指定的字节序类型。</param>
            <returns>一系列 Int64 类型的值。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteInt64(System.Int64)">
            <summary>
            写入一个 Int64 类型的值。
            </summary>
            <param name="value">要写入的 Int64 类型的值。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteInt64(System.Int64,TouchSocket.Core.EndianType)">
            <summary>
            按指定的字节序写入一个 Int64 类型的值。
            </summary>
            <param name="value">要写入的 Int64 类型的值。</param>
            <param name="endianType">指定的字节序类型。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadIsNull">
            <summary>
            读取是否为null。
            </summary>
            <returns>如果读取内容为null，则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteIsNull``1(``0)">
            <summary>
            写入一个值，并标记该值是否为null。
            </summary>
            <param name="t">要写入的值。</param>
            <typeparam name="T">值的类型，必须是引用类型。</typeparam>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteIsNull``1(System.Nullable{``0})">
            <summary>
            写入一个可能为null的值，并标记该值是否为null。
            </summary>
            <param name="t">要写入的值，可以为null。</param>
            <typeparam name="T">值的类型，必须是值类型。</typeparam>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteNotNull">
            <summary>
            写入一个非null的标记。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteNull">
            <summary>
            写入一个null的标记。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadGuid">
            <summary>
            读取一个全局唯一标识符（GUID）。
            </summary>
            <returns>返回读取到的GUID。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteGuid(System.Guid@)">
            <summary>
            写入一个全局唯一标识符（GUID）。
            </summary>
            <param name="value">要写入的GUID，使用in修饰符确保参数只读且不复制。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadTimeSpan">
            <summary>
            读取一个时间间隔。
            </summary>
            <returns>返回读取的时间间隔。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToTimeSpans">
            <summary>
            将当前对象转换为一系列时间间隔。
            </summary>
            <returns>返回一个时间间隔的集合。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteTimeSpan(System.TimeSpan)">
            <summary>
            写入一个时间间隔。
            </summary>
            <param name="value">要写入的时间间隔。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadUInt32">
            <summary>
            读取一个无符号32位整数，使用默认的大端字节序。
            </summary>
            <returns>读取到的无符号32位整数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadUInt32(TouchSocket.Core.EndianType)">
            <summary>
            按指定的字节序读取一个无符号32位整数。
            </summary>
            <param name="endianType">指定的字节序类型。</param>
            <returns>读取到的无符号32位整数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToUInt32s">
            <summary>
            将输入的数据流转换为一系列无符号32位整数，使用默认的大端字节序。
            </summary>
            <returns>转换得到的一系列无符号32位整数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToUInt32s(TouchSocket.Core.EndianType)">
            <summary>
            按指定的字节序将输入的数据流转换为一系列无符号32位整数。
            </summary>
            <param name="endianType">指定的字节序类型。</param>
            <returns>转换得到的一系列无符号32位整数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteUInt32(System.UInt32)">
            <summary>
            将无符号32位整数写入输出流，使用默认的大端字节序。
            </summary>
            <param name="value">要写入的无符号32位整数。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteUInt32(System.UInt32,TouchSocket.Core.EndianType)">
            <summary>
            按指定的字节序将无符号32位整数写入输出流。
            </summary>
            <param name="value">要写入的无符号32位整数。</param>
            <param name="endianType">指定的字节序类型。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadUInt64">
            <summary>
            读取一个无符号64位整数。
            </summary>
            <returns>读取到的无符号64位整数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadUInt64(TouchSocket.Core.EndianType)">
            <summary>
            按指定字节序读取一个无符号64位整数。
            </summary>
            <param name="endianType">指定的字节序。</param>
            <returns>读取到的无符号64位整数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToUInt64s">
            <summary>
            将输入流中的数据全部转换为无符号64位整数的集合。
            </summary>
            <returns>转换得到的无符号64位整数集合。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToUInt64s(TouchSocket.Core.EndianType)">
            <summary>
            按指定字节序将输入流中的数据全部转换为无符号64位整数的集合。
            </summary>
            <param name="endianType">指定的字节序。</param>
            <returns>转换得到的无符号64位整数集合。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteUInt64(System.UInt64)">
            <summary>
            写入一个无符号64位整数。
            </summary>
            <param name="value">要写入的无符号64位整数值。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteUInt64(System.UInt64,TouchSocket.Core.EndianType)">
            <summary>
            按指定字节序写入一个无符号64位整数。
            </summary>
            <param name="value">要写入的无符号64位整数值。</param>
            <param name="endianType">指定的字节序。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.Seek(System.Int32)">
            <summary>
            将流定位到指定位置。
            </summary>
            <param name="position">要定位到的位置。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.Seek(System.Int32,System.IO.SeekOrigin)">
            <summary>
            将流定位到相对于指定起始点的偏移位置。
            </summary>
            <param name="offset">从起始点开始的偏移量。</param>
            <param name="origin">偏移量的起始点。</param>
            <returns>新的位置。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.SeekToEnd">
            <summary>
            将流定位到末尾位置。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.SeekToStart">
            <summary>
            将流定位到起始位置。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadToSpan(System.Int32)">
            <summary>
            将指定长度的数据读取到只读字节跨度中。
            </summary>
            <param name="length">要读取的数据长度。</param>
            <returns>包含读取数据的只读字节跨度。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.Reset">
            <summary>
            重置当前对象的状态到初始状态。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.SetCapacity(System.Int32,System.Boolean)">
            <summary>
            设置当前对象的容量。
            </summary>
            <param name="size">新的容量大小。</param>
            <param name="retainedData">是否保留原有数据，默认为false。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.SetHolding(System.Boolean)">
            <summary>
            设置当前对象是否处于持有状态。
            </summary>
            <param name="holding">true表示处于持有状态，false表示非持有状态。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.SetLength(System.Int32)">
            <summary>
            设置当前对象的长度。
            </summary>
            <param name="value">新的长度值。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToString">
            <summary>
            将当前实例转换为字符串表示形式。
            </summary>
            <returns>当前实例的字符串表示。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToString(System.Int32)">
            <summary>
            将当前实例从指定位置转换为字符串表示形式。
            </summary>
            <param name="offset">开始转换的索引位置。</param>
            <returns>从指定位置开始的当前实例的字符串表示。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToString(System.Int32,System.Int32)">
            <summary>
            将当前实例从指定位置开始，并在指定长度内转换为字符串表示形式。
            </summary>
            <param name="offset">开始转换的索引位置。</param>
            <param name="length">转换的字符数量。</param>
            <returns>从指定位置开始，并在指定长度内的当前实例的字符串表示。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadDateTime">
            <summary>
            读取一个DateTime值。
            </summary>
            <returns>返回读取到的DateTime值。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToDateTimes">
            <summary>
            将当前实例转换为一系列的DateTime值。
            </summary>
            <returns>返回一个IEnumerable&lt;DateTime&gt;，包含转换后的DateTime值。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteDateTime(System.DateTime)">
            <summary>
            写入一个DateTime值。
            </summary>
            <param name="value">要写入的DateTime值。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadDouble">
            <summary>
            读取一个双精度浮点数。
            </summary>
            <returns>读取到的双精度浮点数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadDouble(TouchSocket.Core.EndianType)">
            <summary>
            按指定字节序读取一个双精度浮点数。
            </summary>
            <param name="endianType">指定的字节序。</param>
            <returns>读取到的双精度浮点数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToDoubles">
            <summary>
            读取一系列双精度浮点数。
            </summary>
            <returns>一个包含读取到的双精度浮点数的序列。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToDoubles(TouchSocket.Core.EndianType)">
            <summary>
            按指定字节序读取一系列双精度浮点数。
            </summary>
            <param name="endianType">指定的字节序。</param>
            <returns>一个包含读取到的双精度浮点数的序列。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteDouble(System.Double)">
            <summary>
            写入一个双精度浮点数。
            </summary>
            <param name="value">要写入的双精度浮点数。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteDouble(System.Double,TouchSocket.Core.EndianType)">
            <summary>
            按指定字节序写入一个双精度浮点数。
            </summary>
            <param name="value">要写入的双精度浮点数。</param>
            <param name="endianType">指定的字节序。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadInt32">
            <summary>
            读取一个32位整数。
            </summary>
            <returns>读取到的32位整数值。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadInt32(TouchSocket.Core.EndianType)">
            <summary>
            按指定的字节序读取一个32位整数。
            </summary>
            <param name="endianType">指定的字节序类型。</param>
            <returns>读取到的32位整数值。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToInt32s">
            <summary>
            读取一系列32位整数。
            </summary>
            <returns>一系列32位整数值的集合。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToInt32s(TouchSocket.Core.EndianType)">
            <summary>
            按指定的字节序读取一系列32位整数。
            </summary>
            <param name="endianType">指定的字节序类型。</param>
            <returns>一系列32位整数值的集合。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteInt32(System.Int32)">
            <summary>
            写入一个32位整数。
            </summary>
            <param name="value">要写入的32位整数值。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteInt32(System.Int32,TouchSocket.Core.EndianType)">
            <summary>
            按指定的字节序写入一个32位整数。
            </summary>
            <param name="value">要写入的32位整数值。</param>
            <param name="endianType">指定的字节序类型。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadInt16">
            <summary>
            读取一个Int16类型的数据，使用默认的字节序。
            </summary>
            <returns>读取到的Int16数据。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadInt16(TouchSocket.Core.EndianType)">
            <summary>
            按指定字节序读取一个Int16类型的数据。
            </summary>
            <param name="endianType">指定的字节序类型。</param>
            <returns>读取到的Int16数据。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToInt16s">
            <summary>
            读取一系列Int16类型的数据，使用默认的字节序。
            </summary>
            <returns>一系列读取到的Int16数据。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToInt16s(TouchSocket.Core.EndianType)">
            <summary>
            按指定字节序读取一系列Int16类型的数据。
            </summary>
            <param name="endianType">指定的字节序类型。</param>
            <returns>一系列读取到的Int16数据。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteInt16(System.Int16)">
            <summary>
            写入一个Int16类型的数据，使用默认的字节序。
            </summary>
            <param name="value">要写入的Int16数据。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteInt16(System.Int16,TouchSocket.Core.EndianType)">
            <summary>
            按指定字节序写入一个Int16类型的数据。
            </summary>
            <param name="value">要写入的Int16数据。</param>
            <param name="endianType">指定的字节序类型。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadString(TouchSocket.Core.FixedHeaderType)">
            <summary>
            读取一个字符串。
            </summary>
            <param name="headerType">可选的固定头部类型，默认为Int类型。</param>
            <returns>读取到的字符串。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteString(System.String,TouchSocket.Core.FixedHeaderType)">
            <summary>
            写入一个字符串。
            </summary>
            <param name="value">要写入的字符串值。</param>
            <param name="headerType">可选的固定头部类型，默认为Int类型。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadUInt16">
            <summary>
            读取一个无符号16位整数。
            </summary>
            <returns>读取到的无符号16位整数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadUInt16(TouchSocket.Core.EndianType)">
            <summary>
            根据指定的字节顺序读取一个无符号16位整数。
            </summary>
            <param name="endianType">指定的字节顺序。</param>
            <returns>读取到的无符号16位整数。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToUInt16s">
            <summary>
            将输入流中的数据全部转换为无符号16位整数的集合。
            </summary>
            <returns>转换得到的无符号16位整数集合。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ToUInt16s(TouchSocket.Core.EndianType)">
            <summary>
            根据指定的字节顺序，将输入流中的数据全部转换为无符号16位整数的集合。
            </summary>
            <param name="endianType">指定的字节顺序。</param>
            <returns>转换得到的无符号16位整数集合。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteUInt16(System.UInt16)">
            <summary>
            写入一个无符号16位整数。
            </summary>
            <param name="value">要写入的无符号16位整数值。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteUInt16(System.UInt16,TouchSocket.Core.EndianType)">
            <summary>
            根据指定的字节顺序写入一个无符号16位整数。
            </summary>
            <param name="value">要写入的无符号16位整数值。</param>
            <param name="endianType">指定的字节顺序。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadBytesPackage">
            <summary>
            读取字节流数据包。
            </summary>
            <returns>字节数组</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadBytesPackageMemory">
            <summary>
            读取字节流数据包为只读内存。
            </summary>
            <returns>只读内存字节块，可能为null</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteBytesPackage(System.Byte[])">
            <summary>
            写入字节流数据包。
            </summary>
            <param name="value">要写入的字节数组</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteBytesPackage(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从指定偏移量开始写入指定长度的字节流数据包。
            </summary>
            <param name="value">要写入的字节数组</param>
            <param name="offset">从数组中开始写入的索引位置</param>
            <param name="length">要写入的字节数</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadPackage``1">
            <summary>
            读取指定类型的包装对象。
            </summary>
            <typeparam name="TPackage">包装对象的类型，必须是IPackage的实现。</typeparam>
            <returns>返回读取到的包装对象。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WritePackage``1(``0)">
            <summary>
            写入指定类型的包装对象。
            </summary>
            <typeparam name="TPackage">包装对象的类型，必须是IPackage的实现。</typeparam>
            <param name="package">要写入的包装对象。</param>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.ReadVarUInt32">
            <summary>
            读取一个变量长度的无符号32位整数。
            </summary>
            <returns>返回读取到的无符号32位整数值。</returns>
        </member>
        <member name="M:TouchSocket.Core.IByteBlock.WriteVarUInt32(System.UInt32)">
            <summary>
            写入一个变量长度的无符号32位整数。
            </summary>
            <param name="value">要写入的无符号32位整数值。</param>
            <returns>返回写入操作的结果，成功返回0，否则返回-1。</returns>
        </member>
        <member name="T:TouchSocket.Core.IByteBlockBuilder">
            <summary>
            定义了字节块构建器的接口，用于从内存池中构建和管理字节块。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IByteBlockBuilder.MaxLength">
            <summary>
            构建数据时，指示内存池的申请长度。
            <para>
            建议：该值可以尽可能的设置大一些，这样可以避免内存池扩容。
            </para>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IByteBlockBuilder.Build``1(``0@)">
            <summary>
            构建对象到<see cref="T:TouchSocket.Core.ByteBlock"/>
            </summary>
            <param name="byteBlock">要构建的字节块对象引用。</param>
        </member>
        <member name="T:TouchSocket.Core.DynamicMethodMemberAccessor">
            <summary>
            DynamicMethodMemberAccessor
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DynamicMethodMemberAccessor.Default">
            <summary>
            DynamicMethodMemberAccessor的默认实例。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DynamicMethodMemberAccessor.OnGetFieldInfes">
            <summary>
            获取字段
            </summary>
        </member>
        <member name="P:TouchSocket.Core.DynamicMethodMemberAccessor.OnGetProperties">
            <summary>
            获取属性
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DynamicMethodMemberAccessor.GetValue(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.DynamicMethodMemberAccessor.SetValue(System.Object,System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.ExpressionMapper">
            <summary>
            表达式复制
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ExpressionMapper.Trans``2(``0)">
            <summary>
            字典缓存表达式树
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IMemberAccessor">
            <summary>
            一个成员访问接口
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IMemberAccessor.GetValue(System.Object,System.String)">
            <summary>
            获取指定成员的值
            </summary>
            <param name="instance"></param>
            <param name="memberName"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.IMemberAccessor.SetValue(System.Object,System.String,System.Object)">
             <summary>
            设置指定成员的值
             </summary>
             <param name="instance"></param>
             <param name="memberName"></param>
             <param name="newValue"></param>
        </member>
        <member name="T:TouchSocket.Core.InstanceCreater">
            <summary>
            实例生成
            </summary>
        </member>
        <member name="M:TouchSocket.Core.InstanceCreater.Create(System.Type,System.Object[])">
            <summary>
            根据对象类型创建对象实例
            </summary>
            <param name="key">对象类型</param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.Member">
            <summary>
            用于表达式树的成员
            </summary>
        </member>
        <member name="T:TouchSocket.Core.MemberAccessor`1">
            <summary>
            动态成员访问器
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.MemberAccessor`1.#ctor">
            <summary>
            动态成员访问器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.MemberAccessor">
            <summary>
            动态成员访问器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MemberAccessor.#ctor(System.Type)">
            <summary>
            动态成员访问器
            </summary>
            <param name="type"></param>
        </member>
        <member name="P:TouchSocket.Core.MemberAccessor.OnGetFieldInfes">
            <summary>
            获取字段
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MemberAccessor.OnGetProperties">
            <summary>
            获取属性
            </summary>
        </member>
        <member name="P:TouchSocket.Core.MemberAccessor.Type">
            <summary>
            所属类型
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MemberAccessor.Build">
            <summary>
            构建
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MemberAccessor.GetValue(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.MemberAccessor.SetValue(System.Object,System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.MemberGetter">
            <summary>
            表示属性的Getter
            </summary>
        </member>
        <member name="F:TouchSocket.Core.MemberGetter.m_getFunc">
            <summary>
            get方法委托
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MemberGetter.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            表示属性的Getter
            </summary>
            <param name="property">属性</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.MemberGetter.#ctor(System.Reflection.FieldInfo)">
            <summary>
            表示类型字段或属性的Getter
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.MemberGetter.Invoke(System.Object)">
            <summary>
            获取属性的值
            </summary>
            <param name="instance">实例</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.MemberSetter">
            <summary>
            表示属性的设置器
            </summary>
        </member>
        <member name="F:TouchSocket.Core.MemberSetter.setFunc">
            <summary>
            set方法委托
            </summary>
        </member>
        <member name="M:TouchSocket.Core.MemberSetter.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            表示属性的Getter
            </summary>
            <param name="property">属性</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.MemberSetter.Invoke(System.Object,System.Object)">
            <summary>
            设置属性的值
            </summary>
            <param name="instance">实例</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.TaskReturnType">
            <summary>
            Task类型
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TaskReturnType.None">
            <summary>
            没有Task
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TaskReturnType.Task">
            <summary>
            仅返回Task
            </summary>
        </member>
        <member name="F:TouchSocket.Core.TaskReturnType.TaskObject">
            <summary>
            返回Task的值
            </summary>
        </member>
        <member name="T:TouchSocket.Core.Method">
            <summary>
            一个动态调用方法
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Method.m_invoker">
            <summary>
            方法执行委托
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Method.#ctor(System.Reflection.MethodInfo)">
            <summary>
            初始化一个动态调用方法
            </summary>
            <param name="method"></param>
        </member>
        <member name="M:TouchSocket.Core.Method.#ctor(System.Reflection.MethodInfo,System.Boolean)">
            <summary>
            初始化一个动态调用方法
            </summary>
            <param name="method">方法信息</param>
            <param name="build">是否直接使用IL构建调用</param>
        </member>
        <member name="P:TouchSocket.Core.Method.HasReturn">
            <summary>
            是否具有返回值。当返回值为Task时，也会认为没有返回值。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Method.Info">
            <summary>
            方法信息
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Method.HasByRef">
            <summary>
            是否有引用类型
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Method.Name">
            <summary>
            获取方法名
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Method.ReturnType">
            <summary>
            返回值类型。
            <para>当方法为void或task时，为null</para>
            <para>当方法为task泛型时，为泛型元素类型</para>
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Method.TaskType">
            <summary>
            返回值的Task类型。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Method.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.Method.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.Method.Invoke(System.Object,System.Object[])">
            <summary>
            执行方法。
            </summary>
            <param name="instance">实例</param>
            <param name="parameters">参数</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Method.InvokeAsync(System.Object,System.Object[])">
            <summary>
            异步调用
            </summary>
            <param name="instance"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Method.InvokeAsync``1(System.Object,System.Object[])">
            <summary>
            调用异步结果
            </summary>
            <param name="instance"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Method.InvokeObjectAsync(System.Object,System.Object[])">
            <summary>
            执行方法。
            <para>当方法为void或task时，会异常</para>
            <para>当方法为task泛型时，会await后的值</para>
            <para>支持调用方为UI主线程。</para>
            </summary>
            <param name="instance">实例</param>
            <param name="parameters">参数</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Method.CreateExpressionInvoker(System.Reflection.MethodInfo)">
            <summary>
            构建表达式树调用
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Method.CreateILInvoker(System.Reflection.MethodInfo)">
            <summary>
            构建IL调用
            </summary>
            <param name="methodInfo"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.Property">
            <summary>
            表示属性
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Property.m_cached">
            <summary>
            类型属性的Setter缓存
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Property.m_geter">
            <summary>
            获取器
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Property.m_seter">
            <summary>
            设置器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Property.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            属性
            </summary>
            <param name="property">属性信息</param>
        </member>
        <member name="P:TouchSocket.Core.Property.CanRead">
            <summary>
            是否可以读取
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Property.CanWrite">
            <summary>
            是否可以写入
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Property.Info">
            <summary>
            获取属性信息
            </summary>
        </member>
        <member name="P:TouchSocket.Core.Property.Name">
            <summary>
            获取属性名称
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Property.GetProperties(System.Type)">
            <summary>
            从类型的属性获取属性
            </summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Property.GetValue(System.Object)">
            <summary>
            获取属性的值
            </summary>
            <param name="instance">实例</param>
            <exception cref="T:System.NotSupportedException"></exception>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.Property.SetValue(System.Object,System.Object)">
            <summary>
            设置属性的值
            </summary>
            <param name="instance">实例</param>
            <param name="value">值</param>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="T:TouchSocket.Core.IResult">
            <summary>
            表示结果的接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IResult.ResultCode">
            <summary>
            结果代码
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IResult.Message">
            <summary>
            结果附加消息
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IResult.IsSuccess">
            <summary>
            是否成功。一般的当<see cref="P:TouchSocket.Core.IResult.ResultCode"/>为<see cref="F:TouchSocket.Core.ResultCode.Success"/>时会返回<see langword="true"/>。其余情况返回<see langword="false"/>
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IResult`1">
            <summary>
            泛型接口<see cref="T:TouchSocket.Core.IResult`1"/>，继承自<see cref="T:TouchSocket.Core.IResult"/>。
            用于定义具有特定类型结果值的对象所需的行为。
            </summary>
            <typeparam name="T">结果值的类型。</typeparam>
        </member>
        <member name="P:TouchSocket.Core.IResult`1.Value">
            <summary>
            获取结果值。
            </summary>
            <value>结果值，类型为 T。</value>
        </member>
        <member name="T:TouchSocket.Core.Result">
            <summary>
            结果返回
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Result.Success">
            <summary>
            成功
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Result.Default">
            <summary>
            初始状态
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Result.UnknownFail">
            <summary>
            未知失败
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Result.Overtime">
            <summary>
            超时
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Result.Canceled">
            <summary>
            取消
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Result.#ctor(TouchSocket.Core.ResultCode,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="resultCode">结果代码，表示操作的结果</param>
            <param name="message">消息，提供操作结果的详细描述</param>
        </member>
        <member name="M:TouchSocket.Core.Result.#ctor(TouchSocket.Core.IResult)">
            <summary>
            构造函数
            </summary>
            <param name="result">传入的结果对象，用于初始化当前结果对象的属性</param>
        </member>
        <member name="M:TouchSocket.Core.Result.#ctor(System.Exception)">
            <summary>
            构造函数
            </summary>
            <param name="exception">异常对象，用于提取错误信息</param>
        </member>
        <member name="M:TouchSocket.Core.Result.#ctor(TouchSocket.Core.ResultCode)">
            <summary>
            构造函数
            </summary>
            <param name="resultCode">结果代码，用于指定结果的状态</param>
        </member>
        <member name="P:TouchSocket.Core.Result.ResultCode">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.Result.Message">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.Result.IsSuccess">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.Result.FromCanceled(System.String)">
            <summary>
            创建来自<see cref="F:TouchSocket.Core.ResultCode.Canceled"/>的<see cref="T:TouchSocket.Core.Result"/>
            </summary>
            <param name="msg">关联的消息</param>
            <returns>创建的Result对象</returns>
        </member>
        <member name="M:TouchSocket.Core.Result.FromError(System.String)">
            <summary>
            创建来自<see cref="F:TouchSocket.Core.ResultCode.Error"/>的<see cref="T:TouchSocket.Core.Result"/>
            </summary>
            <param name="msg">关联的消息</param>
            <returns>创建的Result对象</returns>
        </member>
        <member name="M:TouchSocket.Core.Result.FromException(System.String)">
            <summary>
            创建来自<see cref="F:TouchSocket.Core.ResultCode.Exception"/>的<see cref="T:TouchSocket.Core.Result"/>
            </summary>
            <param name="msg">关联的消息</param>
            <returns>创建的Result对象</returns>
        </member>
        <member name="M:TouchSocket.Core.Result.FromException(System.Exception)">
            <summary>
            根据异常生成结果对象
            </summary>
            <param name="ex">异常对象</param>
            <returns>包含异常信息的结果对象</returns>
        </member>
        <member name="M:TouchSocket.Core.Result.FromFail(System.String)">
            <summary>
            创建来自<see cref="F:TouchSocket.Core.ResultCode.Fail"/>的<see cref="T:TouchSocket.Core.Result"/>
            </summary>
            <param name="msg">关联的消息</param>
            <returns>创建的Result对象</returns>
        </member>
        <member name="M:TouchSocket.Core.Result.FromOvertime(System.String)">
            <summary>
            创建来自<see cref="F:TouchSocket.Core.ResultCode.Overtime"/>的<see cref="T:TouchSocket.Core.Result"/>
            </summary>
            <param name="msg">关联的消息</param>
            <returns>创建的Result对象</returns>
        </member>
        <member name="M:TouchSocket.Core.Result.FromSuccess(System.String)">
            <summary>
            创建来自<see cref="F:TouchSocket.Core.ResultCode.Success"/>的<see cref="T:TouchSocket.Core.Result"/>
            </summary>
            <param name="msg">关联的消息</param>
            <returns>创建的Result对象</returns>
        </member>
        <member name="M:TouchSocket.Core.Result.ToString">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.ResultBase">
            <summary>
            结果返回
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ResultBase.#ctor(TouchSocket.Core.ResultCode,System.String)">
            <summary>
            初始化 ResultBase 类的新实例。
            </summary>
            <param name="resultCode">结果代码，表示操作的结果。</param>
            <param name="message">消息，提供有关操作结果的详细信息。</param>
        </member>
        <member name="M:TouchSocket.Core.ResultBase.#ctor(TouchSocket.Core.ResultCode)">
            <summary>
            初始化 ResultBase 类的新实例。
            </summary>
            <param name="resultCode">结果代码，表示操作的结果。</param>
        </member>
        <member name="M:TouchSocket.Core.ResultBase.#ctor(TouchSocket.Core.Result)">
            <summary>
            初始化 ResultBase 类的新实例。
            </summary>
            <param name="result">要复制其属性值的 Result 对象。</param>
        </member>
        <member name="M:TouchSocket.Core.ResultBase.#ctor">
            <summary>
            ResultBase 类的构造函数。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ResultBase.ResultCode">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ResultBase.Message">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.ResultBase.IsSuccess">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ResultBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.ResultExtensions">
            <summary>
            ResultExtensions
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ResultExtensions.IsSuccess(TouchSocket.Core.IResult)">
            <summary>
            是否成功。
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ResultExtensions.NotSuccess(TouchSocket.Core.IResult)">
            <summary>
            是否没有成功。
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ResultExtensions.ToResult(TouchSocket.Core.IResult)">
            <summary>
            转换为<see cref="T:TouchSocket.Core.Result"/>
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.Result`1">
            <summary>
            表示一个结构化的操作结果，包含操作的返回值、结果代码和消息。
            </summary>
            <typeparam name="T">结果值的类型。</typeparam>
        </member>
        <member name="F:TouchSocket.Core.Result`1.m_message">
            <summary>
            结果消息，提供操作的描述信息。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Result`1.m_resultCode">
            <summary>
            结果代码，用于表示操作的状态。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.Result`1.m_value">
            <summary>
            结果值。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Result`1.#ctor(`0,TouchSocket.Core.ResultCode,System.String)">
            <summary>
            初始化<see cref="T:TouchSocket.Core.Result`1"/>结构。
            </summary>
            <param name="value">操作的返回值。</param>
            <param name="resultCode">结果代码，表示操作的状态。</param>
            <param name="message">结果消息，提供操作的描述信息。</param>
        </member>
        <member name="M:TouchSocket.Core.Result`1.#ctor(TouchSocket.Core.ResultCode,System.String)">
            <summary>
            初始化<see cref="T:TouchSocket.Core.Result`1"/>结构，使用默认值作为结果值。
            </summary>
            <param name="code">结果代码，表示操作的状态。</param>
            <param name="message">结果消息，提供操作的描述信息。</param>
        </member>
        <member name="M:TouchSocket.Core.Result`1.#ctor(TouchSocket.Core.ResultCode)">
            <summary>
            初始化<see cref="T:TouchSocket.Core.Result`1"/>结构，使用结果代码的描述作为消息。
            </summary>
            <param name="code">结果代码，表示操作的状态。</param>
        </member>
        <member name="M:TouchSocket.Core.Result`1.#ctor(System.Exception)">
            <summary>
            初始化<see cref="T:TouchSocket.Core.Result`1"/>结构，将异常信息作为结果消息。
            </summary>
            <param name="exception">发生的异常。</param>
        </member>
        <member name="M:TouchSocket.Core.Result`1.#ctor(`0)">
            <summary>
            初始化<see cref="T:TouchSocket.Core.Result`1"/>结构，使用成功作为结果代码和消息。
            </summary>
            <param name="value">操作的返回值。</param>
        </member>
        <member name="P:TouchSocket.Core.Result`1.IsSuccess">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.Result`1.Message">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.Result`1.ResultCode">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.Result`1.Value">
            <summary>
            获取结果值。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.Result`1.op_Implicit(`0)~TouchSocket.Core.Result{`0}">
            <summary>
            隐式类型转换操作符，将值类型<typeparamref name="T"/>转换为<see cref="T:TouchSocket.Core.Result`1"/>类型。
            </summary>
            <param name="value">要转换的值。</param>
            <returns>一个新的<see cref="T:TouchSocket.Core.Result`1"/>实例，值为提供的值，结果代码和消息为成功。</returns>
        </member>
        <member name="M:TouchSocket.Core.Result`1.op_Implicit(TouchSocket.Core.Result)~TouchSocket.Core.Result{`0}">
            <summary>
            隐式转换运算符，将<see cref="T:TouchSocket.Core.Result"/>类型转换为<see cref="T:TouchSocket.Core.Result`1"/>类型。
            </summary>
            <param name="result">原始的<see cref="T:TouchSocket.Core.Result"/>对象。</param>
            <returns>转换后的<see cref="T:TouchSocket.Core.Result`1"/>对象，其中T为泛型参数。</returns>
        </member>
        <member name="M:TouchSocket.Core.Result`1.op_Explicit(TouchSocket.Core.Result{`0})~TouchSocket.Core.Result">
            <summary>
            显式转换运算符，将ResultT类型的对象转换为Result类型的对象。
            </summary>
            <param name="result">要转换的ResultT对象。</param>
            <returns>转换后的Result对象，包含了原ResultT对象的结果码和消息。</returns>
        </member>
        <member name="T:TouchSocket.Core.LoopAction">
            <summary>
            LoopAction 类用于在指定循环次数和间隔下执行异步操作。
            它支持暂停、恢复和重新运行操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LoopAction.m_waitHandle">
            <summary>
            异步自动重置事件，用于控制循环执行的同步点。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.LoopAction.m_executeAction">
            <summary>
            执行操作的委托，接受 LoopAction 实例作为参数。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.#ctor(System.Int32,System.TimeSpan,System.Func{TouchSocket.Core.LoopAction,System.Threading.Tasks.Task})">
            <summary>
            初始化 LoopAction 实例。
            </summary>
            <param name="count">循环执行次数，-1 表示无限循环。</param>
            <param name="interval">两次执行操作之间的间隔时间。</param>
            <param name="action">要执行的异步操作。</param>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.CreateLoopAction(System.Int32,System.TimeSpan,System.Action{TouchSocket.Core.LoopAction})">
            <summary>
            创建并返回一个 LoopAction 实例，该实例将在指定次数和间隔下执行给定的异步操作。
            </summary>
            <param name="count">循环执行次数。</param>
            <param name="interval">两次执行操作之间的间隔时间。</param>
            <param name="action">要执行的异步操作。</param>
            <returns>一个新的 LoopAction 实例。</returns>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.CreateLoopAction(System.Int32,System.Int32,System.Action{TouchSocket.Core.LoopAction})">
            <summary>
            创建并返回一个 LoopAction 实例，该实例将在指定次数和以毫秒为单位的间隔下执行给定的异步操作。
            </summary>
            <param name="count">循环执行次数。</param>
            <param name="intervalMS">两次执行操作之间的间隔时间（毫秒）。</param>
            <param name="action">要执行的异步操作。</param>
            <returns>一个新的 LoopAction 实例。</returns>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.CreateLoopAction(System.Int32,System.Action{TouchSocket.Core.LoopAction})">
            <summary>
            创建并返回一个 LoopAction 实例，该实例将在指定次数和无间隔下执行给定的异步操作。
            </summary>
            <param name="count">循环执行次数。</param>
            <param name="action">要执行的异步操作。</param>
            <returns>一个新的 LoopAction 实例。</returns>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.CreateLoopAction(System.TimeSpan,System.Action{TouchSocket.Core.LoopAction})">
            <summary>
            创建并返回一个 LoopAction 实例，该实例将在无限次数和指定间隔下执行给定的异步操作。
            </summary>
            <param name="interval">两次执行操作之间的间隔时间。</param>
            <param name="action">要执行的异步操作。</param>
            <returns>一个新的 LoopAction 实例。</returns>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.CreateLoopAction(System.Action{TouchSocket.Core.LoopAction})">
            <summary>
            创建并返回一个 LoopAction 实例，该实例将在无限次数和无间隔下执行给定的异步操作。
            </summary>
            <param name="action">要执行的异步操作。</param>
            <returns>一个新的 LoopAction 实例。</returns>
        </member>
        <member name="P:TouchSocket.Core.LoopAction.ExecutedCount">
            <summary>
            已执行次数。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.LoopAction.Interval">
            <summary>
            执行间隔。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.LoopAction.LoopCount">
            <summary>
            循环次数。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.LoopAction.RunStatus">
            <summary>
            是否在运行。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.Run">
            <summary>
            运行 LoopAction 实例，如果已运行则不执行任何操作。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.Rerun">
            <summary>
            重新运行 LoopAction 实例，重置已执行次数和运行状态。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.RerunAsync">
            <summary>
            以异步方式重新运行 LoopAction 实例。
            </summary>
            <returns>异步操作任务。</returns>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.RunAsync">
            <summary>
            以异步方式运行 LoopAction 实例。
            </summary>
            <returns>异步操作任务。</returns>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.Pause">
            <summary>
            暂停正在运行的 LoopAction 实例。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.Resume">
            <summary>
            恢复已暂停的 LoopAction 实例。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.LoopAction.Dispose(System.Boolean)">
            <summary>
            处置 LoopAction 实例，释放所有资源。
            </summary>
            <param name="disposing">是否为托管资源。</param>
        </member>
        <member name="T:TouchSocket.Core.RunStatus">
            <summary>
            运行状态
            </summary>
        </member>
        <member name="F:TouchSocket.Core.RunStatus.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:TouchSocket.Core.RunStatus.Running">
            <summary>
            Running
            </summary>
        </member>
        <member name="F:TouchSocket.Core.RunStatus.Completed">
            <summary>
            Completed
            </summary>
        </member>
        <member name="F:TouchSocket.Core.RunStatus.Paused">
            <summary>
            Pause
            </summary>
        </member>
        <member name="F:TouchSocket.Core.RunStatus.Disposed">
            <summary>
            Disposed
            </summary>
        </member>
        <member name="T:TouchSocket.Core.SingleTimer">
            <summary>
            不可重入的Timer
            </summary>
        </member>
        <member name="P:TouchSocket.Core.SingleTimer.Pause">
            <summary>
            是否暂停执行。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.SingleTimer.Count">
            <summary>
            自启动以来执行的次数。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.Int32,System.Action)">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.TimeSpan,System.Action)">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.Int32,System.Action{TouchSocket.Core.SingleTimer})">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.Int32,System.Action{TouchSocket.Core.SingleTimer,System.Object})">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.Object,System.TimeSpan,System.Action{TouchSocket.Core.SingleTimer})">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="state"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.Object,System.TimeSpan,System.Action{TouchSocket.Core.SingleTimer,System.Object})">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="state"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.Object,System.Int32,System.Action{TouchSocket.Core.SingleTimer})">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="state"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.#ctor(System.Object,System.Int32,System.Action{TouchSocket.Core.SingleTimer,System.Object})">
            <summary>
            不可重入的Timer
            </summary>
            <param name="action"></param>
            <param name="state"></param>
            <param name="period"></param>
        </member>
        <member name="M:TouchSocket.Core.SingleTimer.Dispose(System.Boolean)">
            <inheritdoc/>
            <param name="disposing"></param>
        </member>
        <member name="T:TouchSocket.Core.FastConverterAttribute">
            <summary>
            FastConverterAttribute
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FastConverterAttribute.#ctor(System.Type)">
            <summary>
            FastConverterAttribute
            </summary>
            <param name="type"></param>
        </member>
        <member name="P:TouchSocket.Core.FastConverterAttribute.Type">
            <summary>
            转化器类型。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.FastMemberAttribute">
            <summary>
            标识Fast序列化成员编号。以此来代替属性、字段名。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FastMemberAttribute.Index">
            <summary>
            索引号
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FastMemberAttribute.#ctor(System.Byte)">
            <summary>
            标识Fast序列化成员编号。以此来代替属性、字段名。
            </summary>
            <param name="index">最大支持255个成员</param>
        </member>
        <member name="T:TouchSocket.Core.FastNonSerializedAttribute">
            <summary>
            忽略的Fast序列化
            </summary>
        </member>
        <member name="T:TouchSocket.Core.FastSerializedAttribute">
            <summary>
            显式Fast序列化。一般当某个属性为只读时，使用该特性。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FastSerializedAttribute.EnableIndex">
            <summary>
            使用索引替代属性名称。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.MetadataFastBinaryConverter">
            <summary>
            MetadataFastBinaryConverter
            </summary>
        </member>
        <member name="T:TouchSocket.Core.FastBinaryFormatter">
            <summary>
            快速二进制序列化。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.FastBinaryFormatter.DynamicallyAccessed">
            <summary>
            定义一个常量，指定动态访问的成员类型，包括公共构造函数、方法、字段和属性。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.FastBinaryFormatter.s_defaultFastSerializerContext">
            <summary>
            初始化一个默认的快速序列化上下文对象，用于支持快速序列化操作。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.FastBinaryFormatter.DefaultFastSerializerContext">
            <summary>
            获取默认的快速序列化上下文。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.AddFastBinaryConverter``2">
            <summary>
            添加一个新的快速二进制转换器，该转换器由指定的泛型参数提供。
            </summary>
            <typeparam name="TType">要序列化的类型。</typeparam>
            <typeparam name="TConverter">转换器类型，必须实现 <see cref="T:TouchSocket.Core.IFastBinaryConverter"/> 接口。</typeparam>
            <remarks>
            [DynamicallyAccessedMembers(DynamicallyAccessed)] 特性确保类型和转换器在反射时可被动态访问。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.AddFastBinaryConverter``1(TouchSocket.Core.IFastBinaryConverter)">
            <summary>
            为指定类型添加一个快速二进制转换器。
            </summary>
            <typeparam name="TType">要序列化的类型。</typeparam>
            <param name="converter">要添加的转换器，必须实现 <see cref="T:TouchSocket.Core.IFastBinaryConverter"/> 接口。</param>
            <remarks>
            [DynamicallyAccessedMembers(DynamicallyAccessed)] 特性确保类型在反射时可被动态访问。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.AddFastBinaryConverter(System.Type,TouchSocket.Core.IFastBinaryConverter)">
            <summary>
            为指定类型添加一个快速二进制转换器。
            </summary>
            <param name="type">要序列化的类型。</param>
            <param name="converter">要添加的转换器，必须实现 <see cref="T:TouchSocket.Core.IFastBinaryConverter"/> 接口。</param>
            <remarks>
            [DynamicallyAccessedMembers(DynamicallyAccessed)] 特性确保类型在反射时可被动态访问。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.Serialize``1(TouchSocket.Core.ByteBlock,``0@,TouchSocket.Core.FastSerializerContext)">
            <summary>
            序列化给定对象并将其写入字节块。
            </summary>
            <param name="byteBlock">用于存储序列化数据的字节块。</param>
            <param name="graph">要序列化的对象。</param>
            <param name="serializerContext">（可选）序列化上下文，提供额外的序列化设置或上下文。</param>
            <typeparam name="T">要序列化的对象类型。</typeparam>
            <remarks>
            此方法提供了一种便捷的方式来序列化对象至字节块，利用提供的序列化上下文进行序列化过程。
            </remarks>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.Serialize``2(``0@,``1@,TouchSocket.Core.FastSerializerContext)">
            <summary>
            使用指定的序列化上下文将对象序列化到提供的字节块中。
            </summary>
            <typeparam name="TByteBlock">字节块的类型，必须实现IByteBlock接口。</typeparam>
            <typeparam name="T">要序列化的对象类型。</typeparam>
            <param name="byteBlock">用于存储序列化数据的字节块。</param>
            <param name="graph">要序列化的对象。</param>
            <param name="serializerContext">用于序列化的上下文。</param>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.SerializeToBytes``1(``0@,TouchSocket.Core.FastSerializerContext)">
            <summary>
            使用指定的序列化上下文将对象序列化为字节数组。
            </summary>
            <typeparam name="T">要序列化的对象类型。</typeparam>
            <param name="graph">要序列化的对象。</param>
            <param name="serializerContext">用于序列化的上下文。</param>
            <returns>序列化后的字节数组。</returns>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.Deserialize``1(TouchSocket.Core.ByteBlock,TouchSocket.Core.FastSerializerContext)">
            <summary>
            反序列化字节块为指定类型的对象。
            </summary>
            <param name="byteBlock">包含待反序列化数据的字节块。</param>
            <param name="serializerContext">（可选）快速序列化上下文，用于优化性能。</param>
            <typeparam name="T">要反序列化为的类型。</typeparam>
            <returns>反序列化后的对象。</returns>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.Deserialize``1(TouchSocket.Core.ValueByteBlock@,TouchSocket.Core.FastSerializerContext)">
            <summary>
            反序列化字节块为指定类型。
            </summary>
            <param name="byteBlock">包含待反序列化数据的字节块。</param>
            <param name="serializerContext">（可选）序列化上下文，用于控制序列化行为。</param>
            <typeparam name="T">要反序列化的类型，该类型标记有[DynamicallyAccessedMembers]特性，表示在运行时会动态访问其成员。</typeparam>
            <returns>反序列化后的对象。</returns>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.Deserialize``1(System.Byte[],TouchSocket.Core.FastSerializerContext)">
            <summary>
            将字节数组反序列化为指定类型的实例。
            </summary>
            <param name="bytes">包含已序列化数据的字节数组。</param>
            <param name="serializerContext">（可选）用于序列化和反序列化过程的上下文对象。</param>
            <typeparam name="T">要反序列化的目标类型。</typeparam>
            <returns>反序列化后的目标类型实例。</returns>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.Deserialize``2(``0@,TouchSocket.Core.FastSerializerContext)">
            <summary>
            使用指定的序列化上下文从字节块中反序列化出指定类型的对象。
            </summary>
            <typeparam name="TByteBlock">实现IByteBlock接口的类型，用于读取字节数据。</typeparam>
            <typeparam name="T">要反序列化为的类型。</typeparam>
            <param name="byteBlock">包含序列化数据的字节块。</param>
            <param name="serializerContext">用于反序列化的FastSerializerContext实例。</param>
            <returns>反序列化后的对象。</returns>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryFormatter.Deserialize``1(``0@,System.Type,TouchSocket.Core.FastSerializerContext)">
            <summary>
            使用指定的序列化上下文从字节块中反序列化对象。
            </summary>
            <typeparam name="TByteBlock">实现IByteBlock接口的类型，用于读取字节数据。</typeparam>
            <param name="byteBlock">包含序列化数据的字节块。</param>
            <param name="type">要反序列化为的类型。</param>
            <param name="serializerContext">用于反序列化的FastSerializerContext实例。</param>
            <returns>反序列化后的对象。</returns>
        </member>
        <member name="T:TouchSocket.Core.IFastBinaryConverter">
            <summary>
            定义了快速二进制转换器的接口，用于将对象转换为字节块，反之亦然。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IFastBinaryConverter.Read``1(``0@,System.Type)">
            <summary>
            从字节块中读取对象。
            </summary>
            <param name="byteBlock">包含对象数据的字节块。</param>
            <param name="type">要读取的对象的类型。</param>
            <typeparam name="TByteBlock">字节块的类型，实现了IByteBlock接口。</typeparam>
            <returns>从字节块中读取的对象实例。</returns>
        </member>
        <member name="M:TouchSocket.Core.IFastBinaryConverter.Write``1(``0@,System.Object@)">
            <summary>
            将对象写入字节块。
            </summary>
            <param name="byteBlock">将要包含对象数据的字节块。</param>
            <param name="obj">要写入的对象实例。</param>
            <typeparam name="TByteBlock">字节块的类型，实现了IByteBlock接口。</typeparam>
        </member>
        <member name="T:TouchSocket.Core.FastBinaryConverter`1">
            <summary>
            提供了一个抽象类，实现了IFastBinaryConverter接口，用于快速二进制转换。
            </summary>
            <typeparam name="T">具体实现类的类型参数。</typeparam>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryConverter`1.TouchSocket#Core#IFastBinaryConverter#Read``1(``0@,System.Type)">
            <summary>
            通过此实现从字节块中读取对象。
            </summary>
            <param name="byteBlock">包含对象数据的字节块。</param>
            <param name="type">要读取的对象的类型。</param>
            <typeparam name="TByteBlock">字节块的类型，实现了IByteBlock接口。</typeparam>
            <returns>从字节块中读取的对象实例。</returns>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryConverter`1.TouchSocket#Core#IFastBinaryConverter#Write``1(``0@,System.Object@)">
            <summary>
            通过此实现将对象写入字节块。
            </summary>
            <param name="byteBlock">将要包含对象数据的字节块。</param>
            <param name="obj">要写入的对象实例。</param>
            <typeparam name="TByteBlock">字节块的类型，实现了IByteBlock接口。</typeparam>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryConverter`1.Read``1(``0@,System.Type)">
            <summary>
            从字节块中读取对象。必须由具体实现类实现。
            </summary>
            <param name="byteBlock">包含对象数据的字节块。</param>
            <param name="type">要读取的对象的类型。</param>
            <typeparam name="TByteBlock">字节块的类型，实现了IByteBlock接口。</typeparam>
            <returns>从字节块中读取的对象实例。</returns>
        </member>
        <member name="M:TouchSocket.Core.FastBinaryConverter`1.Write``1(``0@,`0@)">
            <summary>
            将对象写入字节块。必须由具体实现类实现。
            </summary>
            <param name="byteBlock">将要包含对象数据的字节块。</param>
            <param name="obj">要写入的对象实例。</param>
            <typeparam name="TByteBlock">字节块的类型，实现了IByteBlock接口。</typeparam>
        </member>
        <member name="T:TouchSocket.Core.SerializationType">
            <summary>
            序列化类型
            </summary>
        </member>
        <member name="F:TouchSocket.Core.SerializationType.FastBinary">
            <summary>
            内置快速二进制
            </summary>
        </member>
        <member name="F:TouchSocket.Core.SerializationType.Json">
            <summary>
            Json
            </summary>
        </member>
        <member name="F:TouchSocket.Core.SerializationType.SystemBinary">
            <summary>
            系统二进制。微软认为这是不安全的，所以谨慎使用。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.DefaultFastSerializerContext.AddFastBinaryConverter(System.Type,TouchSocket.Core.IFastBinaryConverter)">
            <summary>
            添加转换器。
            </summary>
            <param name="type"></param>
            <param name="converter"></param>
        </member>
        <member name="T:TouchSocket.Core.FastSerializerContext">
            <summary>
            快速序列化上下文
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FastSerializerContext.#ctor">
            <summary>
            快速序列化上下文
            </summary>
        </member>
        <member name="M:TouchSocket.Core.FastSerializerContext.GetNewInstance(System.Type)">
            <summary>
            获取新实例
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FastSerializerContext.GetSerializeObject(System.Type)">
            <summary>
            获取序列化对象
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.FastSerializerContext.AddConverter(System.Type,TouchSocket.Core.IFastBinaryConverter)">
            <summary>
            添加转换器
            </summary>
            <param name="type"></param>
            <param name="converter"></param>
        </member>
        <member name="T:TouchSocket.Core.SerializObject">
            <summary>
            可序列化对象
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SerializObject.#ctor(System.Type,TouchSocket.Core.IFastBinaryConverter)">
            <summary>
            从转换器初始化
            </summary>
            <param name="type"></param>
            <param name="converter"></param>
        </member>
        <member name="M:TouchSocket.Core.SerializObject.#ctor(System.Type)">
            <summary>
            从类型创建序列化器
            </summary>
            <param name="type"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="P:TouchSocket.Core.SerializObject.Converter">
            <summary>
            转化器
            </summary>
        </member>
        <member name="P:TouchSocket.Core.SerializObject.Type">
            <summary>
            类型
            </summary>
        </member>
        <member name="T:TouchSocket.Core.SerializeConvert">
            <summary>
            高性能序列化器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinarySerialize(System.Object@)">
            <summary>
            普通二进制序列化对象
            </summary>
            <param name="obj">数据对象</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinarySerializeToFile(System.Object@,System.String)">
            <summary>
            二进制序列化对象至文件
            </summary>
            <param name="obj">数据对象</param>
            <param name="path">路径</param>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinarySerialize(System.IO.Stream,System.Object@)">
            <summary>
            二进制序列化对象
            </summary>
            <param name="stream"></param>
            <param name="obj"></param>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinaryDeserialize``1(System.Byte[],System.Int32,System.Int32,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            从Byte[]中反序列化
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="binder"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinaryDeserialize(System.Byte[],System.Int32,System.Int32,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            反序列化
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="binder"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinaryDeserialize``1(System.IO.Stream,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            从Stream中反序列化
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stream"></param>
            <param name="binder"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinaryDeserialize(System.IO.Stream,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            从流中反序列化对象。
            </summary>
            <param name="stream">包含序列化对象数据的流。</param>
            <param name="binder">可选的绑定器，用于控制反序列化过程中的类型绑定。</param>
            <returns>反序列化后的对象。</returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinaryDeserializeFromFile``1(System.String)">
            <summary>
            将二进制文件数据反序列化为指定类型对象
            </summary>
            <typeparam name="T"></typeparam>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinaryDeserialize``1(System.Byte[])">
            <summary>
            将二进制数据反序列化为指定类型对象
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.BinaryDeserialize``1(System.Byte[],System.Runtime.Serialization.SerializationBinder)">
            <summary>
            从Byte[]中反序列化
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="binder"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlSerializeToString(System.Object,System.Text.Encoding)">
            <summary>
            Xml序列化数据对象
            </summary>
            <param name="obj">数据对象</param>
            <param name="encoding">编码格式</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlSerializeToString(System.Object)">
            <summary>
            Xml序列化数据对象
            </summary>
            <param name="obj">数据对象</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlSerializeToBytes(System.Object)">
            <summary>
            Xml序列化数据对象
            </summary>
            <param name="obj">数据对象</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlSerializeToFile(System.Object,System.String)">
            <summary>
            Xml序列化至文件
            </summary>
            <param name="obj"></param>
            <param name="path"></param>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlDeserializeFromBytes``1(System.Byte[])">
            <summary>
            Xml反序列化
            </summary>
            <typeparam name="T">反序列化类型</typeparam>
            <param name="dataBytes">数据</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlDeserializeFromBytes(System.Byte[],System.Type)">
            <summary>
            Xml反序列化
            </summary>
            <param name="dataBytes"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlDeserializeFromStream(System.IO.Stream,System.Type)">
            <summary>
            Xml反序列化
            </summary>
            <param name="xmlStream"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlDeserializeFromStream``1(System.IO.Stream)">
            <summary>
            Xml反序列化
            </summary>
            <typeparam name="T"></typeparam>
            <param name="xmlStream"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlDeserializeFromString(System.String,System.Type)">
            <summary>
            Xml反序列化
            </summary>
            <param name="xmlString">xml字符串</param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlDeserializeFromString``1(System.String)">
            <summary>
            Xml反序列化
            </summary>
            <typeparam name="T"></typeparam>
            <param name="xmlString"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.XmlDeserializeFromFile``1(System.String)">
            <summary>
            Xml反序列化
            </summary>
            <typeparam name="T">反序列化类型</typeparam>
            <param name="path">文件路径</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.ToJsonString(System.Object)">
            <summary>
            转换为Json
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.FromJsonString(System.String,System.Type)">
            <summary>
            从字符串到json
            </summary>
            <param name="json"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.FromJsonString``1(System.String)">
            <summary>
            从字符串到json
            </summary>
            <typeparam name="T"></typeparam>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.JsonSerializeToBytes(System.Object)">
            <summary>
            Json序列化数据对象
            </summary>
            <param name="obj">数据对象</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.JsonSerializeToFile(System.Object,System.String)">
            <summary>
            Json序列化至文件
            </summary>
            <param name="obj"></param>
            <param name="path"></param>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.JsonDeserializeFromBytes``1(System.Byte[])">
            <summary>
            Json反序列化
            </summary>
            <typeparam name="T">反序列化类型</typeparam>
            <param name="dataBytes">数据</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.JsonDeserializeFromBytes(System.Byte[],System.Type)">
            <summary>
            Xml反序列化
            </summary>
            <param name="dataBytes"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.JsonDeserializeFromString``1(System.String)">
            <summary>
            Json反序列化
            </summary>
            <typeparam name="T">类型</typeparam>
            <param name="json">json字符串</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.SerializeConvert.JsonDeserializeFromFile``1(System.String)">
            <summary>
            Json反序列化
            </summary>
            <typeparam name="T">反序列化类型</typeparam>
            <param name="path">文件路径</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.BytesSerializerConverter`1">
            <summary>
            字节类转换器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.BytesSerializerConverter">
            <summary>
            字节类转换器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ISerializerFormatter`2">
            <summary>
            转换器接口
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ISerializerFormatter`2.Order">
            <summary>
            转换器执行顺序
            <para>该属性值越小，越靠前执行。值相等时，按添加先后顺序</para>
            <para>该属性效果，仅在<see cref="M:TouchSocket.Core.TouchSocketSerializerConverter`2.Add(TouchSocket.Core.ISerializerFormatter{`0,`1})"/>之前设置有效。</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ISerializerFormatter`2.TryDeserialize(`1,`0@,System.Type,System.Object@)">
            <summary>
            尝试将源数据转换目标类型对象
            </summary>
            <param name="state"></param>
            <param name="source"></param>
            <param name="targetType"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.ISerializerFormatter`2.TrySerialize(`1,System.Object@,`0@)">
            <summary>
            尝试将目标类型对象转换源数据
            </summary>
            <param name="state"></param>
            <param name="target"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.JsonBytesToClassSerializerFormatter`1">
            <summary>
            Json字节转到对应类
            </summary>
        </member>
        <member name="P:TouchSocket.Core.JsonBytesToClassSerializerFormatter`1.JsonSettings">
            <summary>
            JsonSettings
            </summary>
        </member>
        <member name="P:TouchSocket.Core.JsonBytesToClassSerializerFormatter`1.Order">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.JsonBytesToClassSerializerFormatter`1.TryDeserialize(`0,System.Byte[]@,System.Type,System.Object@)">
            <inheritdoc/>
            <param name="state"></param>
            <param name="source"></param>
            <param name="targetType"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonBytesToClassSerializerFormatter`1.TrySerialize(`0,System.Object@,System.Byte[]@)">
            <inheritdoc/>
            <param name="state"></param>
            <param name="target"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.JsonStringToClassSerializerFormatter`1">
            <summary>
            Json字符串转到对应类
            </summary>
        </member>
        <member name="P:TouchSocket.Core.JsonStringToClassSerializerFormatter`1.Order">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.JsonStringToClassSerializerFormatter`1.JsonSettings">
            <summary>
            JsonSettings
            </summary>
        </member>
        <member name="M:TouchSocket.Core.JsonStringToClassSerializerFormatter`1.TryDeserialize(`0,System.String@,System.Type,System.Object@)">
            <inheritdoc/>
            <param name="state"></param>
            <param name="source"></param>
            <param name="targetType"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.JsonStringToClassSerializerFormatter`1.TrySerialize(`0,System.Object@,System.String@)">
            <inheritdoc/>
            <param name="state"></param>
            <param name="target"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.StringSerializerConverter`1">
            <summary>
            String类型数据转换器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.StringSerializerConverter`1.#ctor(TouchSocket.Core.ISerializerFormatter{System.String,`0}[])">
            <summary>
            String类型数据转换器
            </summary>
        </member>
        <member name="T:TouchSocket.Core.StringSerializerConverter">
            <summary>
            String类型数据转换器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.StringSerializerConverter.#ctor(TouchSocket.Core.ISerializerFormatter{System.String,System.Object}[])">
            <summary>
            String类型数据转换器
            </summary>
            <param name="converters"></param>
        </member>
        <member name="T:TouchSocket.Core.StringToPrimitiveSerializerFormatter`1">
            <summary>
            String值转换为基础类型。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.StringToPrimitiveSerializerFormatter`1.Order">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.StringToPrimitiveSerializerFormatter`1.TryDeserialize(`0,System.String@,System.Type,System.Object@)">
            <inheritdoc/>
            <param name="state"></param>
            <param name="source"></param>
            <param name="targetType"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.StringToPrimitiveSerializerFormatter`1.TrySerialize(`0,System.Object@,System.String@)">
            <inheritdoc/>
            <param name="state"></param>
            <param name="target"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.TouchSocketSerializerConverter`2">
            <summary>
            序列化转换器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketSerializerConverter`2.Add(TouchSocket.Core.ISerializerFormatter{`0,`1})">
            <summary>
            添加插件
            </summary>
            <param name="converter">插件</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketSerializerConverter`2.Clear">
            <summary>
            清除所有转化器
            </summary>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketSerializerConverter`2.Deserialize(`1,`0,System.Type)">
            <summary>
            将源数据转换目标类型对象
            </summary>
            <param name="state"></param>
            <param name="source"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketSerializerConverter`2.Serialize(`1,System.Object@)">
            <summary>
            将目标类型对象转换源数据
            </summary>
            <param name="state"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketSerializerConverter`2.Remove(TouchSocket.Core.ISerializerFormatter{`0,`1})">
            <summary>
            移除插件
            </summary>
            <param name="converter"></param>
        </member>
        <member name="M:TouchSocket.Core.TouchSocketSerializerConverter`2.Remove(System.Type)">
            <summary>
            移除插件
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:TouchSocket.Core.XmlStringToClassSerializerFormatter`1">
            <summary>
            Xml字符串转换器
            </summary>
            <typeparam name="TState"></typeparam>
        </member>
        <member name="P:TouchSocket.Core.XmlStringToClassSerializerFormatter`1.Order">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.XmlStringToClassSerializerFormatter`1.TryDeserialize(`0,System.String@,System.Type,System.Object@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.XmlStringToClassSerializerFormatter`1.TrySerialize(`0,System.Object@,System.String@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.AsyncAutoResetEvent">
            <summary>
            异步等待的AutoResetEvent
            WaitOneAsync方法会返回一个task，通过await方式等待
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AsyncAutoResetEvent.#ctor">
            <summary>
            异步等待的AutoResetEvent
            WaitOneAsync方法会返回一个task，通过await方式等待
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AsyncAutoResetEvent.#ctor(System.Boolean)">
            <summary>
            异步等待的AutoResetEvent
            WaitOneAsync方法会返回一个task，通过await方式等待
            </summary>
            <param name="set"></param>
        </member>
        <member name="T:TouchSocket.Core.AsyncManualResetEvent">
            <summary>
            一个手动恢复的异步通知事件
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AsyncManualResetEvent.#ctor">
            <summary>
            一个手动恢复的异步通知事件
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AsyncManualResetEvent.#ctor(System.Boolean)">
            <summary>
             一个手动恢复的异步通知事件
            </summary>
            <param name="set"></param>
        </member>
        <member name="T:TouchSocket.Core.AsyncResetEvent">
            <summary>
            异步AsyncResetEvent
            能够创建一个手动Reset或者自动Reset.
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AsyncResetEvent.#ctor(System.Boolean,System.Boolean)">
            <summary>
            创建一个异步AsyncResetEvent
            </summary>
            <param name="initialState">是否包含初始信号</param>
            <param name="autoReset">是否自动重置</param>
        </member>
        <member name="M:TouchSocket.Core.AsyncResetEvent.WaitOneAsync">
            <summary>
            异步等待设置此事件
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AsyncResetEvent.WaitOneAsync(System.TimeSpan)">
             <summary>
            异步等待指定时间
             </summary>
             <param name="millisecondsTimeout">超时时间</param>
        </member>
        <member name="M:TouchSocket.Core.AsyncResetEvent.WaitOneAsync(System.Threading.CancellationToken)">
            <summary>
            异步等待可取消
            </summary>
            <param name="cancellationToken">可取消令箭</param>
        </member>
        <member name="M:TouchSocket.Core.AsyncResetEvent.Reset">
            <summary>
            重置
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AsyncResetEvent.Set">
            <summary>
            设置信号
            </summary>
        </member>
        <member name="M:TouchSocket.Core.AsyncResetEvent.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.EasyTask">
            <summary>
            EasyTask 类简化了对异步任务的处理，提供了简便的静态方法来创建和操作任务。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.EasyTask.#cctor">
            <summary>
            EasyTask 类的静态构造函数，在类加载时初始化 CompletedTask 属性。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.EasyTask.CompletedTask">
            <summary>
            获取一个已成功完成的空 Task 对象。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.EasyTask.FromCanceled(System.Threading.CancellationToken)">
            <summary>
            根据提供的取消令牌创建一个已取消的 Task。
            </summary>
            <param name="cancellationToken">用于取消操作的取消令牌。</param>
            <returns>一个表示已取消任务的 Task 对象。</returns>
        </member>
        <member name="M:TouchSocket.Core.EasyTask.FromCanceled``1(System.Threading.CancellationToken)">
            <summary>
            根据提供的取消令牌创建一个已取消的 Task，该任务返回指定类型的结果。
            </summary>
            <typeparam name="T">任务返回的结果类型。</typeparam>
            <param name="cancellationToken">用于取消操作的取消令牌。</param>
            <returns>一个表示已取消任务的 Task 对象，带有指定类型的结果。</returns>
        </member>
        <member name="T:TouchSocket.Core.EasyValueTask">
            <summary>
            定义了一个简化版本的ValueTask工具类。
            该类提供了一些静态方法来创建ValueTask对象，旨在优化性能并简化异步编程。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.EasyValueTask.#cctor">
            <summary>
            类的静态构造函数，用于初始化静态字段。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.EasyValueTask.CompletedTask">
            <summary>
            获取一个表示已完成任务的静态属性。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.EasyValueTask.FromResult``1(``0)">
            <summary>
            根据指定的结果创建一个ValueTask对象。
            </summary>
            <param name="result">作为ValueTask结果的值。</param>
            <typeparam name="TResult">ValueTask结果的类型。</typeparam>
            <returns>一个新的ValueTask对象，其结果被指定为传入的result参数。</returns>
        </member>
        <member name="T:TouchSocket.Core.ReadLock">
            <summary>
            读取锁
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ReadLock.#ctor(System.Threading.ReaderWriterLockSlim)">
            <summary>
            构造函数
            </summary>
            <param name="locks"></param>
        </member>
        <member name="M:TouchSocket.Core.ReadLock.Dispose">
            <summary>
            释放
            </summary>
        </member>
        <member name="T:TouchSocket.Core.WriteLock">
            <summary>
            写入锁
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WriteLock.#ctor(System.Threading.ReaderWriterLockSlim)">
            <summary>
            构造函数
            </summary>
            <param name="locks"></param>
        </member>
        <member name="M:TouchSocket.Core.WriteLock.Dispose">
            <summary>
            释放
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ManualResetValueTaskSourceCore`1">
            <summary>Provides the core logic for implementing a manual-reset <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/> or <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/>.</summary>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="F:TouchSocket.Core.ManualResetValueTaskSourceCore`1._continuation">
            <summary>
            The callback to invoke when the operation completes if <see cref="M:TouchSocket.Core.ManualResetValueTaskSourceCore`1.OnCompleted(System.Action{System.Object},System.Object,System.Int16,System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags)"/> was called before the operation completed,
            or <see cref="F:TouchSocket.Core.ManualResetValueTaskSourceCoreShared.s_sentinel"/> if the operation completed before a callback was supplied,
            or null if a callback hasn't yet been provided and the operation hasn't yet completed.
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ManualResetValueTaskSourceCore`1._continuationState">
            <summary>State to pass to <see cref="F:TouchSocket.Core.ManualResetValueTaskSourceCore`1._continuation"/>.</summary>
        </member>
        <member name="F:TouchSocket.Core.ManualResetValueTaskSourceCore`1._executionContext">
            <summary><see cref="T:System.Threading.ExecutionContext"/> to flow to the callback, or null if no flowing is required.</summary>
        </member>
        <member name="F:TouchSocket.Core.ManualResetValueTaskSourceCore`1._capturedContext">
            <summary>
            A "captured" <see cref="T:System.Threading.SynchronizationContext"/> or <see cref="T:System.Threading.Tasks.TaskScheduler"/> with which to invoke the callback,
            or null if no special context is required.
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ManualResetValueTaskSourceCore`1._completed">
            <summary>Whether the current operation has completed.</summary>
        </member>
        <member name="F:TouchSocket.Core.ManualResetValueTaskSourceCore`1._result">
            <summary>The result with which the operation succeeded, or the default value if it hasn't yet completed or failed.</summary>
        </member>
        <member name="F:TouchSocket.Core.ManualResetValueTaskSourceCore`1._error">
            <summary>The exception with which the operation failed, or null if it hasn't yet completed or completed successfully.</summary>
        </member>
        <member name="F:TouchSocket.Core.ManualResetValueTaskSourceCore`1._version">
            <summary>The current version of this value, used to help prevent misuse.</summary>
        </member>
        <member name="P:TouchSocket.Core.ManualResetValueTaskSourceCore`1.RunContinuationsAsynchronously">
            <summary>Gets or sets whether to force continuations to run asynchronously.</summary>
            <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>
        </member>
        <member name="M:TouchSocket.Core.ManualResetValueTaskSourceCore`1.Reset">
            <summary>Resets to prepare for the next operation.</summary>
        </member>
        <member name="M:TouchSocket.Core.ManualResetValueTaskSourceCore`1.SetResult(`0)">
            <summary>Completes with a successful result.</summary>
            <param name="result">The result.</param>
        </member>
        <member name="M:TouchSocket.Core.ManualResetValueTaskSourceCore`1.SetException(System.Exception)">
            <summary>Complets with an error.</summary>
            <param name="error"></param>
        </member>
        <member name="P:TouchSocket.Core.ManualResetValueTaskSourceCore`1.Version">
            <summary>Gets the operation version.</summary>
        </member>
        <member name="M:TouchSocket.Core.ManualResetValueTaskSourceCore`1.GetStatus(System.Int16)">
            <summary>Gets the status of the operation.</summary>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
        </member>
        <member name="M:TouchSocket.Core.ManualResetValueTaskSourceCore`1.GetResult(System.Int16)">
            <summary>Gets the result of the operation.</summary>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
        </member>
        <member name="M:TouchSocket.Core.ManualResetValueTaskSourceCore`1.OnCompleted(System.Action{System.Object},System.Object,System.Int16,System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags)">
            <summary>Schedules the continuation action for this operation.</summary>
            <param name="continuation">The continuation to invoke when the operation has completed.</param>
            <param name="state">The state object to pass to <paramref name="continuation"/> when it's invoked.</param>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
            <param name="flags">The flags describing the behavior of the continuation.</param>
        </member>
        <member name="M:TouchSocket.Core.ManualResetValueTaskSourceCore`1.ValidateToken(System.Int16)">
            <summary>Ensures that the specified token matches the current version.</summary>
            <param name="token">The token supplied by <see cref="T:System.Threading.Tasks.ValueTask"/>.</param>
        </member>
        <member name="M:TouchSocket.Core.ManualResetValueTaskSourceCore`1.SignalCompletion">
            <summary>Signals that the operation has completed.  Invoked after the result or error has been set.</summary>
        </member>
        <member name="M:TouchSocket.Core.ManualResetValueTaskSourceCore`1.InvokeContinuation">
            <summary>
            Invokes the continuation with the appropriate captured context / scheduler.
            This assumes that if <see cref="F:TouchSocket.Core.ManualResetValueTaskSourceCore`1._executionContext"/> is not null we're already
            running within that <see cref="T:System.Threading.ExecutionContext"/>.
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ValueTaskSource`1">
            <summary>
            提供异步操作的值任务源抽象类。
            </summary>
            <typeparam name="TResult">结果类型。</typeparam>
        </member>
        <member name="F:TouchSocket.Core.ValueTaskSource`1.s_continuationCompleted">
            <summary>
            表示继续操作已完成的静态操作委托。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ValueTaskSource`1.m_continuation">
            <summary>
            异步操作继续操作委托。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ValueTaskSource`1.m_exceptionDispatchInfo">
            <summary>
            异常分发信息。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ValueTaskSource`1.m_tokenRegistration">
            <summary>
            取消令牌注册。
            </summary>
        </member>
        <member name="F:TouchSocket.Core.ValueTaskSource`1.m_userState">
            <summary>
            用户状态对象。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueTaskSource`1.ExceptionDispatchInfo">
            <summary>
            获取异常分发信息。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueTaskSource`1.GetResult">
            <summary>
            获取结果。
            </summary>
            <returns>操作结果。</returns>
        </member>
        <member name="M:TouchSocket.Core.ValueTaskSource`1.Cancel">
            <summary>
            取消操作。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueTaskSource`1.Reset">
            <summary>
            重置操作状态。
            </summary>
        </member>
        <member name="M:TouchSocket.Core.ValueTaskSource`1.Complete(System.Boolean)">
            <summary>
            完成操作。
            </summary>
            <param name="scheduler">是否使用调度器。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueTaskSource`1.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.ValueTaskSource`1.Scheduler(System.Action{System.Object},System.Object)">
            <summary>
            调度继续操作。
            </summary>
            <param name="action">继续操作委托。</param>
            <param name="state">状态对象。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueTaskSource`1.SetException(System.Exception)">
            <summary>
            设置异常。
            </summary>
            <param name="exception">异常对象。</param>
        </member>
        <member name="M:TouchSocket.Core.ValueTaskSource`1.ValueWaitAsync(System.Threading.CancellationToken)">
            <summary>
            值等待异步操作。
            </summary>
            <param name="token">取消令牌。</param>
            <returns>值任务。</returns>
        </member>
        <member name="M:TouchSocket.Core.ValueTaskSource`1.System#Threading#Tasks#Sources#IValueTaskSource{TResult}#GetResult(System.Int16)">
            <summary>
            获取结果。
            </summary>
            <param name="token">令牌。</param>
            <returns>操作结果。</returns>
        </member>
        <member name="M:TouchSocket.Core.ValueTaskSource`1.System#Threading#Tasks#Sources#IValueTaskSource{TResult}#GetStatus(System.Int16)">
            <summary>
            获取状态。
            </summary>
            <param name="token">令牌。</param>
            <returns>操作状态。</returns>
        </member>
        <member name="M:TouchSocket.Core.ValueTaskSource`1.System#Threading#Tasks#Sources#IValueTaskSource{TResult}#OnCompleted(System.Action{System.Object},System.Object,System.Int16,System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags)">
            <summary>
            操作完成时调用。
            </summary>
            <param name="continuation">继续操作委托。</param>
            <param name="state">状态对象。</param>
            <param name="token">令牌。</param>
            <param name="flags">标志。</param>
        </member>
        <member name="T:TouchSocket.Core.IWaitData`1">
            <summary>
            IWaitData
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:TouchSocket.Core.IWaitData`1.Status">
            <summary>
            等待对象的状态
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IWaitData`1.WaitResult">
            <summary>
            等待结果
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IWaitData`1.Cancel">
            <summary>
            取消等待
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IWaitData`1.Reset">
            <summary>
            Reset。
            设置<see cref="P:TouchSocket.Core.IWaitData`1.WaitResult"/>为null。然后重置状态为<see cref="F:TouchSocket.Core.WaitDataStatus.Default"/>
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IWaitData`1.Set">
            <summary>
            使等待的线程继续执行
            </summary>
        </member>
        <member name="M:TouchSocket.Core.IWaitData`1.Set(`0)">
            <summary>
            使等待的线程继续执行
            </summary>
            <param name="waitResult">等待结果</param>
        </member>
        <member name="M:TouchSocket.Core.IWaitData`1.SetCancellationToken(System.Threading.CancellationToken)">
            <summary>
            加载取消令箭
            </summary>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:TouchSocket.Core.IWaitData`1.SetResult(`0)">
            <summary>
            载入结果
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IWaitHandle">
            <summary>
            定义了等待句柄接口，用于同步或异步操作的等待机制。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IWaitHandle.Sign">
            <summary>
            获取或设置等待句柄的唯一标志。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.IWaitResult">
            <summary>
            等待返回类
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IWaitResult.Message">
            <summary>
            消息
            </summary>
        </member>
        <member name="P:TouchSocket.Core.IWaitResult.Status">
            <summary>
            状态
            </summary>
        </member>
        <member name="T:TouchSocket.Core.ValueWaitResult">
            <summary>
            ValueWaitResult
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueWaitResult.Message">
            <summary>
            消息
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueWaitResult.Sign">
            <summary>
            标记号
            </summary>
        </member>
        <member name="P:TouchSocket.Core.ValueWaitResult.Status">
            <summary>
            状态
            </summary>
        </member>
        <member name="T:TouchSocket.Core.WaitData`1">
            <summary>
            等待数据对象
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.#ctor">
            <summary>
            WaitData
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitData`1.Status">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.WaitData`1.WaitResult">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.Cancel">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.Reset">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.Set">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.Set(`0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.SetCancellationToken(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.SetResult(`0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.Wait(System.TimeSpan)">
            <summary>
            等待指定时间
            </summary>
            <param name="timeSpan"></param>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.Wait(System.Int32)">
            <summary>
            等待指定毫秒
            </summary>
            <param name="millisecond"></param>
        </member>
        <member name="M:TouchSocket.Core.WaitData`1.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.WaitData">
            <summary>
            等待数据对象
            </summary>
        </member>
        <member name="T:TouchSocket.Core.WaitDataAsync`1">
            <summary>
            等待数据对象
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:TouchSocket.Core.WaitDataAsync`1.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitDataAsync`1.Status">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.WaitDataAsync`1.WaitResult">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitDataAsync`1.Cancel">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitDataAsync`1.Reset">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitDataAsync`1.Set">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitDataAsync`1.Set(`0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitDataAsync`1.SetCancellationToken(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitDataAsync`1.SetResult(`0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Core.WaitDataAsync`1.WaitAsync(System.TimeSpan)">
            <summary>
            等待指定时间
            </summary>
            <param name="timeSpan"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.WaitDataAsync`1.WaitAsync(System.Int32)">
            <summary>
            等待指定毫秒
            </summary>
            <param name="millisecond"></param>
        </member>
        <member name="M:TouchSocket.Core.WaitDataAsync`1.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.WaitDataAsync">
            <summary>
            等待数据对象
            </summary>
        </member>
        <member name="T:TouchSocket.Core.WaitDataStatus">
            <summary>
            等待数据状态
            </summary>
        </member>
        <member name="F:TouchSocket.Core.WaitDataStatus.Default">
            <summary>
            默认
            </summary>
        </member>
        <member name="F:TouchSocket.Core.WaitDataStatus.SetRunning">
            <summary>
            收到信号运行
            </summary>
        </member>
        <member name="F:TouchSocket.Core.WaitDataStatus.Overtime">
            <summary>
            超时
            </summary>
        </member>
        <member name="F:TouchSocket.Core.WaitDataStatus.Canceled">
            <summary>
            已取消
            </summary>
        </member>
        <member name="F:TouchSocket.Core.WaitDataStatus.Disposed">
            <summary>
            已释放
            </summary>
        </member>
        <member name="T:TouchSocket.Core.WaitDataStatusExtension">
            <summary>
            WaitDataStatusExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WaitDataStatusExtension.ThrowIfNotRunning(TouchSocket.Core.WaitDataStatus)">
            <summary>
            当状态不是<see cref="F:TouchSocket.Core.WaitDataStatus.SetRunning"/>时抛出异常。
            </summary>
            <param name="status"></param>
        </member>
        <member name="T:TouchSocket.Core.WaitHandlePool`1">
            <summary>
            WaitHandlePool 类用于管理具有等待句柄的资源，提供了一种线程安全的资源分配和回收机制。
            它的目的是优化资源使用，通过重用资源来减少创建和销毁资源的开销。
            </summary>
            <typeparam name="T">资源类型，必须实现 IWaitHandle 接口。</typeparam>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.#ctor">
            <summary>
            初始化WaitHandle池。
            </summary>
            <remarks>
            在构造函数中，初始化了四个并发集合，用于管理和存储等待数据。
            这些集合分别用于同步和异步操作的等待数据，以及它们之间的转换。
            </remarks>
        </member>
        <member name="P:TouchSocket.Core.WaitHandlePool`1.MaxSign">
            <summary>
            最大Sign
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitHandlePool`1.MinSign">
            <summary>
            最小Sign
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.CancelAll">
            <summary>
            取消全部
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.Destroy(TouchSocket.Core.WaitData{`0})">
            <summary>
            销毁
            </summary>
            <param name="waitData"></param>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.Destroy(TouchSocket.Core.WaitDataAsync{`0})">
            <summary>
            销毁
            </summary>
            <param name="waitData"></param>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.GetWaitData(`0,System.Boolean)">
            <summary>
            获取同步等待数据对象，并为其设置结果。
            </summary>
            <param name="result">要设置给等待数据对象的结果。</param>
            <param name="autoSign">是否自动签名，默认为true。</param>
            <returns>初始化后的等待数据对象。</returns>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.GetWaitData(System.Int32@)">
            <summary>
            获取同步等待数据对象，并为其设置默认结果。
            </summary>
            <param name="sign">返回签名。</param>
            <returns>初始化后的等待数据对象。</returns>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.GetWaitDataAsync(`0,System.Boolean)">
            <summary>
            获取异步等待数据对象，并为其设置结果。
            </summary>
            <param name="result">要设置给等待数据对象的结果。</param>
            <param name="autoSign">是否自动签名，默认为true。</param>
            <returns>初始化后的等待数据对象。</returns>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.GetWaitDataAsync(System.Int32@)">
            <summary>
            获取异步等待数据对象，并为其设置默认结果。
            </summary>
            <param name="sign">返回签名。</param>
            <returns>初始化后的等待数据对象。</returns>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.SetRun(System.Int32)">
            <summary>
            根据标志设置异步等待数据为运行状态。
            </summary>
            <param name="sign">操作的标志。</param>
            <returns>如果找到并设置等待数据，则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.SetRun(System.Int32,`0)">
            <summary>
            根据标志和结果对象设置等待数据为运行状态。
            </summary>
            <param name="sign">操作的标志。</param>
            <param name="waitResult">等待的结果对象。</param>
            <returns>如果找到并设置等待数据，则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.SetRun(`0)">
            <summary>
            根据结果对象的标志设置异步等待数据为运行状态。
            </summary>
            <param name="waitResult">等待的结果对象，包含标志和数据。</param>
            <returns>如果找到并设置等待数据，则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.TryGetData(System.Int32,TouchSocket.Core.WaitData{`0}@)">
            <summary>
            尝试获取指定标志的同步等待数据。
            </summary>
            <param name="sign">操作的标志。</param>
            <param name="waitData">获取到的等待数据。</param>
            <returns>如果找到等待数据，则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.TryGetDataAsync(System.Int32,TouchSocket.Core.WaitDataAsync{`0}@)">
            <summary>
            尝试获取指定标志的异步等待数据。
            </summary>
            <param name="sign">操作的标志。</param>
            <param name="waitDataAsync">获取到的异步等待数据。</param>
            <returns>如果找到异步等待数据，则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Core.WaitHandlePool`1.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Core.WaitResult">
            <summary>
            等待返回类
            </summary>
        </member>
        <member name="P:TouchSocket.Core.WaitResult.Message">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.WaitResult.Sign">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Core.WaitResult.Status">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Resources.TouchSocketCoreResource">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.Culture">
            <summary>
              重写当前线程的 CurrentUICulture 属性，对
              使用此强类型资源类的所有资源查找执行重写。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.AdapterAlreadyUsed">
            <summary>
              查找类似 此适配器已被其他终端使用，请重新创建对象。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.ArgumentIsNull">
            <summary>
              查找类似 参数‘{0}’为空。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.BlockReaderNotAllowReading">
            <summary>
              查找类似 当前读取器不允许读取。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.ConfigIsNull">
            <summary>
              查找类似 配置文件为空。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.Default">
            <summary>
              查找类似 默认情况。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.ExceptionOccurred">
            <summary>
              查找类似 发生异常，信息：‘{0}’。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.FileNotExists">
            <summary>
              查找类似 文件‘{0}’不存在。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.FileOnlyWrittenTo">
            <summary>
              查找类似 该路径’{0}‘的文件已经被加载为仅写入模式。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.FileReadOnly">
            <summary>
              查找类似 该路径’{0}‘的文件已经被加载为仅读取模式。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.InvalidEnum">
            <summary>
              查找类似 对于枚举类型：‘{0}’，设置了无效的枚举值‘{1}’。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.InvalidParameter">
            <summary>
              查找类似 参数‘{0}’的值是无效参数。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.MemoryGetArrayFail">
            <summary>
              查找类似 应为由数组支持的缓冲区。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.MessageNotFound">
            <summary>
              查找类似 Token消息为‘{0}’的未注册。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.NotFindPublicConstructor">
            <summary>
              查找类似 没有找到类型‘{0}’的公共构造函数。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.ObjectDisposed">
            <summary>
              查找类似 类型为’{0}‘，HashCode为’{1}‘的对象实例已被释放。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.OperationCanceled">
            <summary>
              查找类似 操作已被取消。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.OperationOvertime">
            <summary>
              查找类似 操作超时。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.OperationSuccessful">
            <summary>
              查找类似 操作成功。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.ResultToString">
            <summary>
              查找类似 类型：{0}，信息：{1} 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.StreamNotFind">
            <summary>
              查找类似 没有找到路径‘{0}’对应的流文件。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.StreamReferencing">
            <summary>
              查找类似 路径‘{0}’对应的流文件，仍然被‘{1}’对象应用。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.StringParseToTypeFail">
            <summary>
              查找类似 无法将字符串’{0}‘转为类型’{1}‘。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.TokenExisted">
            <summary>
              查找类似 Token消息为‘{0}’的已注册。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.UnknownError">
            <summary>
              查找类似 未知错误。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.UnregisteredType">
            <summary>
              查找类似 无法创建未被注册的类型‘{0}’的实例。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.ValueBetweenAnd">
            <summary>
              查找类似 参数‘{0}’的值为’{1}‘，超出‘{2}’到‘{3}’的范围。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.ValueLessThan">
            <summary>
              查找类似 参数‘{0}’的值为’{1}‘，小于‘{2}’。 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketCoreResource.ValueMoreThan">
            <summary>
              查找类似 参数‘{0}’的值为’{1}‘，大于‘{2}’。 的本地化字符串。
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>
            表示方法在返回特定值时不会返回 null。
            </summary>
            <remarks>
            该属性用于对方法的返回值进行说明，即在方法返回特定值时，其返回的对象不会是 null。
            这对于代码分析工具和编译器来说，是一个重要的元数据，可以帮助提高代码质量和安全性。
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            初始化 NotNullWhenAttribute 类的实例。
            </summary>
            <param name="returnValue">
            表示当方法返回此值时，方法的返回对象不会是 null。
            </param>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>
            指示方法不会返回值的属性。
            </summary>
            <remarks>
            此属性用于指示方法在正常执行过程中不会返回控制权，例如，因为它会引发异常或执行无限循环。
            </remarks>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes">
            <summary>
            
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All">
            <summary>
            Specifies all members.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None">
            <summary>
            Specifies no members.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicParameterlessConstructor">
            <summary>
            Specifies the default, parameterless public constructor.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors">
            <summary>
            Specifies all public constructors.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors">
            <summary>
            Specifies all non-public constructors.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods">
            <summary>
            Specifies all public methods.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods">
            <summary>
            Specifies all non-public methods.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields">
            <summary>
            Specifies all public fields.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields">
            <summary>
            Specifies all non-public fields.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicNestedTypes">
            <summary>
            Specifies all public nested types.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicNestedTypes">
            <summary>
            Specifies all non-public nested types.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties">
            <summary>
            Specifies all public properties.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties">
            <summary>
            Specifies all non-public properties.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents">
            <summary>
            Specifies all public events.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents">
            <summary>
            Specifies all non-public events.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.Interfaces">
            <summary>
            Specifies all interfaces implemented by the type.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute">
            <summary>
            Indicates that certain members on a specified System.Type are accessed dynamically,
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute.#ctor(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)">
            <summary>
            Initializes a new instance of the System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute
            </summary>
            <param name="memberTypes"></param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute.MemberTypes">
            <summary>
             Gets the System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes that
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>
            表示当指定成员不为 null 时，方法返回特定值的属性。
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>
            初始化 <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute"/> 类的新实例，适用于单个成员。
            </summary>
            <param name="returnValue">预期的方法返回值。</param>
            <param name="member">表示成员的字符串。</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>
            初始化 <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute"/> 类的新实例，适用于多个成员。
            </summary>
            <param name="returnValue">预期的方法返回值。</param>
            <param name="members">表示成员的字符串数组。</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>
            获取成员的数组，这些成员在方法返回特定值时不应为 null。
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>
            获取当指定成员不为 null 时，方法预期返回的值。
            </summary>
        </member>
    </members>
</doc>
